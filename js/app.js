/* ============================================
   MYTHRAS CLASSIC FANTASY CHARACTER SHEET
   Main Application Controller
   ============================================ */

const App = {
  // Current character data
  character: null,
  
  // Current sheet type
  sheetType: 'human',
  
  // Track active ability effects (to prevent stacking and enable removal)
  activeAbilityEffects: {},
  
  // Flag to track if we're in the middle of initialization
  isInitializing: false,
  
  // Ability effects configuration - abilities that modify stats/skills
  ABILITY_EFFECTS: {
    'agile': {
      description: '+4 Initiative (when Unburdened, light armor, 50%+ Evade/Acrobatics)',
      apply: function(app) {
        app.updateAgileDisplay();
      },
      remove: function(app) {
        // Force removal by ensuring displayed flag matches reality
        app.updateAgileDisplay();
      }
    },
    'artful dodger': {
      description: '+10 Evade (when Unburdened)',
      apply: function(app) {
        app.updateArtfulDodgerDisplay();
      },
      remove: function(app) {
        app.updateArtfulDodgerDisplay();
      }
    },
    'lightning reflexes': {
      description: '+10 Evade (when Extremely Unburdened + No Armor, Monk only)',
      apply: function(app) {
        app.updateLightningReflexesDisplay();
        app.checkMonkAbilitiesVisibility();
      },
      remove: function(app) {
        app.updateLightningReflexesDisplay();
        app.checkMonkAbilitiesVisibility();
      }
    },
    'graceful strike': {
      description: 'DEX+POW Damage Modifier for Unarmed if higher (Extremely Unburdened + No Armor)',
      apply: function(app) {
        app.checkMonkAbilitiesVisibility();
      },
      remove: function(app) {
        app._applyGracefulStrikeDM(false, 0);
        app.checkMonkAbilitiesVisibility();
      }
    },
    'ki strike': {
      description: 'Unarmed attacks count as magical weapons',
      apply: function(app) {
        app._applyKiStrikeTrait(true);
        app.checkMonkAbilitiesVisibility();
      },
      remove: function(app) {
        app._applyKiStrikeTrait(false);
        app.checkMonkAbilitiesVisibility();
      }
    },
    'slow fall': {
      description: 'Ignore fall damage up to ½ Mysticism in feet',
      apply: function(app) {
        app.checkMonkAbilitiesVisibility();
      },
      remove: function(app) {
        app.checkMonkAbilitiesVisibility();
      }
    },
    'very agile': {
      description: '+1/10 Mysticism to Initiative (min +5, Extremely Unburdened + No Armor)',
      apply: function(app) {
        app.updateVeryAgileDisplay();
        app.checkMonkAbilitiesVisibility();
      },
      remove: function(app) {
        app.updateVeryAgileDisplay();
        app.checkMonkAbilitiesVisibility();
      }
    },
    'arrowcut': {
      description: 'Parry arrows/darts/spears at Standard Difficulty (Extremely Unburdened + No Armor)',
      apply: function(app) {
        app.checkMonkAbilitiesVisibility();
      },
      remove: function(app) {
        app.checkMonkAbilitiesVisibility();
      }
    },
    'nether walk': {
      description: 'Teleport up to 1/10 Mysticism in feet, 1/day',
      apply: function(app) {
        app.checkNertherWalkVisibility();
        app.checkMonkAbilitiesVisibility();
      },
      remove: function(app) {
        app.checkNertherWalkVisibility();
        app.checkMonkAbilitiesVisibility();
      }
    },
    'quivering palm': {
      description: 'Kill with a touch — 1/week, Extremely Unburdened + No Armor',
      apply: function(app) {
        app.checkQuiveringPalmVisibility();
      },
      remove: function(app) {
        app.checkQuiveringPalmVisibility();
      }
    },
    'perfection': {
      description: '10 pts magical armor, ethereal 20 rds/day, immune to Charm, no Aging penalties',
      apply: function(app) {
        app.checkPerfectionVisibility();
      },
      remove: function(app) {
        // Deactivate if active when ability is removed
        if (app.character.perfectionActive) {
          app._restorePerfectionAP();
          app.character.perfectionActive = false;
        }
        app.checkPerfectionVisibility();
      }
    },
    'weapon precision': {
      description: 'Use higher of STR+DEX or STR+SIZ for Damage Modifier with finesse weapons',
      // List of weapons that benefit from Weapon Precision
      eligibleWeapons: ['club', 'dagger', 'garrote', 'knife', 'shortsword', 'short sword', 'main gauche', 'main-gauche', 'rapier', 'unarmed', 'dart', 'sling', 'short bow', 'shortbow', 'javelin'],
      apply: function(app) {
        const strVal = parseInt(document.getElementById('str-value')?.value, 10) || 0;
        const sizVal = parseInt(document.getElementById('siz-value')?.value, 10) || 0;
        const dexVal = parseInt(document.getElementById('dex-value')?.value, 10) || 0;
        
        const strSiz = strVal + sizVal;
        const strDex = strVal + dexVal;
        
        // Get damage modifier for each
        const dmgStrSiz = app.getDamageModifierForSum(strSiz);
        const dmgStrDex = app.getDamageModifierForSum(strDex);
        
        // Use whichever is higher on the progression
        const wpDmg = app.getHigherDamageMod(dmgStrDex, dmgStrSiz);
        
        // Show the WP Damage Mod row
        const wpRow = document.getElementById('wp-damage-row');
        const wpOrigField = document.getElementById('wp-damage-mod-original');
        const wpCurrField = document.getElementById('wp-damage-mod-current');
        
        if (wpRow && wpOrigField && wpCurrField) {
          // Always show WP row when ability is active, with higher modifier
          wpRow.style.display = '';
          wpOrigField.value = wpDmg;
          wpCurrField.value = wpDmg;
          
          // Store values for comparison/removal
          app.activeAbilityEffects['weapon precision'].strDexDamage = dmgStrDex;
          app.activeAbilityEffects['weapon precision'].strSizDamage = dmgStrSiz;
          app.activeAbilityEffects['weapon precision'].wpDamage = wpDmg;
        }
        
        // Update all weapon damage displays to use WP mod for eligible weapons
        if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
          window.WeaponData.updateAllWeaponDamage();
        }
      },
      remove: function(app) {
        // Hide the WP Damage Mod row
        const wpRow = document.getElementById('wp-damage-row');
        if (wpRow) {
          wpRow.style.display = 'none';
        }
        const wpOrigField = document.getElementById('wp-damage-mod-original');
        const wpCurrField = document.getElementById('wp-damage-mod-current');
        if (wpOrigField) wpOrigField.value = '';
        if (wpCurrField) wpCurrField.value = '';
        
        // Update all weapon damage displays to use standard damage mod
        if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
          window.WeaponData.updateAllWeaponDamage();
        }
      }
    },
    'lucky': {
      description: '+1 Luck Point',
      persistent: true, // Don't reapply on recalculation - only apply once when gained
      apply: function(app) {
        const origField = document.getElementById('luck-original');
        const currField = document.getElementById('luck-current');
        if (origField) {
          const origVal = parseInt(origField.value, 10) || 0;
          origField.value = origVal + 1;
        }
        if (currField) {
          const currVal = parseInt(currField.value, 10) || 0;
          currField.value = currVal + 1;
        }
      },
      remove: function(app) {
        const origField = document.getElementById('luck-original');
        const currField = document.getElementById('luck-current');
        if (origField) {
          const origVal = parseInt(origField.value, 10) || 0;
          origField.value = origVal - 1;
        }
        if (currField) {
          const currVal = parseInt(currField.value, 10) || 0;
          currField.value = currVal - 1;
        }
      }
    },
    'gifted': {
      description: '+1 Experience Roll',
      persistent: true, // Don't reapply on recalculation - only apply once when gained
      apply: function(app) {
        const expField = document.getElementById('exp-rolls');
        if (expField) {
          const currVal = parseInt(expField.value, 10) || 0;
          expField.value = currVal + 1;
        }
      },
      remove: function(app) {
        const expField = document.getElementById('exp-rolls');
        if (expField) {
          const currVal = parseInt(expField.value, 10) || 0;
          expField.value = Math.max(0, currVal - 1);
        }
      }
    },
    'resilient': {
      description: 'Hit Points calculated with STR+CON+SIZ instead of CON+SIZ',
      persistent: true, // Only apply once when gained - HP calculation checks for this
      apply: function(app) {
        // Mark Resilient as active - HP calculation in recalculateAll will use STR+CON+SIZ
        // Don't call recalculateAll here - it will be called after ability is applied
      },
      remove: function(app) {
        // Remove Resilient flag - HP calculation will use standard CON+SIZ
        // recalculateAll will be called after ability is removed
      }
    },
    'extra rage i': {
      description: '+1 Berserk Rage use per day',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        // Reduce remaining uses if they exceed the new max
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    },
    'extra rage 1': {
      description: '+1 Berserk Rage use per day',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    },
    'extra rage ii': {
      description: '+1 Berserk Rage use per day (stacks)',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    },
    'extra rage 2': {
      description: '+1 Berserk Rage use per day (stacks)',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    },
    'extra rage iii': {
      description: '+1 Berserk Rage use per day (stacks)',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    },
    'extra rage 3': {
      description: '+1 Berserk Rage use per day (stacks)',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    },
    'extra rage iv': {
      description: '+1 Berserk Rage use per day (stacks)',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    },
    'extra rage 4': {
      description: '+1 Berserk Rage use per day (stacks)',
      apply: function(app) {
        app.updateBerserkRageDisplay();
      },
      remove: function(app) {
        const newMax = app.getMaxRageUses();
        if (app.character.rageUsesRemaining > newMax) {
          app.character.rageUsesRemaining = newMax;
        }
        app.updateBerserkRageDisplay();
      }
    }
  },

  /**
   * Initialize the application
   */
  init() {
    console.log('Initializing Mythras Character Sheet...');
    
    // Set initialization flag to prevent premature bonus applications
    this.isInitializing = true;
    
    // Check storage availability
    if (!StorageManager.isStorageAvailable()) {
      console.warn('LocalStorage not available. Auto-save disabled.');
    }
    
    // Load existing character or create new
    this.character = StorageManager.load() || StorageManager.createEmptyCharacter();
    this.sheetType = this.character.sheetType || 'human';
    
    // Set up the UI
    this.setupNavigation();
    this.setupSheetTypeSelector();
    this.setupAttributeListeners();
    this.setupAutoSave();
    this.setupImageUploads();
    this.setupButtons();
    
    // Generate dynamic content
    this.generateAlignments();
    this.generatePassions();
    this.generateOaths();
    this.generateLanguages();
    this.generateProfessionalSkills();
    this.generateEquipmentRows();
    this.setupContainerModal();
    this.generateHitLocations();
    this.generateWeaponRows();
    this.generateSpecialAbilities();
    this.generateSpellRows();
    
    // Setup money listeners
    this.setupMoneyListeners();
    
    // Setup magic skill sync between pages (sets up listeners)
    this.setupMagicSkillSync();
    
    // Populate form with loaded data
    this.populateForm();
    
    // Add dice buttons to skill rows (after dynamic content is generated)
    this.addSkillDiceButtons();
    
    // Add ℹ info buttons to skill rows
    this.addSkillInfoButtons();
    
    // Ensure Unarmed is always present as a melee weapon
    this.ensureUnarmedWeapon();
    
    // Populate species abilities section based on current species
    this.initSpeciesAbilities();
    
    // Sync magic skill values after form is populated
    this.syncMagicSkillValues();
    
    // Validate multiclass restrictions (without showing warnings on load)
    this.updateMulticlassFieldStates();
    
    // Update combat skill name and weapons from classes (if not already set)
    this.updateCombatSkillName();
    this.updateWeaponsKnown();
    this.updateRankName();
    this.updatePrereqKeys();
    this.updateMagicVisibility();
    
    // Setup magic skill sync listeners (for two-way sync between magic page and professional skills)
    this.setupMagicSkillSyncListeners();
    
    // Auto-add magic skills to professional skills based on class
    this.autoAddMagicSkillsToProfessional();
    
    // Sync Professional Skills values to Magic page (must happen after populateForm and autoAdd)
    this.syncProfessionalSkillsToMagicPage();
    
    // Clean up orphaned class features (Cants without abilities, etc.)
    this.cleanupOrphanedClassFeatures();
    
    // Restore last viewed page (after magic visibility so we don't restore hidden pages)
    this.restoreCurrentPage();
    
    // Update container button visibility
    this.updateContainerButtons();
    
    // Setup prereq label click handlers
    this.setupPrereqLabelClicks();
    
    // Setup attribute info buttons
    this.setupAttributeInfoButtons();
    
    // Setup summary page
    this.setupSummaryPage();
    
    // Setup notes page
    this.setupNotesPage();
    
    // Setup EXP spending modal
    this.setupExpModal();
    
    // Setup alphabetize button
    this.setupAlphabetizeButton();
    
    // Setup add row buttons
    this.setupAddRowButtons();
    
    // Setup passion formula listeners
    this.setupPassionFormulaListeners();
    
    // Setup fatigue radio buttons and penalty system
    this.setupFatigueListeners();
    
    // Initial calculations
    this.recalculateAll();
    
    // Restore ability effects (Artful Dodger, etc.) after calculations
    this.restoreAbilityEffects();
    
    // Restore characteristic increase display name if applicable
    this.restoreCharacteristicIncreaseDisplay();
    
    // Compact dynamic sections to only show filled rows
    this.compactDynamicSections();
    
    // Ensure Unarmed is always present in melee weapons
    this.ensureUnarmedWeapon();
    
    // Check if Berserk Rage section should be visible
    this.checkBerserkRageVisibility();
    
    // Check if Forceful Strike section should be visible
    this.checkForcefulStrikeVisibility();
    
    // Check if Brute Strength section should be visible
    this.checkBruteStrengthVisibility();
    
    // Check if Spell-Like Abilities section should be visible
    this.checkSpellLikeAbilitiesVisibility();
    
    // Check if Just a Scratch section should be visible
    this.checkJustAScratchVisibility();
    
    // Check if Mystic Healing section should be visible
    this.checkMysticHealingVisibility();
    
    // Check if Pain Control section should be visible
    this.checkPainControlVisibility();
    this.checkNertherWalkVisibility();
    this.checkQuiveringPalmVisibility();
    this.checkPerfectionVisibility();
    
    // Check if Commanding section should be visible
    this.checkCommandingVisibility();
    this.checkHolyStrikeVisibility();
    this.checkLayOnHandsVisibility();
    this.checkDetectEvilVisibility();
    this.checkCureDiseaseVisibility();
    this.checkDivineProtectionVisibility();
    this.checkCircleOfPowerVisibility();
    this.checkImprovedAimVisibility();
    this.checkSpeciesEnemyVisibility();
    
    // Check if Mental Strength section should be visible
    this.checkMentalStrengthVisibility();
    
    // Check if Turn Undead section should be visible
    this.checkTurnUndeadVisibility();
    
    // Check if Syrin species abilities section should be visible
    this.checkSyrinAbilitiesVisibility();
    
    // Check if Holy Smite section should be visible
    this.checkHolySmiteVisibility();
    
    // Check if Powerful Concentration section should be visible
    this.checkPowerfulConcentrationVisibility();
    
    // Check if Animal Companion section should be visible
    this.checkAnimalCompanionVisibility();
    
    // Check if Shape Change section should be visible
    this.checkShapeChangeVisibility();
    
    // Check if Weapon Specialization section should be visible
    this.checkWeaponSpecVisibility();
    
    // Setup tooltips for ability cards
    this.setupAbilityCardTooltips();
    
    // Final initialization sequence - ensure all ENC-dependent abilities are properly applied
    // Use setTimeout to ensure DOM is fully rendered
    setTimeout(() => {
      // Mark initialization as complete
      this.isInitializing = false;
      
      // Initialize display flags BEFORE any function that might call updateArtfulDodgerDisplay/updateAgileDisplay
      this.artfulDodgerDisplayed = false; // Runtime flag, NOT on this.character
      this.agileDisplayed = false; // Runtime flag, NOT on this.character
      this.lightningReflexesDisplayed = false; // Runtime flag for Lightning Reflexes Evade bonus
      this._lightningReflexesBonus = 0; // Tracked bonus amount (10 + Mysticism/10)
      this.veryAgileDisplayed = false; // Runtime flag for Very Agile Initiative bonus
      this._veryAgileBonus = 0; // Tracked bonus amount (max(5, ceil(Mysticism/10)))
      this._monkQuickBonus = 0; // Runtime flag for Quick movement bonus
      
      // Set up ability effect tracking
      if (this.hasAbility('Artful Dodger')) {
        this.activeAbilityEffects['artful dodger'] = { active: true };
      }
      if (this.hasAbility('Agile')) {
        this.activeAbilityEffects['agile'] = { active: true };
      }
      if (this.hasAbility('Very Agile')) {
        this.activeAbilityEffects['very agile'] = { active: true };
      }
      
      // Force recalculate ENC status - this will also call updateArtfulDodgerDisplay,
      // updateAgileDisplay, and updateVeryAgileDisplay since isInitializing is now false
      this.updateTotalEnc();
      
      // Update MP display on spell pages
      this.updateMagicMPDisplay();
      
      // Highlight specialized weapons on combat page
      this.highlightSpecializedWeapons();
      
      // Restore weapon master tier
      if (this.character.weaponMaster) {
        this.updateWeaponMasterTier();
        this.updateWeaponSpecDisplay();
      }
      
      // Restore active weapon spec VISUALS only (values already saved in localStorage)
      if (this.character.activeWeaponSpecs && this.character.activeWeaponSpecs.length > 0) {
        this.restoreWeaponSpecVisuals();
        this.updateWeaponSpecDisplay();
      }
      
      // Apply ranged weapon load reductions for specializations
      this.applyRangedSpecLoadReduction();
    }, 100);
    
    // Save calculated values (like Resilient HP) after initialization
    this.scheduleAutoSave();
    
    // Update class theme if enabled
    if (typeof window.updateClassThemeAfterLoad === 'function') {
      window.updateClassThemeAfterLoad();
    }
    
    console.log('Initialization complete!');
  },
  
  /**
   * Compact all dynamic sections to only show filled rows
   */
  compactDynamicSections() {
    // Compact Passions
    this.compactSection('passions-container', '.belief-row', '.belief-name');
    
    // Compact Oaths
    this.compactSection('oaths-container', '.belief-row', '.belief-name');
    
    // Compact Professional Skills
    this.compactSection('professional-skills-container', '.professional-skill-row', '.prof-skill-name');
    
    // Compact Languages (but keep native tongue)
    this.compactLanguages();
    
    // Compact Equipment
    this.compactSection('equipment-container', '.equipment-row', '.equipment-name');
    
    // Compact Class Abilities
    this.compactClassAbilities();
    
    // Compact Melee Weapons
    this.compactSection('melee-weapons-body', 'tr', '.weapon-name');
    
    // Compact Ranged Weapons
    this.compactSection('ranged-weapons-body', 'tr', '.weapon-name');
  },
  
  /**
   * Compact a section by removing empty rows
   * @param {string} containerId - ID of the container element
   * @param {string} rowSelector - CSS selector for rows
   * @param {string} dataFieldSelector - CSS selector for the primary data field to check
   */
  compactSection(containerId, rowSelector, dataFieldSelector) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const rows = Array.from(container.querySelectorAll(rowSelector));
    
    rows.forEach(row => {
      const dataField = row.querySelector(dataFieldSelector);
      if (dataField && !dataField.value.trim()) {
        row.remove();
      }
    });
    
    // Reindex remaining rows
    this.reindexSection(containerId, rowSelector);
  },
  
  /**
   * Compact languages section (keep native tongue, remove empty others)
   */
  compactLanguages() {
    const container = document.getElementById('language-container');
    if (!container) return;
    
    const rows = Array.from(container.querySelectorAll('.language-row'));
    
    rows.forEach(row => {
      // Skip native tongue row
      if (row.classList.contains('native')) return;
      
      const nameField = row.querySelector('.language-name');
      if (nameField && !nameField.value.trim()) {
        row.remove();
      }
    });
    
    this.reindexLanguages();
  },
  
  /**
   * Compact class abilities section - remove all empty rows
   */
  compactClassAbilities() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    const rows = Array.from(container.querySelectorAll('.class-ability-row'));
    
    // Remove all empty rows
    rows.forEach(row => {
      const input = row.querySelector('.class-ability-input');
      if (input && !input.value.trim()) {
        row.remove();
      }
    });
    
    this.reindexClassAbilityRows();
  },
  
  /**
   * Reindex rows in a section after compaction
   */
  reindexSection(containerId, rowSelector) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const rows = container.querySelectorAll(rowSelector);
    rows.forEach((row, index) => {
      const oneIndexed = index + 1;
      row.dataset.index = oneIndexed;
      
      // Update IDs for known section types
      if (containerId === 'passions-container') {
        this.updatePassionRowIds(row, oneIndexed);
      } else if (containerId === 'oaths-container') {
        this.updateOathRowIds(row, oneIndexed);
      } else if (containerId === 'alignment-container') {
        this.updateAlignmentRowIds(row, oneIndexed);
      } else if (containerId === 'professional-skills-container') {
        this.updateProfSkillRowIds(row, index);
      } else if (containerId === 'equipment-container') {
        this.updateEquipmentRowIds(row, index);
      } else if (containerId === 'melee-weapons-body' || containerId === 'ranged-weapons-body') {
        // Weapon rows handled separately
      }
    });
  },
  
  updatePassionRowIds(row, num) {
    const name = row.querySelector('.belief-name');
    const formula = row.querySelector('.belief-formula-input');
    const base = row.querySelector('.belief-base');
    const current = row.querySelector('.belief-input');
    
    if (name) name.id = `passion-${num}-name`;
    if (formula) formula.id = `passion-${num}-formula`;
    if (base) base.id = `passion-${num}-base`;
    if (current) current.id = `passion-${num}-current`;
  },
  
  updateOathRowIds(row, num) {
    const name = row.querySelector('.belief-name');
    const base = row.querySelector('.belief-base');
    const current = row.querySelector('.belief-input');
    
    if (name) name.id = `oath-${num}-name`;
    if (base) base.id = `oath-${num}-base`;
    if (current) current.id = `oath-${num}-current`;
  },
  
  updateAlignmentRowIds(row, num) {
    const name = row.querySelector('.belief-name');
    const base = row.querySelector('.belief-base');
    const current = row.querySelector('.belief-input');
    
    if (name) name.id = `alignment-${num}-name`;
    if (base) base.id = `alignment-${num}-base`;
    if (current) current.id = `alignment-${num}-current`;
  },
  
  updateProfSkillRowIds(row, index) {
    const prereq = row.querySelector('.prereq-keys');
    const name = row.querySelector('.prof-skill-name');
    const base = row.querySelector('.prof-skill-base');
    const baseVal = row.querySelector('.prof-skill-base-val');
    const current = row.querySelector('.prof-skill-current');
    const enc = row.querySelector('.prof-enc-indicator');
    
    if (prereq) prereq.id = `prof-skill-${index}-prereq`;
    if (name) name.id = `prof-skill-${index}-name`;
    if (base) base.id = `prof-skill-${index}-base`;
    if (baseVal) baseVal.id = `prof-skill-${index}-base-val`;
    if (current) current.id = `prof-skill-${index}-current`;
    if (enc) enc.id = `prof-skill-${index}-enc`;
  },
  
  updateEquipmentRowIds(row, index) {
    const name = row.querySelector('.equipment-name');
    const enc = row.querySelector('.equipment-enc');
    
    if (name) name.id = `equip-${index}-name`;
    if (enc) enc.id = `equip-${index}-enc`;
  },
  
  reindexLanguages() {
    const container = document.getElementById('language-container');
    if (!container) return;
    
    const rows = container.querySelectorAll('.language-row:not(.native)');
    rows.forEach((row, index) => {
      const num = index + 2; // Start from 2 (native tongue is 1)
      const name = row.querySelector('.language-name');
      const base = row.querySelector('.language-base');
      const current = row.querySelector('.language-input');
      
      if (name) name.id = `language-${num}-name`;
      if (base) base.id = `language-${num}-base`;
      if (current) current.id = `language-${num}-current`;
    });
  },

  /**
   * Track scroll positions per page
   */
  pageScrollPositions: {},
  currentPageId: null,
  
  /**
   * Set up tab navigation
   */
  setupNavigation() {
    const tabs = document.querySelectorAll('.tab-btn');
    const pages = document.querySelectorAll('.sheet-page');
    
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const targetPage = tab.dataset.page;
        
        // Save scroll position of current page before switching
        if (this.currentPageId) {
          this.pageScrollPositions[this.currentPageId] = window.scrollY;
        }
        
        // Update tab states
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Update page visibility
        pages.forEach(page => {
          page.classList.remove('active');
          if (page.id === `page-${targetPage}`) {
            page.classList.add('active');
          }
        });
        
        // Update current page tracker
        this.currentPageId = targetPage;
        
        // Restore scroll position for target page (or scroll to top if none saved)
        const savedScroll = this.pageScrollPositions[targetPage];
        if (savedScroll !== undefined) {
          window.scrollTo(0, savedScroll);
        } else {
          window.scrollTo(0, 0);
        }
        
        // Save current page to localStorage
        try {
          localStorage.setItem('mythras-current-page', targetPage);
        } catch (e) {
          // Ignore storage errors
        }
        
        // Update weapon damages when switching to Combat page
        if (targetPage === 'combat' && window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
          window.WeaponData.updateAllWeaponDamage();
          // Re-apply damage boost styling if any damage-boosting ability is active
          this.reapplyDamageBoostStyling();
        }
        
        // Sync magic skill values when switching to Magic pages
        if (targetPage === 'magic1' || targetPage === 'magic2') {
          this.syncProfessionalSkillsToMagicPage();
        }
        
        // Refresh summary widgets when switching to Summary page
        if (targetPage === 'summary') {
          this.refreshSummaryWidgets();
        }
      });
    });
  },
  
  /**
   * Restore the last viewed page from localStorage
   */
  restoreCurrentPage() {
    try {
      const savedPage = localStorage.getItem('mythras-current-page');
      if (savedPage) {
        const tab = document.querySelector(`.tab-btn[data-page="${savedPage}"]`);
        const page = document.getElementById(`page-${savedPage}`);
        
        // Only restore if tab is visible (not hidden due to magic class restrictions)
        if (tab && page && tab.parentElement.style.display !== 'none') {
          document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
          document.querySelectorAll('.sheet-page').forEach(p => p.classList.remove('active'));
          tab.classList.add('active');
          page.classList.add('active');
          this.currentPageId = savedPage;
        } else {
          // Default to main page
          this.currentPageId = 'main';
        }
      } else {
        // No saved page - default to main
        this.currentPageId = 'main';
      }
      
      // Always scroll to top on fresh load
      window.scrollTo(0, 0);
    } catch (e) {
      // Ignore storage errors
      this.currentPageId = 'main';
      window.scrollTo(0, 0);
    }
  },

  /**
   * Set up sheet type based on species (auto-detect Syrin)
   */
  setupSheetTypeSelector() {
    const selector = document.getElementById('sheet-type-select');
    if (selector) {
      // Hide the selector - it's now automatic based on species
      selector.style.display = 'none';
    }
    
    // Set initial sheet type based on species
    this.updateSheetTypeFromSpecies();
    
    // Set initial sheet type on app element
    document.getElementById('app').dataset.sheetType = this.sheetType;
  },
  
  /**
   * Update sheet type based on species field
   */
  updateSheetTypeFromSpecies(previousSpecies = null, isBlurEvent = false) {
    const speciesInput = document.getElementById('species');
    const species = speciesInput?.value?.trim() || '';
    const speciesLower = species.toLowerCase();
    
    // Determine if Syrin
    const isSyrin = speciesLower.indexOf('syrin') !== -1;
    const newSheetType = isSyrin ? 'syrin' : 'human';
    
    // Update sheet type if changed
    if (this.sheetType !== newSheetType) {
      // Save current hit location data before regenerating
      this.saveHitLocationsToCharacter();
      
      this.sheetType = newSheetType;
      this.character.sheetType = this.sheetType;
      document.getElementById('app').dataset.sheetType = this.sheetType;
      
      // Update the hidden selector value (for consistency)
      const selector = document.getElementById('sheet-type-select');
      if (selector) selector.value = this.sheetType;
      
      // Regenerate hit locations for new type
      this.generateHitLocations();
      
      // Restore hit location data
      this.loadHitLocationsFromCharacter();
    }
    
    // Handle species-specific features
    this.updateSpeciesFeatures(species, previousSpecies, isBlurEvent);
    
    this.recalculateAll();
  },
  
  /**
   * Update species-specific features (movement, flying, abilities)
   */
  updateSpeciesFeatures(newSpecies, previousSpecies = null, isBlurEvent = false) {
    if (!window.SpeciesData) return;
    
    const newSpeciesLower = newSpecies?.toLowerCase().trim() || '';
    const prevSpeciesLower = previousSpecies?.toLowerCase().trim() || '';
    
    // Determine if species actually changed (not just init)
    const speciesActuallyChanged = previousSpecies !== null && prevSpeciesLower !== newSpeciesLower;
    
    // Get species data
    const newData = window.SpeciesData.getSpecies(newSpeciesLower);
    const prevData = previousSpecies ? window.SpeciesData.getSpecies(prevSpeciesLower) : null;
    
    // Update movement rate
    const movementInput = document.getElementById('movement-current');
    if (movementInput && newData) {
      movementInput.value = newData.movement;
    }
    
    // Update flying speed
    const flyingInput = document.getElementById('flying-speed');
    if (flyingInput) {
      if (newData && newData.flyingSpeed) {
        flyingInput.value = newData.flyingSpeed + "'";
      } else {
        flyingInput.value = '';
      }
    }
    
    // Auto-set culture based on species (only when species changes)
    if (speciesActuallyChanged) {
      this.autoSetCultureForSpecies(newSpeciesLower);
    }
    
    // Remove previous species ability effects (only if species actually changed)
    if (speciesActuallyChanged && prevData && prevData.abilities && prevData.abilities.length > 0) {
      prevData.abilities.forEach(ability => {
        this.removeAbilityEffect(ability);
      });
    }
    
    // Only reset species abilities if species actually changed (not during init)
    if (speciesActuallyChanged) {
      // Clear saved species abilities since species changed - use new species defaults
      this.character.speciesAbilities = [];
      
      // Populate the Species Abilities section (replaces old content)
      // Pass true to apply persistent effects since this is a user-initiated species change
      this.populateSpeciesAbilitiesSection(newData ? newData.abilities : [], true);
      
      // Update spell-like section visibility (hide if new species doesn't have it)
      this.checkSpellLikeAbilitiesVisibility();
      
      // Check if new species has Spell-Like Abilities and prompt for selection
      // Only prompt on blur event (not every keystroke)
      if (isBlurEvent && newData && newData.abilities) {
        const hasSpellLike = newData.abilities.some(a => 
          a.toLowerCase().includes('spell-like abilities')
        );
        if (hasSpellLike) {
          // Delay to let the UI update first
          setTimeout(() => this.promptSpellLikeAbilitySelection(), 100);
        }
      }
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Auto-set culture based on species
   * - Human, Half-Elf, Half-Orc: No change (can choose any)
   * - Abyssar, Dwarf, Gnome: Barbarian
   * - Elf, Halfling, Khelmar, Syrin: Civilized
   * - Vulpan: Nomad
   */
  autoSetCultureForSpecies(species) {
    const cultureField = document.getElementById('culture');
    if (!cultureField) return;
    
    // Species with no automatic culture (player's choice)
    const freeChoiceSpecies = ['human', 'half-elf', 'half-orc'];
    if (!species || freeChoiceSpecies.includes(species)) {
      // Don't change culture for these species
      return;
    }
    
    // Species locked to Barbarian
    const barbarianSpecies = ['abyssar', 'dwarf', 'gnome'];
    if (barbarianSpecies.includes(species)) {
      cultureField.value = 'Barbarian';
      return;
    }
    
    // Species locked to Civilized
    const civilizedSpecies = ['elf', 'halfling', 'khelmar', 'syrin'];
    if (civilizedSpecies.includes(species)) {
      cultureField.value = 'Civilized';
      return;
    }
    
    // Vulpan is Nomad
    if (species === 'vulpan') {
      cultureField.value = 'Nomad';
      return;
    }
  },
  
  /**
   * Populate the dedicated Species Abilities section
   * @param {Array} abilities - List of ability names
   * @param {boolean} applyPersistentEffects - If true, apply persistent effects (for species changes after init)
   */
  populateSpeciesAbilitiesSection(abilities, applyPersistentEffects = false) {
    const container = document.getElementById('species-abilities-list');
    if (!container) return;
    
    // Clear existing content
    container.innerHTML = '';
    
    // If no abilities, show a placeholder
    if (!abilities || abilities.length === 0) {
      const placeholder = document.createElement('div');
      placeholder.className = 'species-ability-placeholder';
      placeholder.textContent = 'No species abilities';
      placeholder.style.cssText = 'padding: 0.5rem; color: #999; font-style: italic;';
      container.appendChild(placeholder);
      return;
    }
    
    // Create rows for each ability
    abilities.forEach((ability, index) => {
      const row = document.createElement('div');
      row.className = 'species-ability-row';
      
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'species-ability-input';
      input.id = `species-ability-${index}`;
      input.value = this.toTitleCase(ability);
      input.dataset.abilityName = ability;
      
      // Add event listeners for editing
      input.addEventListener('blur', (e) => {
        const newValue = e.target.value.trim();
        if (newValue) {
          e.target.value = this.toTitleCase(newValue);
          e.target.dataset.abilityName = newValue;
        }
        this.scheduleAutoSave();
        // Update spell-like section if this ability was edited
        this.checkSpellLikeAbilitiesVisibility();
      });
      
      input.addEventListener('input', () => {
        this.scheduleAutoSave();
      });
      
      const infoBtn = document.createElement('button');
      infoBtn.type = 'button';
      infoBtn.className = 'species-ability-info-btn';
      infoBtn.textContent = 'i';
      infoBtn.title = 'View ability details';
      infoBtn.addEventListener('click', () => {
        this.showAbilityDetail(ability);
      });
      
      row.appendChild(input);
      row.appendChild(infoBtn);
      container.appendChild(row);
      
      // Apply ability effect (skip persistent if not requested)
      const baseName = ability.split('(')[0].trim().toLowerCase();
      const effect = this.ABILITY_EFFECTS[baseName];
      if (effect && effect.persistent && !applyPersistentEffects) {
        // Skip persistent effects during init - saved values already include them
        // Just mark as active
        this.activeAbilityEffects[baseName] = { active: true };
      } else {
        this.applyAbilityEffect(ability);
      }
    });
  },
  
  /**
   * Get all species abilities currently displayed
   */
  getSpeciesAbilities() {
    const abilities = [];
    const container = document.getElementById('species-abilities-list');
    if (!container) return abilities;
    
    const inputs = container.querySelectorAll('.species-ability-input');
    inputs.forEach(input => {
      if (input.value.trim()) {
        abilities.push(input.value.trim());
      }
    });
    return abilities;
  },
  
  /**
   * Initialize species abilities section on page load
   */
  initSpeciesAbilities() {
    const speciesInput = document.getElementById('species');
    const species = speciesInput?.value?.trim().toLowerCase() || '';
    
    // Check if there are saved species abilities first
    if (this.character.speciesAbilities && this.character.speciesAbilities.length > 0) {
      this.populateSpeciesAbilitiesSection(this.character.speciesAbilities);
      return;
    }
    
    if (!species || !window.SpeciesData) {
      // Show placeholder for no species
      this.populateSpeciesAbilitiesSection([]);
      return;
    }
    
    const speciesData = window.SpeciesData.getSpecies(species);
    if (speciesData && speciesData.abilities) {
      this.populateSpeciesAbilitiesSection(speciesData.abilities);
    } else {
      this.populateSpeciesAbilitiesSection([]);
    }
  },
  
  /**
   * Check if an ability matches another with fuzzy matching for notes
   * e.g., "Spell-Like Abilities (Produce Flame)" matches "Spell-Like Abilities"
   */
  abilityMatchesFuzzy(abilityWithNotes, baseAbility) {
    if (!abilityWithNotes || !baseAbility) return false;
    
    const normalizedInput = abilityWithNotes.toLowerCase().trim();
    const normalizedBase = baseAbility.toLowerCase().trim();
    
    // Exact match
    if (normalizedInput === normalizedBase) return true;
    
    // Input starts with the base ability
    if (normalizedInput.startsWith(normalizedBase)) return true;
    
    // Base starts with the input (for reverse matching)
    if (normalizedBase.startsWith(normalizedInput)) return true;
    
    return false;
  },

  /**
   * Set up attribute input listeners
   */
  setupAttributeListeners() {
    // Attribute inputs (single value for Characteristics)
    const attrInputs = document.querySelectorAll('.attribute-input');
    attrInputs.forEach(input => {
      input.addEventListener('input', (e) => {
        const attr = e.target.dataset.attr;
        if (attr) {
          this.character.attributes[attr] = e.target.value;
          this.recalculateAll();
          this.scheduleAutoSave();
        }
      });
    });
    
    // Movement input (current only)
    const movementCurrent = document.getElementById('movement-current');
    if (movementCurrent) {
      movementCurrent.addEventListener('input', (e) => {
        // Handle combined ENC + Fatigue penalty
        if (e.target.classList.contains('enc-penalty-init-move') || e.target.classList.contains('fatigue-penalized')) {
          // User is editing while penalized - update original value
          e.target.dataset.originalValue = e.target.value;
          // Re-apply all penalties after a short delay
          setTimeout(() => this.applyAllPenalties(), 10);
        } else if (e.target.dataset.originalValue !== undefined) {
          e.target.dataset.originalValue = e.target.value;
        }
        
        this.character.derived.movementCurrent = e.target.dataset.originalValue || e.target.value;
        this.updateMovementDisplay();
        this.scheduleAutoSave();
      });
    }
    
    // Height input (for jump calculations)
    const heightInput = document.getElementById('height');
    if (heightInput) {
      heightInput.addEventListener('input', (e) => {
        this.character.info.height = e.target.value;
        this.updateJumpDisplay();
        this.scheduleAutoSave();
      });
    }
  },

  /**
   * Set up auto-save for all inputs
   */
  setupAutoSave() {
    // Info fields
    const infoFields = [
      'character-name', 'species', 'culture', 'class-primary', 'class-secondary',
      'class-tertiary', 'rank-name', 'gender', 'age', 'handedness', 'height',
      'weight', 'hair', 'eyes', 'rank-primary', 'rank-secondary', 'rank-tertiary',
      'tenacity-current', 'tenacity-max', 'exp-rolls'
    ];
    
    // Class fields need special handling to update combat skill name
    const classFields = ['class-primary', 'class-secondary', 'class-tertiary'];
    
    // Rank fields need to update rank name and recalculate attributes
    const rankFields = ['rank-primary', 'rank-secondary', 'rank-tertiary'];
    
    // Set up dedicated rank field listeners for immediate recalculation
    rankFields.forEach(fieldId => {
      const field = document.getElementById(fieldId);
      if (field) {
        // Store previous value on focus
        field.addEventListener('focus', () => {
          field.dataset.previousRank = field.value || '0';
        });
        
        const handleRankChange = () => {
          const previousRank = parseInt(field.dataset.previousRank, 10) || 0;
          let newRank = parseInt(field.value, 10) || 0;
          newRank = Math.max(0, Math.min(5, newRank));
          field.value = newRank;
          field.dataset.previousRank = newRank;
          this.character.info[this.camelCase(fieldId)] = newRank;
          
          // Check if rank decreased - need to remove abilities for higher ranks
          if (newRank < previousRank) {
            this.handleRankDecrease(fieldId, previousRank, newRank);
          }
          
          // Snapshot original derived values BEFORE recalculation so we can
          // detect changes and sync current values after recalculate runs
          const apOrigBefore = parseInt(document.getElementById('action-points-original')?.value, 10) || 0;
          const luckOrigBefore = parseInt(document.getElementById('luck-original')?.value, 10) || 0;
          
          this.recalculateAll();
          
          // Sync current AP when original changes from rank-up/down
          this.syncCurrentToDerivedChange('action-points', apOrigBefore);
          this.syncCurrentToDerivedChange('luck', luckOrigBefore);
          
          // Update rage display text (damage steps, fatigue waivers) based on new rank
          if (this.hasAbility('Berserk Rage')) {
            this.updateBerserkRageDisplay();
          }
          
          this.scheduleAutoSave();
        };
        field.addEventListener('input', handleRankChange);
        field.addEventListener('change', handleRankChange);
      }
    });
    
    // Set up species field listener for immediate recalculation and species features update
    const speciesField = document.getElementById('species');
    if (speciesField) {
      // Store initial value for change detection
      speciesField.dataset.previousValue = speciesField.value || '';
      
      let pendingBlurSpeciesChange = false;
      
      const handleSpeciesChange = (isBlurEvent = false) => {
        const previousSpecies = speciesField.dataset.previousValue || '';
        const currentSpecies = speciesField.value || '';
        
        // Only update species features if actually changed
        if (previousSpecies.toLowerCase().trim() !== currentSpecies.toLowerCase().trim()) {
          this.updateSheetTypeFromSpecies(previousSpecies, isBlurEvent);
          speciesField.dataset.previousValue = currentSpecies;
          // If this was from input (not blur), mark that we need blur-specific actions later
          if (!isBlurEvent) {
            pendingBlurSpeciesChange = true;
          }
        } else if (isBlurEvent && pendingBlurSpeciesChange) {
          // The input event already processed the species change, but blur-specific 
          // actions (like the Abyssar spell-like ability modal) still need to run
          pendingBlurSpeciesChange = false;
          const speciesLower = currentSpecies.toLowerCase().trim();
          const speciesData = window.SpeciesData ? window.SpeciesData.getSpecies(speciesLower) : null;
          if (speciesData && speciesData.abilities) {
            const hasSpellLike = speciesData.abilities.some(a => 
              a.toLowerCase().includes('spell-like abilities')
            );
            if (hasSpellLike) {
              setTimeout(() => this.promptSpellLikeAbilitySelection(), 100);
            }
          }
        }
        
        this.recalculateAll();
        this.updateMagicVisibility();
        this.checkSyrinAbilitiesVisibility();
        this.scheduleAutoSave();
      };
      speciesField.addEventListener('input', () => handleSpeciesChange(false));
      speciesField.addEventListener('change', () => handleSpeciesChange(true));
    }
    
    // Set up gender field listener for Cavalier Exotic Mounts check
    const genderField = document.getElementById('gender');
    if (genderField) {
      genderField.addEventListener('change', () => {
        // Check if Cavalier at rank 2+ - if so, re-check Exotic Mounts I eligibility
        const classSlots = [
          { cls: 'class-primary', rank: 'rank-primary' },
          { cls: 'class-secondary', rank: 'rank-secondary' },
          { cls: 'class-tertiary', rank: 'rank-tertiary' }
        ];
        
        for (const slot of classSlots) {
          const className = (document.getElementById(slot.cls)?.value || '').toLowerCase().trim();
          const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
          if (className === 'cavalier' && rank >= 2) {
            this.checkCavalierExoticMountsI();
            break;
          }
        }
      });
    }
    
    infoFields.forEach(fieldId => {
      const field = document.getElementById(fieldId);
      if (field) {
        field.addEventListener('input', (e) => {
          const key = this.camelCase(fieldId);
          this.character.info[key] = e.target.value;
          
          // Clamp rank values to 0-5 (also handled above, but keep for consistency)
          if (rankFields.includes(fieldId)) {
            let val = parseInt(e.target.value, 10);
            if (!isNaN(val)) {
              val = Math.max(0, Math.min(5, val));
              e.target.value = val;
              this.character.info[key] = val;
            }
          }
          
          this.scheduleAutoSave();
        });
        
        // Add blur listener for class fields to validate and update
        if (classFields.includes(fieldId)) {
          // Store previous value to detect changes
          field.addEventListener('focus', (e) => {
            e.target.dataset.previousValue = e.target.value;
            // Store all previous classes for spell tracking
            e.target.dataset.previousClasses = JSON.stringify([
              { name: document.getElementById('class-primary')?.value?.trim().toLowerCase() || '', rank: parseInt(document.getElementById('rank-primary')?.value, 10) || 0 },
              { name: document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '', rank: parseInt(document.getElementById('rank-secondary')?.value, 10) || 0 },
              { name: document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || '', rank: parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0 }
            ]);
          });
          
          field.addEventListener('blur', () => {
            const previousValue = field.dataset.previousValue || '';
            const currentValue = field.value.trim();
            let previousClasses = null;
            try {
              previousClasses = field.dataset.previousClasses ? JSON.parse(field.dataset.previousClasses) : null;
            } catch (e) {
              console.warn('[CLASS BLUR] Error parsing previousClasses:', e);
            }
            
            // Determine corresponding rank field
            const rankFieldId = fieldId.replace('class-', 'rank-');
            const rankField = document.getElementById(rankFieldId);
            
            // If class was cleared, clear the rank too
            if (!currentValue && previousValue) {
              if (rankField) {
                rankField.value = '';
                const rankKey = this.camelCase(rankFieldId);
                this.character.info[rankKey] = '';
              }
            }
            
            // If class was added or changed, prompt for rank
            console.log(`%c[CLASS BLUR] field=${fieldId}, prev="${previousValue}", cur="${currentValue}", willPrompt=${!!(currentValue && currentValue !== previousValue)}`, 'color: #2a9d8f; font-weight: bold');
            if (currentValue && currentValue !== previousValue) {
              this.promptForRank(currentValue, rankFieldId);
            }
            
            // Wrap remaining handlers in try-catch to ensure prompt isn't affected by errors
            try {
              // Validate multiclass restrictions
              this.validateAndUpdateClasses(fieldId);
              this.updateCombatSkillName(true);
              this.updateWeaponsKnown(true);
              this.updateRankName();
              this.updatePrereqKeys();
              this.updateMagicVisibility();
              this.updateSpellMemorization();
              
              // Handle magic skills - remove obsolete ones first, then add new ones
              this.removeObsoleteMagicSkills();
              this.autoAddMagicSkillsToProfessional();
              
              // Update class spells after a brief delay to ensure rank is set
              setTimeout(() => {
                this.updateClassSpells(previousClasses);
                this.updateClassAbilities(previousClasses);
              }, 50);
            } catch (e) {
              console.error('[CLASS BLUR] Error in post-class-change handlers:', e);
            }
            
            this.scheduleAutoSave();
          });
        }
        
        // Species field is handled separately above with input/change listeners
        // Skip adding duplicate listeners here
        if (fieldId === 'species') {
          // Do nothing - handled in the main species listener above
        }
        
        // Add blur listener for rank fields to update rank name and prereq keys
        if (rankFields.includes(fieldId)) {
          field.addEventListener('blur', () => {
            this.updateRankName();
            this.updatePrereqKeys();
            this.updateSpellMemorization();
            this.updateClassSpells();
            this.updateClassAbilities();
            this.scheduleAutoSave();
          });
        }
      }
    });
    
    // Derived stat inputs (editable ones)
    const derivedFields = [
      'action-points-current',
      'damage-mod-current',
      'exp-mod-current',
      'healing-rate-current',
      'initiative-current',
      'luck-current',
      'magic-points-current',
      'tenacity-current'
    ];
    
    // Fields that have original/max values they shouldn't exceed
    const fieldsWithMax = {
      'action-points-current': 'action-points-original',
      'luck-current': 'luck-original',
      'magic-points-current': 'magic-points-original',
      'tenacity-current': 'tenacity-max'
    };
    
    derivedFields.forEach(fieldId => {
      const field = document.getElementById(fieldId);
      if (field) {
        // Enforce max value on input
        field.addEventListener('input', (e) => {
          const key = this.camelCase(fieldId);
          
          // Check if this field has a max and enforce it
          const maxFieldId = fieldsWithMax[fieldId];
          if (maxFieldId) {
            const maxField = document.getElementById(maxFieldId);
            if (maxField) {
              const maxVal = parseInt(maxField.value, 10);
              const currentVal = parseInt(e.target.value, 10);
              if (!isNaN(maxVal) && !isNaN(currentVal) && currentVal > maxVal) {
                e.target.value = maxVal;
              }
            }
          }
          
          // Handle combined ENC + Fatigue penalty for initiative and action points
          if ((fieldId === 'initiative-current' || fieldId === 'action-points-current') &&
              (e.target.classList.contains('enc-penalty-init-move') || e.target.classList.contains('fatigue-penalized'))) {
            // User is editing while penalized - update original value
            e.target.dataset.originalValue = e.target.value;
            // Re-apply all penalties after a short delay
            setTimeout(() => this.applyAllPenalties(), 10);
          } else if (fieldId === 'initiative-current' || fieldId === 'action-points-current') {
            // Normal edit - also update originalValue if it exists
            if (e.target.dataset.originalValue !== undefined) {
              e.target.dataset.originalValue = e.target.value;
            }
          }
          
          this.character.derived[key] = e.target.dataset.originalValue || e.target.value;
          this.scheduleAutoSave();
          
          // Update weapon damages when damage modifier changes
          if (fieldId === 'damage-mod-current') {
            if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
              window.WeaponData.updateAllWeaponDamage();
            }
          }
          
          // Update MP display on spell pages when magic points change
          if (fieldId === 'magic-points-current') {
            this.updateMagicMPDisplay();
          }
        });
        
        // Also enforce on blur (in case user types quickly)
        field.addEventListener('blur', (e) => {
          const maxFieldId = fieldsWithMax[fieldId];
          if (maxFieldId) {
            const maxField = document.getElementById(maxFieldId);
            if (maxField) {
              const maxVal = parseInt(maxField.value, 10);
              const currentVal = parseInt(e.target.value, 10);
              if (!isNaN(maxVal) && !isNaN(currentVal) && currentVal > maxVal) {
                e.target.value = maxVal;
                this.scheduleAutoSave();
              }
            }
          }
        });
      }
    });
    
    // Skill current values
    document.querySelectorAll('.skill-input').forEach(input => {
      input.addEventListener('input', (e) => {
        const skillKeyKebab = e.target.id.replace('-current', '');
        const skillKey = this.camelCase(skillKeyKebab);
        
        // If there's any active penalty and user is editing, update the original value
        if (e.target.classList.contains('enc-penalized-value') || e.target.classList.contains('fatigue-penalized')) {
          // User is editing a penalized field - treat the input as the NEW original
          const newOriginal = e.target.value;
          e.target.dataset.originalValue = newOriginal;
          this.character.standardSkills[skillKey] = newOriginal;
          
          // Re-apply all penalties after a short delay
          setTimeout(() => this.applyAllPenalties(), 10);
        } else {
          // Normal edit - also update originalValue if it exists
          // For Evade: if Artful Dodger or Lightning Reflexes display bonus is active, save base value (minus display bonuses)
          if (skillKey === 'evade' && (this.artfulDodgerDisplayed || this.lightningReflexesDisplayed)) {
            const displayedValue = parseInt(e.target.value, 10) || 0;
            let bonusToRemove = 0;
            if (this.artfulDodgerDisplayed) bonusToRemove += 10;
            if (this.lightningReflexesDisplayed) bonusToRemove += (this._lightningReflexesBonus || 0);
            const baseValue = Math.max(0, displayedValue - bonusToRemove).toString();
            if (e.target.dataset.originalValue !== undefined) {
              e.target.dataset.originalValue = baseValue;
            }
            this.character.standardSkills[skillKey] = baseValue;
          } else {
            if (e.target.dataset.originalValue !== undefined) {
              e.target.dataset.originalValue = e.target.value;
            }
            this.character.standardSkills[skillKey] = e.target.value;
          }
        }
        
        this.updateCombatQuickRef();
        this.scheduleAutoSave();
      });
    });
    
    // Notes - Rich text sections (handled via setupNotesPage)
    // The old general-notes textarea is replaced with contenteditable sections
    const notesEditors = document.querySelectorAll('.notes-editor');
    notesEditors.forEach(editor => {
      editor.addEventListener('input', () => {
        this.saveNotesData();
        this.scheduleAutoSave();
      });
    });
    
    // Combat skill inputs
    const combatSkillFields = ['combat-skill-1-name', 'combat-skill-1-percent', 'combat-skill-1-weapons', 'unarmed-percent'];
    combatSkillFields.forEach(fieldId => {
      const field = document.getElementById(fieldId);
      if (field) {
        field.addEventListener('input', () => {
          // For percent fields, handle combined ENC + Fatigue penalty
          if (fieldId === 'combat-skill-1-percent' || fieldId === 'unarmed-percent') {
            // If field has a penalty applied, update the original value
            if (field.classList.contains('enc-penalized-value') || field.classList.contains('fatigue-penalized')) {
              field.dataset.originalValue = field.value;
              // Re-apply all penalties
              setTimeout(() => this.applyAllPenalties(), 10);
            } else {
              // No penalty, original = current
              field.dataset.originalValue = field.value;
            }
          }
          // Update weapon master critical badge if active
          if (fieldId === 'combat-skill-1-percent' && (this.character.activeWeaponSpecs || []).length > 0) {
            // Combat skill changed manually while spec active — update pre-values
          }
          this.updateCombatQuickRef();
          this.scheduleAutoSave();
        });
      }
    });
  },

  /**
   * Schedule an auto-save
   */
  scheduleAutoSave() {
    StorageManager.scheduleAutoSave(this.character);
  },

  /**
   * Set up image upload handlers
   */
  setupImageUploads() {
    // Full body portrait
    const fullBodyUpload = document.getElementById('full-body-upload');
    if (fullBodyUpload) {
      fullBodyUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          try {
            const base64 = await StorageManager.imageToBase64(file);
            this.character.images.fullBody = base64;
            this.displayImage('full-body', base64);
            this.scheduleAutoSave();
          } catch (error) {
            console.error('Error uploading image:', error);
          }
        }
      });
    }
    
    // Thumbnail portrait
    const portraitUpload = document.getElementById('portrait-upload');
    if (portraitUpload) {
      portraitUpload.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (file) {
          try {
            const base64 = await StorageManager.imageToBase64(file);
            this.character.images.portrait = base64;
            this.displayImage('portrait', base64);
            this.scheduleAutoSave();
          } catch (error) {
            console.error('Error uploading image:', error);
          }
        }
      });
    }
    
    // Remove image buttons
    document.querySelectorAll('.btn-remove-image').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const target = btn.dataset.target;
        this.removeImage(target);
      });
    });
  },

  /**
   * Display an uploaded image
   */
  displayImage(target, base64) {
    const img = document.getElementById(`${target}-image`);
    const label = img.previousElementSibling;
    const removeBtn = img.nextElementSibling;
    
    if (img && base64) {
      img.src = base64;
      img.classList.remove('hidden');
      if (label) label.classList.add('hidden');
      if (removeBtn) removeBtn.classList.remove('hidden');
    }
  },

  /**
   * Remove an uploaded image
   */
  removeImage(target) {
    const img = document.getElementById(`${target}-image`);
    const label = img.previousElementSibling;
    const removeBtn = img.nextElementSibling;
    const input = document.getElementById(`${target}-upload`);
    
    if (target === 'full-body') {
      this.character.images.fullBody = null;
    } else {
      this.character.images.portrait = null;
    }
    
    if (img) {
      img.src = '';
      img.classList.add('hidden');
    }
    if (label) label.classList.remove('hidden');
    if (removeBtn) removeBtn.classList.add('hidden');
    if (input) input.value = '';
    
    this.scheduleAutoSave();
  },

  /**
   * Set up button handlers
   */
  setupButtons() {
    // Save button
    const saveBtn = document.getElementById('btn-save');
    if (saveBtn) {
      saveBtn.addEventListener('click', () => {
        this.collectFormData();
        if (!StorageManager.save(this.character)) {
          alert('Error saving character.');
        }
      });
    }
    
    // Load button
    const loadBtn = document.getElementById('btn-load');
    if (loadBtn) {
      loadBtn.addEventListener('click', () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              this.character = await StorageManager.importJSON(file);
              this.sheetType = this.character.sheetType || 'human';
              document.getElementById('sheet-type-select').value = this.sheetType;
              document.getElementById('app').dataset.sheetType = this.sheetType;
              this.generateHitLocations();
              this.populateForm();
              this.recalculateAll();
              alert('Character loaded!');
            } catch (error) {
              alert('Error loading file: ' + error.message);
            }
          }
        };
        input.click();
      });
    }
    
    // Export button
    const exportBtn = document.getElementById('btn-export');
    if (exportBtn) {
      exportBtn.addEventListener('click', () => {
        this.collectFormData();
        StorageManager.exportJSON(this.character);
      });
    }
    
    // Print button
    const printBtn = document.getElementById('btn-print');
    if (printBtn) {
      printBtn.addEventListener('click', () => {
        window.print();
      });
    }
    
    // Sort abilities button
    const sortBtn = document.getElementById('btn-sort-abilities');
    if (sortBtn) {
      sortBtn.addEventListener('click', () => {
        this.sortSpecialAbilities();
      });
    }
    
    // Alphabetize spells buttons (individual for each rank)
    const spellRanks = ['cantrips', 'rank1', 'rank2', 'rank3', 'rank4', 'rank5'];
    spellRanks.forEach(rankKey => {
      const btn = document.getElementById(`btn-alphabetize-${rankKey}`);
      if (btn) {
        btn.addEventListener('click', () => {
          this.alphabetizeSpellsInRank(rankKey);
        });
      }
    });
    
    // Unlock originals button (for Attributes only)
    const unlockOriginalsBtn = document.getElementById('unlock-originals-btn');
    if (unlockOriginalsBtn) {
      unlockOriginalsBtn.addEventListener('click', () => {
        this.toggleOriginalsEditing();
      });
    }
    
    // Short Rest button - recover one fatigue level
    const shortRestBtn = document.getElementById('btn-short-rest');
    if (shortRestBtn) {
      shortRestBtn.addEventListener('click', () => {
        this.shortRest();
      });
    }
    
    // Long Rest button - fully recover to Fresh
    const longRestBtn = document.getElementById('btn-long-rest');
    if (longRestBtn) {
      longRestBtn.addEventListener('click', () => {
        this.longRest();
      });
    }
    
    // Short Rest Modal buttons
    const shortRestModalClose = document.getElementById('short-rest-modal-close');
    if (shortRestModalClose) {
      shortRestModalClose.addEventListener('click', () => {
        this.closeShortRestModal();
      });
    }
    
    const applyShortRestBtn = document.getElementById('btn-apply-short-rest');
    if (applyShortRestBtn) {
      applyShortRestBtn.addEventListener('click', () => {
        this.applyShortRestAction();
      });
    }
    
    const cancelShortRestBtn = document.getElementById('btn-cancel-short-rest');
    if (cancelShortRestBtn) {
      cancelShortRestBtn.addEventListener('click', () => {
        this.closeShortRestModal();
      });
    }
    
    // Close modal on overlay click
    const shortRestOverlay = document.getElementById('short-rest-modal-overlay');
    if (shortRestOverlay) {
      shortRestOverlay.addEventListener('click', (e) => {
        if (e.target === shortRestOverlay) {
          this.closeShortRestModal();
        }
      });
    }
    
    // Event delegation for weapon damage dice buttons on Combat page
    document.addEventListener('click', (e) => {
      const diceBtn = e.target.closest('.weapon-dice-btn');
      if (diceBtn) {
        e.preventDefault();
        e.stopPropagation();
        const damageInput = diceBtn.parentElement?.querySelector('.weapon-damage');
        if (damageInput && damageInput.value) {
          let damageStr = damageInput.value;
          // If Holy Strike is active, append +1d6 (except for Unarmed)
          if (this.character.holyStrikeActive) {
            const row = diceBtn.closest('tr');
            const nameInput = row?.querySelector('.weapon-name');
            const nameVal = (nameInput?.value || '').toLowerCase().trim();
            if (nameVal !== 'unarmed' && nameVal !== '') {
              damageStr += '+1d6';
              this._holyStrikeUsedThisRoll = true;
            }
          }
          this.rollDamage(damageStr);
          // Deactivate Holy Strike after damage roll
          if (this._holyStrikeUsedThisRoll) {
            this._holyStrikeUsedThisRoll = false;
            this.deactivateHolyStrike();
          }
          // Deactivate Species Enemy after damage roll (if combat was rolled first)
          if (this.character.speciesEnemyActive && this.character.speciesEnemyCombatRolled) {
            this.deactivateSpeciesEnemy();
          }
        }
      }
    });
    
    // Heal All button - restore all hit location HP to max
    const healAllBtn = document.getElementById('btn-heal-all');
    if (healAllBtn) {
      healAllBtn.addEventListener('click', () => {
        this.healAllHitLocations();
      });
    }
    
    // Heal All Modal buttons
    const healConfirmBtn = document.getElementById('btn-heal-confirm');
    if (healConfirmBtn) {
      healConfirmBtn.addEventListener('click', () => {
        this.confirmHealAll();
      });
    }
    
    const healCancelBtn = document.getElementById('btn-heal-cancel');
    if (healCancelBtn) {
      healCancelBtn.addEventListener('click', () => {
        this.closeHealModal();
      });
    }
    
    // Initiative d10 Roll button
    const initRollBtn = document.getElementById('btn-init-roll');
    if (initRollBtn) {
      initRollBtn.addEventListener('click', () => {
        this.openInitiativeRollModal();
      });
    }
    
    const healModalClose = document.getElementById('heal-modal-close');
    if (healModalClose) {
      healModalClose.addEventListener('click', () => {
        this.closeHealModal();
      });
    }
    
    // Close heal modal on overlay click
    const healModal = document.getElementById('heal-all-modal');
    if (healModal) {
      healModal.addEventListener('click', (e) => {
        if (e.target === healModal) {
          this.closeHealModal();
        }
      });
    }
    
    // Wound Info Modal handlers
    const woundInfoClose = document.getElementById('wound-info-close');
    if (woundInfoClose) {
      woundInfoClose.addEventListener('click', () => {
        this.closeWoundInfoModal();
      });
    }
    
    const woundInfoCloseBtn = document.getElementById('btn-wound-info-close');
    if (woundInfoCloseBtn) {
      woundInfoCloseBtn.addEventListener('click', () => {
        this.closeWoundInfoModal();
      });
    }
    
    const woundInfoModal = document.getElementById('wound-info-modal');
    if (woundInfoModal) {
      woundInfoModal.addEventListener('click', (e) => {
        if (e.target === woundInfoModal) {
          this.closeWoundInfoModal();
        }
      });
    }
    
    // Event delegation for wound status badge clicks
    document.addEventListener('click', (e) => {
      const woundStatus = e.target.closest('.wound-status.clickable');
      if (woundStatus) {
        const statusClass = woundStatus.dataset.status;
        const locationName = woundStatus.dataset.location || '';
        if (statusClass && statusClass !== 'none') {
          this.showWoundInfoModal(statusClass, locationName);
        }
      }
    });
    
    // Event delegation for HP up/down buttons
    document.addEventListener('click', (e) => {
      const hpBtn = e.target.closest('.hp-btn');
      if (hpBtn) {
        e.preventDefault();
        const locIndex = hpBtn.dataset.loc;
        const isUp = hpBtn.classList.contains('hp-up');
        this.adjustLocationHP(locIndex, isUp ? 1 : -1);
      }
    });
    
    // New Game button
    const newGameBtn = document.getElementById('btn-new-game');
    if (newGameBtn) {
      newGameBtn.addEventListener('click', () => {
        this.startNewGame();
      });
    }
    
    // New Game Modal handlers
    const newGameModalClose = document.getElementById('new-game-modal-close');
    if (newGameModalClose) {
      newGameModalClose.addEventListener('click', () => this.closeNewGameModal());
    }
    
    const newGameOkBtn = document.getElementById('btn-new-game-ok');
    if (newGameOkBtn) {
      newGameOkBtn.addEventListener('click', () => this.closeNewGameModal());
    }
    
    const newGameModal = document.getElementById('new-game-modal');
    if (newGameModal) {
      newGameModal.addEventListener('click', (e) => {
        if (e.target === newGameModal) this.closeNewGameModal();
      });
    }
    
    // Finish Game button
    const finishGameBtn = document.getElementById('btn-finish-game');
    if (finishGameBtn) {
      finishGameBtn.addEventListener('click', () => {
        this.showFinishGameModal();
      });
    }
    
    // Finish Game Modal handlers
    const finishGameModalClose = document.getElementById('finish-game-modal-close');
    if (finishGameModalClose) {
      finishGameModalClose.addEventListener('click', () => this.closeFinishGameModal());
    }
    
    const finishGameCancelBtn = document.getElementById('btn-finish-game-cancel');
    if (finishGameCancelBtn) {
      finishGameCancelBtn.addEventListener('click', () => this.closeFinishGameModal());
    }
    
    const finishGameConfirmBtn = document.getElementById('btn-finish-game-confirm');
    if (finishGameConfirmBtn) {
      finishGameConfirmBtn.addEventListener('click', () => this.confirmFinishGame());
    }
    
    const finishGameModal = document.getElementById('finish-game-modal');
    if (finishGameModal) {
      finishGameModal.addEventListener('click', (e) => {
        if (e.target === finishGameModal) this.closeFinishGameModal();
      });
    }
    
    // Update EXP preview when input changes
    const finishGameExpInput = document.getElementById('finish-game-exp');
    if (finishGameExpInput) {
      finishGameExpInput.addEventListener('input', () => this.updateFinishGamePreview());
    }
  },
  
  /**
   * Add d100 dice buttons to skill rows on Character page
   */
  addSkillDiceButtons() {
    // Helper to create dice button
    const createDiceButton = (skillNameGetter, valueGetter) => {
      const btn = document.createElement('button');
      btn.className = 'd100-btn skill-roll-btn';
      btn.title = 'Roll d100!';
      btn.innerHTML = '<img src="images/d10.svg" alt="d10" class="d10-icon">';
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const skillName = skillNameGetter();
        const currentValue = valueGetter();
        this.rollD100(skillName, currentValue);
      });
      return btn;
    };
    
    // Add to Standard Skills on Character page
    document.querySelectorAll('.standard-skills .skill-row').forEach(row => {
      if (row.querySelector('.d100-btn')) return;
      
      const skillName = (row.querySelector('.skill-name')?.textContent || '').replace(/\u2139/g, '').trim();
      const skillInput = row.querySelector('.skill-input');
      const encIndicator = row.querySelector('.enc-indicator');
      
      if (skillInput) {
        const btn = createDiceButton(
          () => skillName,
          () => parseInt(skillInput.value) || 0
        );
        
        // Insert before enc-indicator if present, otherwise append
        if (encIndicator) {
          row.insertBefore(btn, encIndicator);
        } else {
          row.appendChild(btn);
        }
      }
    });
    
    // Add to Alignment rows
    document.querySelectorAll('.alignment-section .belief-row').forEach(row => {
      if (row.querySelector('.d100-btn')) return;
      
      const nameInput = row.querySelector('.belief-name');
      const valueInput = row.querySelector('.belief-input');
      
      if (nameInput && valueInput) {
        const btn = createDiceButton(
          () => nameInput.value || 'Alignment',
          () => parseInt(valueInput.value) || 0
        );
        row.appendChild(btn);
      }
    });
    
    // Add to Passion rows
    document.querySelectorAll('#passions-container .belief-row').forEach(row => {
      if (row.querySelector('.d100-btn')) return;
      
      const nameInput = row.querySelector('.belief-name');
      const valueInput = row.querySelector('.belief-input');
      
      if (nameInput && valueInput) {
        const btn = createDiceButton(
          () => nameInput.value || 'Passion',
          () => parseInt(valueInput.value) || 0
        );
        row.appendChild(btn);
      }
    });
    
    // Add to Oath rows
    document.querySelectorAll('#oaths-container .belief-row').forEach(row => {
      if (row.querySelector('.d100-btn')) return;
      
      const nameInput = row.querySelector('.belief-name');
      const valueInput = row.querySelector('.belief-input');
      
      if (nameInput && valueInput) {
        const btn = createDiceButton(
          () => nameInput.value || 'Oath',
          () => parseInt(valueInput.value) || 0
        );
        row.appendChild(btn);
      }
    });
    
    // Add to Professional Skill rows
    document.querySelectorAll('.professional-skill-row').forEach(row => {
      if (row.querySelector('.d100-btn')) return;
      
      const nameInput = row.querySelector('.prof-skill-name');
      const valueInput = row.querySelector('.prof-skill-current');
      const encIndicator = row.querySelector('.prof-enc-indicator');
      
      if (nameInput && valueInput) {
        const btn = createDiceButton(
          () => nameInput.value || 'Professional Skill',
          () => parseInt(valueInput.value) || 0
        );
        
        // Insert before enc-indicator if present, otherwise append
        if (encIndicator) {
          row.insertBefore(btn, encIndicator);
        } else {
          row.appendChild(btn);
        }
      }
    });
    
    // Add to Combat Skill rows (Combat/Abilities page)
    document.querySelectorAll('.combat-skill-row').forEach(row => {
      if (row.querySelector('.d100-btn')) return;
      
      // Get skill name - could be input or span (for Unarmed)
      const nameInput = row.querySelector('.combat-skill-name');
      const skillName = nameInput?.tagName === 'INPUT' ? nameInput.value : nameInput?.textContent;
      const valueInput = row.querySelector('.combat-skill-percent');
      const encIndicator = row.querySelector('.enc-indicator');
      
      if (valueInput) {
        const btn = createDiceButton(
          () => {
            const currentName = nameInput?.tagName === 'INPUT' ? nameInput.value : nameInput?.textContent;
            return currentName || 'Combat Skill';
          },
          () => parseInt(valueInput.value) || 0
        );
        
        // Insert after percent input, before enc-indicator
        if (encIndicator) {
          row.insertBefore(btn, encIndicator);
        } else {
          valueInput.after(btn);
        }
      }
    });
  },
  
  /**
   * Add ℹ info buttons to standard skill rows that have SKILL_INFO entries
   */
  addSkillInfoButtons() {
    if (typeof SKILL_INFO === 'undefined') return;

    const self = this;
    function makeBtn(key) {
      const b = document.createElement('button');
      b.type = 'button';
      b.className = 'skill-info-btn';
      b.title = 'Skill info';
      b.innerHTML = '&#8505;';
      b.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        self.showSkillInfo(key);
      });
      return b;
    }

    // Standard skill rows - insert into .skill-name span
    const stdRows = document.querySelectorAll('.standard-skills .skill-row');
    for (let i = 0; i < stdRows.length; i++) {
      const row = stdRows[i];
      if (row.querySelector('.skill-info-btn')) continue;
      const skillKey = row.dataset.skill;
      if (!skillKey || !SKILL_INFO[skillKey]) continue;
      const nameSpan = row.querySelector('.skill-name');
      if (nameSpan) {
        nameSpan.insertBefore(makeBtn(skillKey), nameSpan.firstChild);
      }
    }

    // Professional skill rows - wrap button + name input in flex span
    const profRows = document.querySelectorAll('.professional-skill-row');
    for (let p = 0; p < profRows.length; p++) {
      const row = profRows[p];
      if (row.querySelector('.skill-info-btn')) continue;
      const nameInput = row.querySelector('.prof-skill-name');
      const nameVal = nameInput ? nameInput.value.trim() : '';
      if (!nameVal) continue;
      const key = this._findSkillInfoKey(nameVal);
      if (!key) continue;
      const wrapper = document.createElement('span');
      wrapper.className = 'prof-skill-info-wrapper';
      wrapper.style.cssText = 'display:flex;align-items:center;gap:4px;min-width:0;overflow:hidden;';
      nameInput.parentNode.insertBefore(wrapper, nameInput);
      wrapper.appendChild(makeBtn(key));
      nameInput.style.minWidth = '0';
      nameInput.style.flex = '1';
      wrapper.appendChild(nameInput);
    }

    // Combat skill rows - wrap button + name in flex span
    const combatRows = document.querySelectorAll('.combat-skill-row');
    for (let j = 0; j < combatRows.length; j++) {
      const row = combatRows[j];
      if (row.querySelector('.skill-info-btn')) continue;
      const nameEl = row.querySelector('.combat-skill-name');
      if (!nameEl) continue;
      const rawName = (nameEl.tagName === 'INPUT' ? nameEl.value : nameEl.textContent || '').toLowerCase().trim();
      let key = null;
      if (rawName === 'unarmed') { key = 'unarmed'; }
      else if (rawName.length > 0) { key = 'combat skill'; }
      if (!key || !SKILL_INFO[key]) continue;
      const wrapper = document.createElement('span');
      wrapper.style.cssText = 'display:inline-flex;align-items:center;gap:4px;min-width:0;overflow:hidden;';
      nameEl.parentNode.insertBefore(wrapper, nameEl);
      wrapper.appendChild(makeBtn(key));
      if (nameEl.tagName === 'INPUT') {
        nameEl.style.minWidth = '0';
        nameEl.style.flex = '1';
      }
      wrapper.appendChild(nameEl);
    }
  },

  /**
   * Find SKILL_INFO key for a skill name (handles parenthetical suffixes)
   * e.g. "Lore (History)" → "lore", "Language (Elvish)" → "language",
   *      "Craft (Blacksmithing)" → "craft", "Acrobatics" → "acrobatics"
   */
  _findSkillInfoKey(skillName) {
    if (typeof SKILL_INFO === 'undefined') return null;
    const normalized = skillName.toLowerCase().trim();
    
    // Direct match
    if (SKILL_INFO[normalized]) return normalized;
    
    // Try with dashes instead of spaces
    const dashed = normalized.replace(/\s+/g, '-');
    if (SKILL_INFO[dashed]) return dashed;
    
    // Strip parenthetical suffix: "Lore (History)" → "lore"
    const base = normalized.replace(/\s*\(.*?\)\s*$/, '').trim();
    if (SKILL_INFO[base]) return base;
    
    // Try dashed base
    const dashedBase = base.replace(/\s+/g, '-');
    if (SKILL_INFO[dashedBase]) return dashedBase;
    
    return null;
  },

  /**
   * Refresh the info button on a professional skill row when its name changes
   */
  _refreshProfSkillInfoButton(row, skillName) {
    if (typeof SKILL_INFO === 'undefined') return;
    // Remove existing button
    const existing = row.querySelector('.skill-info-btn');
    if (existing) existing.remove();
    
    // If wrapper exists but no button needed, unwrap the input
    const wrapper = row.querySelector('.prof-skill-info-wrapper');
    const nameInput = row.querySelector('.prof-skill-name');
    
    if (!skillName) {
      if (wrapper && nameInput) {
        wrapper.parentNode.insertBefore(nameInput, wrapper);
        nameInput.style.minWidth = '';
        nameInput.style.flex = '';
        wrapper.remove();
      }
      return;
    }
    
    const key = this._findSkillInfoKey(skillName);
    if (!key) {
      if (wrapper && nameInput) {
        wrapper.parentNode.insertBefore(nameInput, wrapper);
        nameInput.style.minWidth = '';
        nameInput.style.flex = '';
        wrapper.remove();
      }
      return;
    }
    
    const self = this;
    const btn = document.createElement('button');
    btn.type = 'button';
    btn.className = 'skill-info-btn';
    btn.title = 'Skill info';
    btn.innerHTML = '&#8505;';
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      self.showSkillInfo(key);
    });
    
    if (wrapper) {
      // Wrapper exists, just prepend button
      wrapper.insertBefore(btn, wrapper.firstChild);
    } else if (nameInput) {
      // Create wrapper
      const newWrapper = document.createElement('span');
      newWrapper.className = 'prof-skill-info-wrapper';
      newWrapper.style.cssText = 'display:flex;align-items:center;gap:4px;min-width:0;overflow:hidden;';
      nameInput.parentNode.insertBefore(newWrapper, nameInput);
      newWrapper.appendChild(btn);
      nameInput.style.minWidth = '0';
      nameInput.style.flex = '1';
      newWrapper.appendChild(nameInput);
    }
  },

    /**
   * Show skill info modal (reuses attr-info overlay)
   */
  showSkillInfo(skillKey) {
    if (typeof SKILL_INFO === 'undefined') return;
    const info = SKILL_INFO[skillKey];
    if (!info) return;
    
    // Build description — handle Evade's dynamic description
    let descHTML;
    if (info.getDescription) {
      const hasAD = !!(this.artfulDodgerDisplayed || (this.activeAbilityEffects && this.activeAbilityEffects['artful dodger']));
      descHTML = info.getDescription(hasAD);
    } else {
      descHTML = info.description || '';
    }
    
    // Add outcomes section if any exist
    const hasOutcomes = info.critical || info.failure || info.fumble;
    if (hasOutcomes) {
      descHTML += '<hr style="border:none;border-top:1px solid var(--border-light);margin:0.75rem 0;">';
      descHTML += '<div class="skill-outcomes">';
      if (info.critical) {
        descHTML += `<div class="skill-outcome"><span class="outcome-label outcome-critical">Critical</span> <span class="outcome-text">${info.critical}</span></div>`;
      }
      if (info.failure) {
        descHTML += `<div class="skill-outcome"><span class="outcome-label outcome-failure">Failure</span> <span class="outcome-text">${info.failure}</span></div>`;
      }
      if (info.fumble) {
        descHTML += `<div class="skill-outcome"><span class="outcome-label outcome-fumble">Fumble</span> <span class="outcome-text">${info.fumble}</span></div>`;
      }
      descHTML += '</div>';
    }
    
    // Reuse the attribute info overlay system
    this.showAttributeInfo({
      _skillInfoOverride: true,
      title: info.title,
      content: descHTML
    });
  },
  
  /**
   * Look up d100 outcome text for a skill and result type
   * Returns null if no specific outcome is defined.
   */
  getSkillOutcome(skillName, resultClass) {
    if (typeof SKILL_INFO === 'undefined') return null;
    
    const normalized = (skillName || '').toLowerCase().trim();
    
    // Use the fuzzy key finder (handles parenthetical suffixes, dashes, etc.)
    let key = this._findSkillInfoKey(normalized);
    
    // If no match, check if it's a combat skill on the combat page
    if (!key) {
      if (normalized === 'unarmed') {
        key = 'unarmed';
      } else {
        // Check if this matches a combat skill row name
        const combatRows = document.querySelectorAll('.combat-skill-row');
        for (const row of combatRows) {
          const nameEl = row.querySelector('.combat-skill-name');
          const rowName = (nameEl?.tagName === 'INPUT' ? nameEl.value : nameEl?.textContent || '').toLowerCase().trim();
          if (rowName === normalized && normalized !== 'unarmed') {
            key = 'combat skill';
            break;
          }
        }
      }
    }
    
    if (!key) return null;
    const info = SKILL_INFO[key];
    if (!info) return null;
    
    // Map result class to outcome property
    if (resultClass === 'roll-critical' && info.critical) return info.critical;
    if (resultClass === 'roll-failure' && info.failure) return info.failure;
    if (resultClass === 'roll-fumble' && info.fumble) return info.fumble;
    
    return null;
  },
  
  /**
   * Toggle editing of Characteristics only (Attributes are always auto-calculated)
   */
  toggleOriginalsEditing() {
    const charInputs = document.querySelectorAll('.char-readonly, .char-editable');
    const btn = document.getElementById('unlock-originals-btn');
    
    // Check current state based on characteristics
    const isCurrentlyReadonly = charInputs[0]?.classList.contains('char-readonly');
    
    // Toggle Characteristics only (Attributes remain auto-calculated and readonly)
    charInputs.forEach(input => {
      if (isCurrentlyReadonly) {
        input.removeAttribute('readonly');
        input.classList.remove('char-readonly');
        input.classList.add('char-editable');
      } else {
        input.setAttribute('readonly', '');
        input.classList.remove('char-editable');
        input.classList.add('char-readonly');
      }
    });
    
    // Update locked state (still track this for saving purposes)
    this.character.originalsLocked = !isCurrentlyReadonly;
    
    this.scheduleAutoSave();
    
    if (btn) {
      if (isCurrentlyReadonly) {
        btn.textContent = '🔓 Lock Characteristics';
        btn.classList.add('unlocked');
      } else {
        btn.textContent = '🔒 Unlock Characteristics';
        btn.classList.remove('unlocked');
      }
    }
  },

  /**
   * Save the current derived original values to character data
   */
  saveDerivedOriginalValues() {
    const fields = {
      'action-points-original': 'actionPointsOriginal',
      'damage-mod-original': 'damageModOriginal',
      'exp-mod-original': 'expModOriginal',
      'healing-rate-original': 'healingRateOriginal',
      'initiative-original': 'initiativeOriginal',
      'luck-original': 'luckOriginal',
      'magic-points-original': 'magicPointsOriginal'
    };
    
    for (const [fieldId, key] of Object.entries(fields)) {
      const input = document.getElementById(fieldId);
      if (input) {
        this.character.derived[key] = input.value;
      }
    }
  },

  /**
   * Sync a current derived value when its original changes (e.g., rank-up gives more AP).
   * Call AFTER recalculateAll() with the snapshot taken BEFORE recalculate.
   * @param {string} prefix - Field prefix, e.g. 'action-points' or 'luck'
   * @param {number} origBefore - The original value before recalculation
   */
  syncCurrentToDerivedChange(prefix, origBefore) {
    const origEl = document.getElementById(`${prefix}-original`);
    const currEl = document.getElementById(`${prefix}-current`);
    if (!origEl || !currEl) return;
    
    const origAfter = parseInt(origEl.value, 10) || 0;
    if (origAfter === origBefore) return; // No change
    
    const currVal = parseInt(currEl.value, 10);
    const dataKey = this.camelCase(`${prefix}-current`);
    
    if (origAfter > origBefore) {
      // Original increased (rank-up)
      const increase = origAfter - origBefore;
      if (isNaN(currVal) || currVal === 0) {
        // Current was empty/zero - set to new original
        currEl.value = origAfter;
      } else {
        // Add the increase to current
        currEl.value = currVal + increase;
      }
    } else {
      // Original decreased (rank-down) - cap current to new max
      if (!isNaN(currVal) && currVal > origAfter) {
        currEl.value = origAfter;
      }
    }
    
    // Update dataset.originalValue for ENC/fatigue penalty system
    currEl.dataset.originalValue = currEl.value;
    
    // Persist to character data
    this.character.derived[dataKey] = currEl.value;
  },

  /**
   * Generate alignment rows dynamically - only for saved alignments with names
   */
  generateAlignments() {
    const container = document.getElementById('alignment-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Filter out any empty alignments (from old save format)
    const savedAlignments = (this.character.alignments || []).filter(a => a && a.name && a.name.trim());
    // Update character data to remove empty entries
    this.character.alignments = savedAlignments;
    
    let rowIndex = 1;
    for (let i = 0; i < savedAlignments.length; i++) {
      const row = document.createElement('div');
      row.className = 'belief-row';
      row.dataset.index = rowIndex;
      row.innerHTML = `
        <input type="text" class="belief-name" id="alignment-${rowIndex}-name" placeholder="">
        <span class="belief-formula">POW+INT+50</span>
        <span class="belief-base" id="alignment-${rowIndex}-base">0</span>
        <input type="number" class="belief-input" id="alignment-${rowIndex}-current" placeholder="">
      `;
      container.appendChild(row);
      
      // Add event listeners
      const nameInput = row.querySelector('.belief-name');
      const currentInput = row.querySelector('.belief-input');
      
      nameInput.addEventListener('blur', (e) => {
        if (e.target.value.trim()) {
          e.target.value = this.toTitleCase(e.target.value.trim());
        }
        this.scheduleAutoSave();
      });
      
      nameInput.addEventListener('input', () => this.scheduleAutoSave());
      currentInput.addEventListener('input', () => this.scheduleAutoSave());
      
      rowIndex++;
    }
  },

  /**
   * Generate passion rows dynamically - only for saved passions
   */
  generatePassions() {
    const container = document.getElementById('passions-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const savedPassions = this.character.passions || [];
    
    for (let i = 0; i < savedPassions.length; i++) {
      const row = document.createElement('div');
      row.className = 'belief-row';
      row.dataset.index = i + 1;
      row.innerHTML = `
        <input type="text" class="belief-name" id="passion-${i+1}-name" placeholder="">
        <input type="text" class="belief-formula-input" id="passion-${i+1}-formula" value="POW+INT+50" placeholder="e.g. POW+INT+50">
        <span class="belief-base" id="passion-${i+1}-base">0</span>
        <input type="number" class="belief-input" id="passion-${i+1}-current" placeholder="">
      `;
      container.appendChild(row);
      
      // Add event listeners
      const nameInput = row.querySelector('.belief-name');
      const formulaInput = row.querySelector('.belief-formula-input');
      const currentInput = row.querySelector('.belief-input');
      
      nameInput.addEventListener('blur', (e) => {
        if (e.target.value.trim()) {
          e.target.value = this.toTitleCase(e.target.value.trim());
        }
        this.scheduleAutoSave();
      });
      
      nameInput.addEventListener('input', () => this.scheduleAutoSave());
      formulaInput.addEventListener('input', () => {
        this.recalculateAll();
        this.scheduleAutoSave();
      });
      currentInput.addEventListener('input', () => this.scheduleAutoSave());
    }
  },

  /**
   * Generate oath rows dynamically - only for saved oaths
   */
  generateOaths() {
    const container = document.getElementById('oaths-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const savedOaths = this.character.oaths || [];
    
    for (let i = 0; i < savedOaths.length; i++) {
      const row = document.createElement('div');
      row.className = 'belief-row';
      row.dataset.index = i + 1;
      row.innerHTML = `
        <input type="text" class="belief-name" id="oath-${i+1}-name" placeholder="">
        <span class="belief-formula">POW+CHA+50</span>
        <span class="belief-base" id="oath-${i+1}-base">0</span>
        <input type="number" class="belief-input" id="oath-${i+1}-current" placeholder="">
      `;
      container.appendChild(row);
      
      // Add event listeners
      const nameInput = row.querySelector('.belief-name');
      const currentInput = row.querySelector('.belief-input');
      
      nameInput.addEventListener('blur', (e) => {
        if (e.target.value.trim()) {
          e.target.value = this.toTitleCase(e.target.value.trim());
        }
        this.scheduleAutoSave();
      });
      
      nameInput.addEventListener('input', () => this.scheduleAutoSave());
      currentInput.addEventListener('input', () => this.scheduleAutoSave());
    }
  },

  /**
   * Generate language rows dynamically - native tongue always shown, others only for saved
   */
  generateLanguages() {
    const container = document.getElementById('language-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Always create native tongue row
    const nativeRow = document.createElement('div');
    nativeRow.className = 'language-row native';
    nativeRow.innerHTML = `
      <label class="language-label">Native Tongue:</label>
      <input type="text" class="language-name" id="native-tongue-name" placeholder="">
      <span class="language-formula">INT+CHA+40</span>
      <span class="language-base" id="native-tongue-base">0</span>
      <input type="number" class="language-input" id="native-tongue-current" placeholder="">
    `;
    container.appendChild(nativeRow);
    
    // Add event listeners for native tongue
    const nativeNameInput = nativeRow.querySelector('.language-name');
    const nativeCurrentInput = nativeRow.querySelector('.language-input');
    
    nativeNameInput.addEventListener('blur', (e) => {
      if (e.target.value.trim()) {
        e.target.value = this.toTitleCase(e.target.value.trim());
      }
      this.scheduleAutoSave();
    });
    nativeNameInput.addEventListener('input', () => this.scheduleAutoSave());
    nativeCurrentInput.addEventListener('input', () => this.scheduleAutoSave());
    
    // Create additional language rows for saved languages (skip index 0 which is native)
    const savedLanguages = this.character.languages || [];
    
    for (let i = 1; i < savedLanguages.length; i++) {
      const rowIndex = i + 1; // language-2-name, language-3-name, etc.
      
      const row = document.createElement('div');
      row.className = 'language-row';
      row.innerHTML = `
        <input type="text" class="language-name" id="language-${rowIndex}-name" placeholder="">
        <span class="language-formula">INT+CHA</span>
        <span class="language-base" id="language-${rowIndex}-base">0</span>
        <input type="number" class="language-input" id="language-${rowIndex}-current" placeholder="">
      `;
      container.appendChild(row);
      
      // Add event listeners
      const nameInput = row.querySelector('.language-name');
      const currentInput = row.querySelector('.language-input');
      
      nameInput.addEventListener('blur', (e) => {
        if (e.target.value.trim()) {
          e.target.value = this.toTitleCase(e.target.value.trim());
        } else {
          // Name cleared - remove this row
          row.remove();
          this.reindexLanguages();
        }
        this.scheduleAutoSave();
      });
      nameInput.addEventListener('input', () => this.scheduleAutoSave());
      currentInput.addEventListener('input', () => this.scheduleAutoSave());
    }
  },

  /**
   * Generate professional skill rows
   */
  generateProfessionalSkills() {
    const container = document.getElementById('professional-skills-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Only create rows for saved professional skills (no fixed slots)
    const savedSkills = this.character.professionalSkills || [];
    const numRows = savedSkills.length; // No extra empty rows
    
    for (let i = 0; i < numRows; i++) {
      const row = document.createElement('div');
      row.className = 'professional-skill-row';
      row.innerHTML = `
        <span class="prereq-keys" id="prof-skill-${i}-prereq" data-skill-name=""></span>
        <input type="text" class="prof-skill-name" id="prof-skill-${i}-name" placeholder="">
        <input type="text" class="prof-skill-base" id="prof-skill-${i}-base" placeholder="" readonly>
        <span class="prof-skill-base-val" id="prof-skill-${i}-base-val"></span>
        <input type="number" class="prof-skill-current" id="prof-skill-${i}-current" placeholder="">
        <span class="enc-indicator prof-enc-indicator" id="prof-skill-${i}-enc" style="display: none;" title="Affected by ENC"></span>
      `;
      container.appendChild(row);
      
      // Add event listeners
      const nameInput = row.querySelector('.prof-skill-name');
      const baseInput = row.querySelector('.prof-skill-base');
      const currentInput = row.querySelector('.prof-skill-current');
      const prereqKeys = row.querySelector('.prereq-keys');
      
      // Track previous name for deletion detection
      nameInput.dataset.previousName = '';
      
      // Store previous name on focus (before editing)
      nameInput.addEventListener('focus', (e) => {
        e.target.dataset.previousName = e.target.value.trim();
      });
      
      // Convert to title case on blur and handle name changes
      nameInput.addEventListener('blur', (e) => {
        const newName = e.target.value.trim();
        const previousName = e.target.dataset.previousName || '';
        
        if (newName) {
          // Check for duplicate magic skill — silently handle instead of alerting
          // Skip during alphabetization (all values are being shuffled)
          if (!this._alphabetizing && this.checkForDuplicateMagicSkill(newName, i)) {
            console.warn(`[MAGIC SKILL] "${this.toTitleCase(newName)}" already exists in Professional Skills at another slot. Clearing this duplicate.`);
            // Clear this slot since the skill already exists elsewhere
            e.target.value = '';
            e.target.dataset.previousName = '';
            if (baseInput) baseInput.value = '';
            if (currentInput) currentInput.value = '';
            this.updateProfessionalSkillData(i);
            this.scheduleAutoSave();
            return;
          }
          
          e.target.value = this.toTitleCase(newName);
          prereqKeys.dataset.skillName = e.target.value;
          
          // Auto-fill formula on blur (in case input event didn't catch it)
          this.autoFillProfessionalSkillFormula(e.target, baseInput);
          
          // Refresh info button for this row
          this._refreshProfSkillInfoButton(row, e.target.value);
          
          this.updatePrereqKeys();
          this.scheduleAutoSave();
        } else if (previousName) {
          // Name was cleared - handle deletion
          this.handleProfSkillDeletion(i, previousName);
        }
        
        e.target.dataset.previousName = e.target.value.trim();
      });
      
      // Auto-fill formula when skill name is entered
      nameInput.addEventListener('input', (e) => {
        this.autoFillProfessionalSkillFormula(e.target, baseInput);
        this.updateProfessionalSkillData(i);
        this.updateProfSkillEncIndicator(i);
        // Update prereq keys data attribute
        prereqKeys.dataset.skillName = e.target.value.trim();
        this.updatePrereqKeys();
        this.scheduleAutoSave();
      });
      
      // Also recalculate base value when formula changes
      baseInput.addEventListener('input', () => {
        this.calculateProfessionalSkillBase(i);
        this.updateProfessionalSkillData(i);
        this.updateProfSkillEncIndicator(i);
        this.scheduleAutoSave();
      });
      
      currentInput.addEventListener('input', (e) => {
        // If there's an active penalty and user is editing, update the original value
        if (e.target.classList.contains('enc-penalized-value')) {
          const newOriginal = e.target.value;
          e.target.dataset.originalValue = newOriginal;
          // Re-apply penalty display after a short delay
          setTimeout(() => this.updateTotalEnc(), 10);
        } else if (e.target.dataset.originalValue !== undefined) {
          e.target.dataset.originalValue = e.target.value;
        }
        this.updateProfessionalSkillData(i);
        // Sync to magic page if this is a magic skill
        this.syncProfSkillToMagic(i);
        // If Mysticism changed, update Lightning Reflexes Evade bonus
        const profName = document.getElementById(`prof-skill-${i}-name`)?.value?.trim().toLowerCase() || '';
        if (profName === 'mysticism') {
          if (this.lightningReflexesDisplayed) {
            this.updateLightningReflexesDisplay();
          }
          if (this.veryAgileDisplayed) {
            this.updateVeryAgileDisplay();
          }
          this.checkMonkAbilitiesVisibility();
        }
        this.scheduleAutoSave();
      });
    }
  },

  /**
   * Sync Musicianship between Professional Skills and Magic page if user is a Bard
   */
  syncMusicianshipIfBard(profSkillIndex) {
    const nameInput = document.getElementById(`prof-skill-${profSkillIndex}-name`);
    const currentInput = document.getElementById(`prof-skill-${profSkillIndex}-current`);
    
    if (!nameInput || !currentInput) return;
    
    const skillName = nameInput.value.trim().toLowerCase();
    if (!skillName.startsWith('musicianship')) return;
    
    // Check if user is a Bard
    const classes = [
      document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || ''
    ].filter(c => c);
    
    if (!classes.includes('bard')) return;
    
    // Sync to magic page
    const magicMusicianship = document.getElementById('musicianship-percent');
    if (magicMusicianship && magicMusicianship.value !== currentInput.value) {
      magicMusicianship.value = currentInput.value;
      magicMusicianship.dispatchEvent(new Event('input', { bubbles: true }));
    }
  },
  
  /**
   * Check if a formula contains STR or DEX and show/hide ENC indicator
   */
  updateProfSkillEncIndicator(index) {
    const baseInput = document.getElementById(`prof-skill-${index}-base`);
    const encIndicator = document.getElementById(`prof-skill-${index}-enc`);
    
    if (!baseInput || !encIndicator) return;
    
    const formula = baseInput.value.toUpperCase();
    const hasStrOrDex = formula.includes('STR') || formula.includes('DEX');
    
    encIndicator.style.display = hasStrOrDex ? 'inline-block' : 'none';
  },

  /**
   * Update professional skill data in character object
   */
  updateProfessionalSkillData(index) {
    if (!this.character.professionalSkills) {
      this.character.professionalSkills = [];
    }
    
    const name = document.getElementById(`prof-skill-${index}-name`)?.value || '';
    const base = document.getElementById(`prof-skill-${index}-base`)?.value || '';
    const currentInput = document.getElementById(`prof-skill-${index}-current`);
    // Use originalValue if available (for ENC penalty system), otherwise use displayed value
    const current = currentInput?.dataset.originalValue || currentInput?.value || '';
    
    this.character.professionalSkills[index] = { name, base, current };
  },

  /**
   * Auto-fill professional skill formula based on skill name
   */
  autoFillProfessionalSkillFormula(nameInput, baseInput) {
    // Get the skill name, strip parentheses content, normalize to lowercase
    const skillName = nameInput.value.replace(/\s*\(.*?\)/g, '').trim().toLowerCase();
    
    // Look up the formula in SKILL_DEFINITIONS.professional
    if (SKILL_DEFINITIONS.professional && SKILL_DEFINITIONS.professional[skillName]) {
      const skillData = SKILL_DEFINITIONS.professional[skillName];
      baseInput.value = skillData.formula;
      
      // Trigger base value calculation
      const index = nameInput.id.match(/prof-skill-(\d+)-name/)[1];
      this.calculateProfessionalSkillBase(parseInt(index));
    }
  },

  /**
   * Calculate professional skill base value from formula
   */
  calculateProfessionalSkillBase(index) {
    const baseInput = document.getElementById(`prof-skill-${index}-base`);
    const baseValSpan = document.getElementById(`prof-skill-${index}-base-val`);
    
    if (!baseInput || !baseValSpan) return;
    
    const formula = baseInput.value.trim().toUpperCase();
    if (!formula) {
      baseValSpan.textContent = '';
      return;
    }
    
    // Parse and calculate the formula
    const result = this.calculateFormulaValue(formula);
    baseValSpan.textContent = result !== null ? result : '';
  },

  /**
   * Calculate a formula like "STR+DEX", "INT x2", "POW+INT+50" using current attribute values
   */
  calculateFormulaValue(formula) {
    const attrs = {
      STR: parseInt(document.getElementById('str-value')?.value) || 0,
      CON: parseInt(document.getElementById('con-value')?.value) || 0,
      SIZ: parseInt(document.getElementById('siz-value')?.value) || 0,
      DEX: parseInt(document.getElementById('dex-value')?.value) || 0,
      INT: parseInt(document.getElementById('int-value')?.value) || 0,
      POW: parseInt(document.getElementById('pow-value')?.value) || 0,
      CHA: parseInt(document.getElementById('cha-value')?.value) || 0
    };
    
    // Normalize formula: uppercase, remove extra spaces
    const normalized = formula.toUpperCase().replace(/\s+/g, '').trim();
    
    // Handle "Xx2" format (e.g., "INTx2", "INTX2", "DEXx2") - multiplier pattern
    const multiplierMatch = normalized.match(/^([A-Z]{3})[xX×]2$/);
    if (multiplierMatch) {
      const attr = multiplierMatch[1];
      if (attrs[attr] !== undefined) {
        return attrs[attr] * 2;
      }
    }
    
    // Handle "X+Y+N" format (e.g., "INT+CHA+40", "POW+INT+50")
    const additionBonusMatch = normalized.match(/^([A-Z]{3})\+([A-Z]{3})\+(\d+)$/);
    if (additionBonusMatch) {
      const attr1 = additionBonusMatch[1];
      const attr2 = additionBonusMatch[2];
      const bonus = parseInt(additionBonusMatch[3]);
      if (attrs[attr1] !== undefined && attrs[attr2] !== undefined) {
        return attrs[attr1] + attrs[attr2] + bonus;
      }
    }
    
    // Handle "Xx2+N" format (e.g., "INTx2+40", "POWx2+30") - multiplier with bonus
    const multiplierBonusMatch = normalized.match(/^([A-Z]{3})[xX×]2\+(\d+)$/);
    if (multiplierBonusMatch) {
      const attr = multiplierBonusMatch[1];
      const bonus = parseInt(multiplierBonusMatch[2]);
      if (attrs[attr] !== undefined) {
        return attrs[attr] * 2 + bonus;
      }
    }
    
    // Handle "X+Y" format (e.g., "STR+DEX", "INT+POW")
    const additionMatch = normalized.match(/^([A-Z]{3})\+([A-Z]{3})$/);
    if (additionMatch) {
      const attr1 = additionMatch[1];
      const attr2 = additionMatch[2];
      if (attrs[attr1] !== undefined && attrs[attr2] !== undefined) {
        return attrs[attr1] + attrs[attr2];
      }
    }
    
    return null;
  },

  /**
   * Recalculate all professional skill base values
   */
  recalculateProfessionalSkillBases() {
    const container = document.getElementById('professional-skills-container');
    if (!container) return;
    
    const rows = container.querySelectorAll('.professional-skill-row');
    rows.forEach((row, i) => {
      this.calculateProfessionalSkillBase(i);
    });
  },

  /**
   * Generate equipment rows - only for saved equipment
   */
  generateEquipmentRows() {
    const container = document.getElementById('equipment-container');
    if (!container) return;
    
    container.innerHTML = '';
    
    const savedEquipment = this.character.equipment || [];
    const numRows = savedEquipment.length;
    
    for (let i = 0; i < numRows; i++) {
      const row = document.createElement('div');
      row.className = 'equipment-row';
      row.innerHTML = `
        <input type="text" class="equipment-name" id="equip-${i}-name" placeholder="">
        <input type="number" class="equipment-enc" id="equip-${i}-enc" placeholder="" step="0.1">
      `;
      container.appendChild(row);
      
      // Add event listeners
      const nameInput = row.querySelector('.equipment-name');
      const encInput = row.querySelector('.equipment-enc');
      const rowIndex = i;
      
      // Store previous value for container removal detection
      nameInput.dataset.previousValue = '';
      
      // Track value on focus for comparison
      nameInput.addEventListener('focus', () => {
        nameInput.dataset.previousValue = nameInput.value.trim().toLowerCase();
      });
      
      // Check for container removal on blur
      nameInput.addEventListener('blur', async () => {
        const currentValue = nameInput.value.trim().toLowerCase();
        const previousValue = nameInput.dataset.previousValue || '';
        
        // Check if a container was removed (had value, now empty or different)
        if (previousValue && (!currentValue || currentValue !== previousValue)) {
          const removedContainer = this.getContainerIdFromItemName(previousValue);
          if (removedContainer) {
            // Check if the new value is also a container (transfer scenario)
            const newContainer = currentValue ? this.getContainerIdFromItemName(currentValue) : null;
            if (newContainer && newContainer !== removedContainer && this.containerHasItems(removedContainer)) {
              // Transfer items from old container to new container
              this.transferContainerItems(removedContainer, newContainer);
            } else {
              // Check if this container type still exists elsewhere in equipment
              const stillExists = this.containerStillExistsElsewhere(removedContainer, rowIndex);
              if (!stillExists) {
                const hasItems = this.containerHasItems(removedContainer);
                if (hasItems) {
                  const handled = await this.handleContainerRemoval(removedContainer, nameInput, previousValue);
                  if (!handled) {
                    // User cancelled - restore the value
                    nameInput.value = previousValue;
                    nameInput.dataset.previousValue = previousValue;
                    return;
                  }
                }
              }
            }
          }
        }
        
        // Update previous value
        nameInput.dataset.previousValue = nameInput.value.trim().toLowerCase();
        
        // Convert to title case
        if (nameInput.value.trim()) {
          let itemName = this.toTitleCase(nameInput.value.trim());
          
          // Add "(see below)" for container items if not already present
          const containerId = this.getContainerIdFromItemName(itemName);
          if (containerId && !itemName.toLowerCase().includes('see below')) {
            itemName = itemName + ' (See Below)';
            
            // Check if this new container upgrades an existing one with items
            // e.g., adding "Reinforced Backpack" when "Backpack" has items
            const upgradeMap = {
              'reinforced-backpack': 'backpack'
            };
            const oldContainerId = upgradeMap[containerId];
            if (oldContainerId && this.containerHasItems(oldContainerId)) {
              this.transferContainerItems(oldContainerId, containerId);
            }
          }
          
          nameInput.value = itemName;
        }
        
        // Normal autofill and update logic
        if (window.EncumbranceData) {
          const itemName = nameInput.value;
          if (itemName.trim() === '') {
            window.EncumbranceData.clearEquipmentEncIfEmpty('equip', rowIndex, itemName);
          } else {
            window.EncumbranceData.autofillEquipmentEnc('equip', rowIndex, itemName);
          }
          this.updateTotalEnc();
          this.updateContainerButtons();
          this.scheduleAutoSave();
        }
        
        // Sync weapon to combat page
        if (nameInput.value.trim()) {
          this.syncEquipmentToCombat(nameInput.value.trim());
        }
      });
      
      nameInput.addEventListener('input', () => {
        this.updateContainerButtons();
        this.scheduleAutoSave();
      });
      
      encInput.addEventListener('input', () => {
        this.updateTotalEnc();
        this.scheduleAutoSave();
      });
    }
    
    // ENC automation toggle
    const toggle = document.getElementById('enc-automation-toggle');
    if (toggle) {
      toggle.addEventListener('change', (e) => {
        this.character.encAutomation = !e.target.checked;
        this.updateTotalEnc();
        this.scheduleAutoSave();
      });
    }
  },

  /**
   * Get container ID from an item name
   */
  getContainerIdFromItemName(itemName) {
    const lowerName = itemName.toLowerCase();
    for (const [containerId, config] of Object.entries(CONTAINER_CONFIGS)) {
      if (config.triggers.some(trigger => lowerName.includes(trigger))) {
        // Special case: check for reinforced backpack vs regular backpack
        if (containerId === 'backpack' && lowerName.includes('reinforced')) {
          return 'reinforced-backpack';
        }
        return containerId;
      }
    }
    return null;
  },

  /**
   * Check if container type still exists elsewhere in equipment (excluding a specific row)
   */
  containerStillExistsElsewhere(containerId, excludeRowIndex) {
    const config = CONTAINER_CONFIGS[containerId];
    if (!config) return false;
    
    for (let i = 0; i < EQUIPMENT_SLOTS; i++) {
      if (i === excludeRowIndex) continue;
      const input = document.getElementById(`equip-${i}-name`);
      if (input && input.value.trim()) {
        const itemName = input.value.trim().toLowerCase();
        // Use getContainerIdFromItemName to get exact container ID 
        // (handles "reinforced backpack" vs "backpack" distinction)
        const foundId = this.getContainerIdFromItemName(itemName);
        if (foundId === containerId) {
          return true;
        }
      }
    }
    return false;
  },

  /**
   * Check if a container has any items stored
   */
  containerHasItems(containerId) {
    if (!this.character.containers || !this.character.containers[containerId]) {
      return false;
    }
    const items = this.character.containers[containerId];
    return items.some(item => item.name && item.name.trim() !== '');
  },

  /**
   * Get items from a container
   */
  getContainerItems(containerId) {
    if (!this.character.containers || !this.character.containers[containerId]) {
      return [];
    }
    return this.character.containers[containerId].filter(item => item.name && item.name.trim() !== '');
  },

  /**
   * Transfer items from one container to another (e.g., Backpack → Reinforced Backpack)
   */
  transferContainerItems(fromId, toId) {
    if (!this.character.containers) this.character.containers = {};
    
    const fromItems = this.character.containers[fromId] || [];
    const toConfig = CONTAINER_CONFIGS[toId];
    const fromConfig = CONTAINER_CONFIGS[fromId];
    
    // Initialize destination container with proper number of rows
    const toRows = toConfig ? toConfig.rows : 20;
    if (!this.character.containers[toId]) {
      this.character.containers[toId] = [];
      for (let i = 0; i < toRows; i++) {
        this.character.containers[toId].push({ name: '', enc: '' });
      }
    }
    
    // Copy items from old container to new container
    const itemsToCopy = fromItems.filter(item => item.name && item.name.trim() !== '');
    itemsToCopy.forEach((item, i) => {
      if (i < toRows) {
        this.character.containers[toId][i] = { ...item };
      }
    });
    
    // Clear old container
    delete this.character.containers[fromId];
    
    const fromName = fromConfig ? fromConfig.name : fromId;
    const toName = toConfig ? toConfig.name : toId;
    console.log(`Transferred ${itemsToCopy.length} items from ${fromName} to ${toName}`);
    
    this.updateContainerButtons();
    this.scheduleAutoSave();
  },

  /**
   * Handle container removal with user prompts
   * Returns true if removal should proceed, false if cancelled
   */
  async handleContainerRemoval(containerId, nameInput, previousValue) {
    const config = CONTAINER_CONFIGS[containerId];
    const containerName = config ? config.name : 'container';
    const items = this.getContainerItems(containerId);
    
    if (items.length === 0) return true;
    
    const itemCount = items.length;
    const itemList = items.map(i => i.name).join(', ');
    
    // First prompt: Move items?
    const moveItems = confirm(
      `The ${containerName} contains ${itemCount} item(s):\n${itemList}\n\n` +
      `Do you want to move these items to your main Equipment list?`
    );
    
    if (moveItems) {
      // Move items to main equipment
      const moved = this.moveContainerItemsToEquipment(containerId);
      if (moved) {
        // Clear the container
        this.character.containers[containerId] = [];
        this.scheduleAutoSave();
        alert(`${moved} item(s) moved to your Equipment list.`);
        return true;
      } else {
        alert('Not enough empty slots in Equipment to move all items. Please free up some space first.');
        return false;
      }
    } else {
      // Second prompt: Are you sure you want to delete?
      const confirmDelete = confirm(
        `Are you sure you want to permanently delete these items?\n\n` +
        `${itemList}\n\n` +
        `This cannot be undone.`
      );
      
      if (confirmDelete) {
        // Delete the items
        this.character.containers[containerId] = [];
        this.scheduleAutoSave();
        return true;
      } else {
        // User said no - cancel the operation
        return false;
      }
    }
  },

  /**
   * Move items from a container to main equipment
   * Returns number of items moved, or 0 if not enough space
   */
  moveContainerItemsToEquipment(containerId) {
    const items = this.getContainerItems(containerId);
    if (items.length === 0) return 0;
    
    // Find empty slots in equipment
    const emptySlots = [];
    for (let i = 0; i < EQUIPMENT_SLOTS; i++) {
      const nameInput = document.getElementById(`equip-${i}-name`);
      if (nameInput && !nameInput.value.trim()) {
        emptySlots.push(i);
      }
    }
    
    // Check if we have enough space
    if (emptySlots.length < items.length) {
      return 0;
    }
    
    // Move items
    items.forEach((item, idx) => {
      const slotIndex = emptySlots[idx];
      const nameInput = document.getElementById(`equip-${slotIndex}-name`);
      const encInput = document.getElementById(`equip-${slotIndex}-enc`);
      
      if (nameInput) {
        nameInput.value = this.toTitleCase(item.name);
        nameInput.dataset.previousValue = item.name.toLowerCase();
      }
      if (encInput && item.enc) {
        encInput.value = item.enc;
      }
    });
    
    // Update totals
    this.updateTotalEnc();
    this.updateContainerButtons();
    
    return items.length;
  },

  /**
   * Setup money input listeners
   */
  setupMoneyListeners() {
    const moneyTypes = ['copper', 'silver', 'gold', 'platinum', 'electrum'];
    moneyTypes.forEach(type => {
      const input = document.getElementById(`money-${type}`);
      if (input) {
        input.addEventListener('input', () => {
          this.updateMoneyEnc();
          this.updateTotalEnc();
          this.scheduleAutoSave();
        });
      }
    });
  },

  /**
   * Calculate and display money ENC
   * Every 100 coins = 1 Thing (ENC)
   */
  updateMoneyEnc() {
    const moneyTypes = ['copper', 'silver', 'gold', 'platinum', 'electrum'];
    let totalCoins = 0;
    
    moneyTypes.forEach(type => {
      const input = document.getElementById(`money-${type}`);
      if (input && input.value) {
        totalCoins += parseInt(input.value) || 0;
      }
    });
    
    const moneyEnc = Math.floor(totalCoins / 100);
    const moneyEncDisplay = document.getElementById('money-enc');
    if (moneyEncDisplay) {
      moneyEncDisplay.textContent = moneyEnc;
    }
    
    return moneyEnc;
  },

  /**
   * Get list of equipment item names (lowercased)
   */
  getEquipmentItemNames() {
    const items = [];
    for (let i = 0; i < EQUIPMENT_SLOTS; i++) {
      const input = document.getElementById(`equip-${i}-name`);
      if (input && input.value.trim()) {
        items.push(input.value.trim().toLowerCase());
      }
    }
    return items;
  },

  /**
   * Check if any equipment item matches a trigger
   */
  hasContainerItem(triggers) {
    const items = this.getEquipmentItemNames();
    return items.some(item => 
      triggers.some(trigger => item.includes(trigger))
    );
  },

  /**
   * Update container button visibility based on equipment
   */
  updateContainerButtons() {
    for (const [containerId, config] of Object.entries(CONTAINER_CONFIGS)) {
      const btn = document.getElementById(`btn-open-${containerId}`);
      if (btn) {
        // Check if we need to exclude this container (e.g., don't show backpack if reinforced backpack exists)
        let shouldShow = this.hasContainerItem(config.triggers);
        
        // Special case: don't show regular backpack if reinforced backpack is present
        if (containerId === 'backpack') {
          const hasReinforced = this.hasContainerItem(CONTAINER_CONFIGS['reinforced-backpack'].triggers);
          if (hasReinforced) shouldShow = false;
        }
        
        btn.classList.toggle('hidden', !shouldShow);
      }
    }
  },

  /**
   * Current active container type
   */
  activeContainer: null,

  /**
   * Setup container modal
   */
  setupContainerModal() {
    const modal = document.getElementById('container-modal');
    const closeBtn = document.getElementById('btn-close-container');
    const saveBtn = document.getElementById('btn-save-container');
    
    // Setup click handlers for all container buttons
    for (const containerId of Object.keys(CONTAINER_CONFIGS)) {
      const btn = document.getElementById(`btn-open-${containerId}`);
      if (btn) {
        btn.addEventListener('click', () => {
          this.openContainer(containerId);
        });
      }
    }
    
    // Close button
    if (closeBtn && modal) {
      closeBtn.addEventListener('click', () => {
        modal.classList.add('hidden');
        this.activeContainer = null;
      });
    }
    
    // Save & Close button
    if (saveBtn && modal) {
      saveBtn.addEventListener('click', () => {
        this.saveContainerData();
        modal.classList.add('hidden');
        this.activeContainer = null;
      });
    }
    
    // Click outside to close
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.saveContainerData();
          modal.classList.add('hidden');
          this.activeContainer = null;
        }
      });
    }
    
    // Alphabetize button
    const alphabetizeBtn = document.getElementById('btn-alphabetize-container');
    if (alphabetizeBtn) {
      alphabetizeBtn.addEventListener('click', () => {
        this.alphabetizeContainerItems();
      });
    }
    
    // Add row button
    const addRowBtn = document.getElementById('btn-add-container-row');
    if (addRowBtn) {
      addRowBtn.addEventListener('click', () => {
        this.addContainerRow();
      });
    }
    
    // Remove row button
    const removeRowBtn = document.getElementById('btn-remove-container-row');
    if (removeRowBtn) {
      removeRowBtn.addEventListener('click', () => {
        this.removeLastContainerRow();
      });
    }
  },

  /**
   * Open a container modal
   */
  openContainer(containerId) {
    const config = CONTAINER_CONFIGS[containerId];
    if (!config) return;
    
    this.activeContainer = containerId;
    
    const modal = document.getElementById('container-modal');
    const title = document.getElementById('container-modal-title');
    const maxEnc = document.getElementById('container-max-enc');
    const itemsContainer = document.getElementById('container-items');
    
    if (title) title.textContent = `${config.name} Contents`;
    if (maxEnc) maxEnc.textContent = config.maxEnc;
    
    // Generate rows for this container
    this.generateContainerRows(containerId, config.maxEnc);
    
    // Load saved data
    this.loadContainerData(containerId);
    
    // Update capacity display
    this.updateContainerCapacity();
    
    // Show modal
    if (modal) modal.classList.remove('hidden');
  },

  /**
   * Generate rows for container modal
   */
  generateContainerRows(containerId, maxEnc) {
    const container = document.getElementById('container-items');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Only create rows for saved items — no empty padding
    const savedItems = this.character.containers?.[containerId] || [];
    savedItems.forEach((item, i) => {
      if (item.name || (item.enc && item.enc !== '0')) {
        this._addContainerRowWithData(item.name || '', item.enc || '');
      }
    });
  },
  
  /**
   * Internal: create a single container row with optional data and auto-remove
   */
  _addContainerRowWithData(name = '', enc = '') {
    const container = document.getElementById('container-items');
    if (!container) return null;
    
    const i = container.querySelectorAll('.equipment-row').length;
    const row = document.createElement('div');
    row.className = 'equipment-row';
    row.innerHTML = `
      <input type="text" class="equipment-name" id="container-${i}-name" placeholder="">
      <input type="number" class="equipment-enc" id="container-${i}-enc" placeholder="" step="0.1">
    `;
    container.appendChild(row);
    
    const nameInput = row.querySelector('.equipment-name');
    const encInput = row.querySelector('.equipment-enc');
    
    if (name) nameInput.value = this.toTitleCase(name);
    if (enc) encInput.value = enc;
    
    // Autofill ENC on blur, auto-remove if cleared
    nameInput.addEventListener('blur', () => {
      if (nameInput.value.trim()) {
        nameInput.value = this.toTitleCase(nameInput.value.trim());
        
        // Block weapons from containers
        if (this.isWeaponItem(nameInput.value.trim())) {
          nameInput.value = '';
          encInput.value = '';
          // Show brief notification
          this._showContainerWeaponWarning();
          row.remove();
          this._reindexContainerRows();
          this.updateContainerCapacity();
          return;
        }
        
        if (window.EncumbranceData) {
          window.EncumbranceData.autofillEquipmentEnc('container', Array.from(container.querySelectorAll('.equipment-row')).indexOf(row), nameInput.value);
        }
      } else if (!nameInput.value.trim() && !encInput.value.trim()) {
        // Name cleared and no ENC — remove row
        row.remove();
        this._reindexContainerRows();
      }
      this.updateContainerCapacity();
    });
    
    encInput.addEventListener('input', () => {
      this.updateContainerCapacity();
    });
    
    return row;
  },
  
  /**
   * Reindex container rows after removal
   */
  _reindexContainerRows() {
    const container = document.getElementById('container-items');
    if (!container) return;
    
    const rows = container.querySelectorAll('.equipment-row');
    rows.forEach((row, i) => {
      const nameInput = row.querySelector('.equipment-name');
      const encInput = row.querySelector('.equipment-enc');
      if (nameInput) nameInput.id = `container-${i}-name`;
      if (encInput) encInput.id = `container-${i}-enc`;
    });
  },

  /**
   * Update container capacity display
   */
  updateContainerCapacity() {
    if (!this.activeContainer) return;
    
    const config = CONTAINER_CONFIGS[this.activeContainer];
    const currentDisplay = document.getElementById('container-current-enc');
    const capacityBar = document.querySelector('.container-capacity-bar');
    
    let totalEnc = 0;
    const container = document.getElementById('container-items');
    if (container) {
      container.querySelectorAll('.equipment-enc').forEach(input => {
        totalEnc += parseFloat(input.value) || 0;
      });
    }
    
    if (currentDisplay) {
      currentDisplay.textContent = totalEnc.toFixed(1);
    }
    
    // Add over-capacity class if exceeded
    const isOverCapacity = totalEnc > config.maxEnc;
    if (capacityBar) {
      capacityBar.classList.toggle('over-capacity', isOverCapacity);
    }
    
    // Show/hide warning message
    let warningEl = document.getElementById('container-capacity-warning');
    if (isOverCapacity) {
      if (!warningEl) {
        warningEl = document.createElement('div');
        warningEl.id = 'container-capacity-warning';
        warningEl.className = 'container-capacity-warning';
        const modalBody = document.querySelector('#container-modal .modal-body');
        if (modalBody) {
          modalBody.insertBefore(warningEl, modalBody.firstChild);
        }
      }
      warningEl.innerHTML = `⚠️ Container is over capacity! Max: ${config.maxEnc} ENC, Current: ${totalEnc.toFixed(1)} ENC`;
    } else if (warningEl) {
      warningEl.remove();
    }
  },

  /**
   * Save container data to character
   */
  saveContainerData() {
    if (!this.activeContainer) return;
    
    if (!this.character.containers) {
      this.character.containers = {};
    }
    
    const items = [];
    const container = document.getElementById('container-items');
    if (container) {
      container.querySelectorAll('.equipment-row').forEach((row, i) => {
        const nameInput = row.querySelector('.equipment-name');
        const encInput = row.querySelector('.equipment-enc');
        const name = nameInput?.value?.trim() || '';
        const enc = encInput?.value || '';
        
        // Only save non-empty rows
        if (name || (enc && enc !== '0')) {
          items.push({ name, enc });
        }
      });
    }
    
    this.character.containers[this.activeContainer] = items;
    this.scheduleAutoSave();
  },

  /**
   * Load container data from character
   * Note: Data is now loaded directly in generateContainerRows
   */
  loadContainerData(containerId) {
    // Data already populated by generateContainerRows
  },

  /**
   * Alphabetize container items - rebuild with only filled rows
   */
  alphabetizeContainerItems() {
    const container = document.getElementById('container-items');
    if (!container) return;
    
    // Gather filled items
    const items = [];
    container.querySelectorAll('.equipment-row').forEach(row => {
      const nameInput = row.querySelector('.equipment-name');
      const encInput = row.querySelector('.equipment-enc');
      const name = nameInput?.value?.trim() || '';
      const enc = encInput?.value || '';
      if (name) items.push({ name, enc });
    });
    
    // Sort alphabetically
    items.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
    
    // Clear and rebuild with only filled rows
    container.innerHTML = '';
    items.forEach(item => {
      this._addContainerRowWithData(item.name, item.enc);
    });
    
    this.updateContainerCapacity();
  },

  /**
   * Add a new row to the container
   */
  addContainerRow() {
    const row = this._addContainerRowWithData('', '');
    if (row) {
      row.querySelector('.equipment-name')?.focus();
    }
  },

  /**
   * Remove the last empty row from the container
   */
  removeLastContainerRow() {
    const container = document.getElementById('container-items');
    if (!container) return;
    
    const rows = container.querySelectorAll('.equipment-row');
    if (rows.length === 0) return;
    
    const lastRow = rows[rows.length - 1];
    const nameInput = lastRow.querySelector('.equipment-name');
    const hasContent = nameInput && nameInput.value.trim();
    
    if (hasContent) {
      if (!confirm(`Remove "${nameInput.value.trim()}"?`)) return;
    }
    
    lastRow.remove();
    this._reindexContainerRows();
    this.updateContainerCapacity();
  },

  /**
   * Generate hit location rows based on sheet type
   */
  generateHitLocations() {
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return;
    
    const locations = HIT_LOCATIONS[this.sheetType] || HIT_LOCATIONS.human;
    
    tbody.innerHTML = '';
    
    locations.forEach((loc, i) => {
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${loc.roll}</td>
        <td>${loc.location}</td>
        <td>${loc.noArmor ? '<span class="no-armor-note">Wings may not have armor</span>' : `<input type="text" class="armor-input" id="loc-${i}-armor" placeholder="">`}</td>
        <td>${loc.noArmor ? '' : `<input type="number" class="ap-input" id="loc-${i}-ap" placeholder="0">`}</td>
        <td class="hp-cell">
          <input type="number" class="hp-max-input derived-readonly" id="loc-${i}-hp" placeholder="" readonly>
          <span class="hp-separator">/</span>
          <div class="hp-current-wrapper">
            <input type="number" class="hp-current" id="loc-${i}-current" placeholder="">
            <div class="hp-btn-stack">
              <button type="button" class="hp-btn hp-up" data-loc="${i}" title="Increase HP">▲</button>
              <button type="button" class="hp-btn hp-down" data-loc="${i}" title="Decrease HP">▼</button>
            </div>
          </div>
        </td>
        <td><span class="wound-status clickable" id="loc-${i}-status" data-status="none" data-location="${loc.location}">—</span></td>
      `;
      tbody.appendChild(tr);
      
      // Add wound status update listener
      const currentInput = tr.querySelector('.hp-current');
      const maxInput = tr.querySelector('.hp-max-input');
      const statusSpan = tr.querySelector('.wound-status');
      
      if (currentInput && statusSpan) {
        currentInput.addEventListener('input', () => {
          // Enforce max limit - current cannot exceed original max HP
          const maxHP = parseInt(maxInput.value, 10) || 0;
          const currentHP = parseInt(currentInput.value, 10);
          if (!isNaN(currentHP) && currentHP > maxHP && maxHP > 0) {
            currentInput.value = maxHP;
          }
          this.updateWoundStatus(i);
          this.scheduleAutoSave();
          // Update unarmed AP/HP if arm HP changed
          const locName = cells[1]?.textContent?.trim() || '';
          if (locName === 'R Arm' || locName === 'L Arm') {
            this.updateUnarmedAPHP();
          }
        });
      }
      
      // Add event listeners (only for editable inputs)
      tr.querySelectorAll('input:not([readonly]):not(.hp-current)').forEach(input => {
        input.addEventListener('input', () => {
          this.scheduleAutoSave();
          // Update unarmed AP/HP if arm AP changed
          if (input.classList.contains('ap-input')) {
            const locName2 = input.closest('tr')?.querySelectorAll('td')[1]?.textContent?.trim() || '';
            if (locName2 === 'R Arm' || locName2 === 'L Arm') {
              this.updateUnarmedAPHP();
            }
          }
        });
      });
      
      // Add armor AP auto-fill on blur (only for armor inputs)
      const armorInput = tr.querySelector('.armor-input');
      const apInput = tr.querySelector('.ap-input');
      if (armorInput && apInput) {
        // Store the previous armor value to detect changes
        armorInput.dataset.previousArmor = '';
        
        armorInput.addEventListener('blur', () => {
          const currentArmor = armorInput.value.trim();
          const previousArmor = armorInput.dataset.previousArmor || '';
          
          if (currentArmor !== previousArmor) {
            // If armor was removed (field cleared), reset AP to 0
            if (!currentArmor) {
              apInput.value = 0;
              apInput.dataset.autoFilled = 'true';
              this.scheduleAutoSave();
            } else if (window.ArmorData) {
              const ap = window.ArmorData.getAP(currentArmor);
              if (ap !== null) {
                // Set AP for recognized armor (including 0 for robes/clothing)
                const currentAP = apInput.value.trim();
                const wasAutoFilled = apInput.dataset.autoFilled === 'true';
                
                if (!currentAP || currentAP === '0' || wasAutoFilled) {
                  apInput.value = ap;
                  apInput.dataset.autoFilled = 'true';
                  this.scheduleAutoSave();
                }
              }
            }
          }
          
          armorInput.dataset.previousArmor = currentArmor;
          
          // Check Agile display (depends on armor type)
          this.updateAgileDisplay();
          // Check Artful Dodger display (depends on armor type)
          this.updateArtfulDodgerDisplay();
          // Check Very Agile display (depends on unarmored status)
          this.updateVeryAgileDisplay();
          // Check Monk abilities (depends on unarmored status)
          this.checkMonkAbilitiesVisibility();
        });
        
        // Track when user manually edits AP
        apInput.addEventListener('input', () => {
          apInput.dataset.autoFilled = 'false';
        });
        
        // Immediately re-verify ability conditions when armor text changes (not just on blur)
        armorInput.addEventListener('input', () => {
          this.updateArtfulDodgerDisplay();
          this.updateAgileDisplay();
          this.updateVeryAgileDisplay();
          this.checkMonkAbilitiesVisibility();
        });
        apInput.addEventListener('blur', () => {
          this.checkMonkAbilitiesVisibility();
        });
      }
    });
  },

  /**
   * Update hit location HP values based on calculated results
   */
  updateHitLocationHPs(hitLocations) {
    if (!hitLocations) return;
    
    // Ensure character.combat.hitLocations exists
    if (!this.character.combat) this.character.combat = {};
    if (!this.character.combat.hitLocations) {
      this.character.combat.hitLocations = [];
    }
    
    hitLocations.forEach((loc, i) => {
      const hpInput = document.getElementById(`loc-${i}-hp`);
      if (hpInput) {
        hpInput.value = loc.hp;
      }
      
      // Also update the character object so autosave picks up the change
      if (!this.character.combat.hitLocations[i]) {
        this.character.combat.hitLocations[i] = { armor: '', ap: '', hp: '', current: '' };
      }
      this.character.combat.hitLocations[i].hp = loc.hp.toString();
    });
    
    // Update wound statuses since max HP may have changed
    this.updateAllWoundStatuses();
  },

  /**
   * Heal all hit locations - show confirmation modal
   */
  healAllHitLocations() {
    // Show confirmation modal
    const modal = document.getElementById('heal-all-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
  },

  /**
   * Confirm heal all - actually restore HP
   */
  confirmHealAll() {
    // Find all hit location rows and restore current to max
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return;
    
    const rows = tbody.querySelectorAll('tr');
    rows.forEach((row, i) => {
      const hpMaxInput = document.getElementById(`loc-${i}-hp`);
      const hpCurrentInput = document.getElementById(`loc-${i}-current`);
      
      if (hpMaxInput && hpCurrentInput) {
        const maxHP = hpMaxInput.value || '';
        hpCurrentInput.value = maxHP;
      }
    });
    
    // Update all wound statuses
    this.updateAllWoundStatuses();
    
    // Close modal
    this.closeHealModal();
    
    // Save changes
    this.scheduleAutoSave();
    
    // Update summary widgets if visible
    this.refreshSummaryWidgets();
  },

  /**
   * Close the heal all confirmation modal
   */
  closeHealModal() {
    const modal = document.getElementById('heal-all-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Adjust a hit location's current HP by a delta
   * @param {number|string} locationIndex - Index of the hit location
   * @param {number} delta - Amount to change HP by (+1 or -1)
   */
  adjustLocationHP(locationIndex, delta) {
    const maxInput = document.getElementById(`loc-${locationIndex}-hp`);
    const currentInput = document.getElementById(`loc-${locationIndex}-current`);
    
    if (!currentInput) return;
    
    const maxHP = parseInt(maxInput?.value, 10) || 0;
    let currentHP = parseInt(currentInput.value, 10);
    
    // If current is empty, start from max
    if (isNaN(currentHP) || currentInput.value === '') {
      currentHP = maxHP;
    }
    
    // Apply delta
    let newHP = currentHP + delta;
    
    // Enforce max limit (cannot go above original max)
    if (newHP > maxHP && maxHP > 0) {
      newHP = maxHP;
    }
    
    currentInput.value = newHP;
    
    // Update wound status (this will apply fatigue if needed)
    this.updateWoundStatus(locationIndex);
    
    this.scheduleAutoSave();
  },

  /**
   * Update wound status for a specific hit location
   * @param {number} locationIndex - Index of the hit location
   * @param {boolean} applyFatigue - Whether to apply fatigue changes (default true)
   */
  updateWoundStatus(locationIndex, applyFatigue = true) {
    const maxInput = document.getElementById(`loc-${locationIndex}-hp`);
    const currentInput = document.getElementById(`loc-${locationIndex}-current`);
    const statusSpan = document.getElementById(`loc-${locationIndex}-status`);
    
    if (!maxInput || !currentInput || !statusSpan) return;
    
    const maxHP = parseInt(maxInput.value, 10) || 0;
    const currentHP = parseInt(currentInput.value, 10);
    
    // Get previous status to detect changes
    const previousStatus = statusSpan.dataset.status || 'none';
    
    // If current is empty or NaN, show no status
    if (isNaN(currentHP) || currentInput.value === '') {
      statusSpan.textContent = '—';
      statusSpan.dataset.status = 'none';
      statusSpan.className = 'wound-status clickable';
      return;
    }
    
    let status, statusClass;
    
    if (currentHP >= maxHP) {
      status = 'No Damage';
      statusClass = 'wound-none';
    } else if (currentHP > 0) {
      status = 'Minor Wound';
      statusClass = 'wound-minor';
    } else if (currentHP > -maxHP) {
      status = 'Serious Wound';
      statusClass = 'wound-serious';
    } else {
      status = 'Major Wound';
      statusClass = 'wound-major';
    }
    
    // Check if wound status worsened to Major - apply fatigue (Incapacitated)
    // Note: Serious Wound does NOT affect fatigue - only Major Wound does
    if (applyFatigue && statusClass !== previousStatus) {
      if (statusClass === 'wound-major' && previousStatus !== 'wound-major') {
        // Major Wound - set to Incapacitated (if not already worse)
        this.applyWoundFatigue('incapacitated', 'Major Wound');
      }
      // Going from Major to Serious does not change fatigue - they stay Incapacitated
    }
    
    statusSpan.textContent = status;
    statusSpan.dataset.status = statusClass;
    statusSpan.className = `wound-status clickable ${statusClass}`;
  },

  /**
   * Apply fatigue from wound (only if current fatigue is less severe)
   */
  applyWoundFatigue(targetState, woundType) {
    const fatigueOrder = ['fresh', 'winded', 'tired', 'wearied', 'exhausted', 'debilitated', 'incapacitated', 'semiconscious', 'coma'];
    const currentState = this.character.fatigueState || 'fresh';
    
    const currentIndex = fatigueOrder.indexOf(currentState);
    const targetIndex = fatigueOrder.indexOf(targetState);
    
    // Only apply if target is more severe than current
    if (targetIndex > currentIndex) {
      this.setFatigueState(targetState, true);
      
      // Show notification
      const formattedCurrent = this.formatFatigueState(currentState);
      const formattedTarget = this.formatFatigueState(targetState);
      alert(`${woundType}! Fatigue changed from ${formattedCurrent} to ${formattedTarget}.`);
    }
  },

  /**
   * Update all wound statuses (without applying fatigue - used for loading/refreshing)
   */
  updateAllWoundStatuses() {
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return;
    
    const rows = tbody.querySelectorAll('tr');
    rows.forEach((row, i) => {
      this.updateWoundStatus(i, false); // Don't apply fatigue on bulk updates
    });
  },

  /**
   * Show wound info modal for a specific wound type
   */
  showWoundInfoModal(woundType, locationName) {
    const modal = document.getElementById('wound-info-modal');
    const header = document.getElementById('wound-info-header');
    const title = document.getElementById('wound-info-title');
    const body = document.getElementById('wound-info-body');
    
    if (!modal || !body) return;
    
    // Get healing rate for major wound info
    const healingRate = document.getElementById('healing-rate')?.value || '3';
    const combatRounds = parseInt(healingRate, 10) * 2;
    
    // Get Endurance skill value - use ORIGINAL value before fatigue penalties
    // This is important because Major Wound sets Incapacitated, but the roll should be against the standard %
    const enduranceInput = document.getElementById('endurance-current');
    const enduranceValue = enduranceInput?.dataset.originalValue || enduranceInput?.value || '0';
    
    let content = '';
    let headerClass = '';
    
    switch (woundType) {
      case 'wound-minor':
        headerClass = 'wound-info-header-minor';
        title.innerHTML = '🩹 Minor Wound';
        content = `
          <div class="wound-info-section">
            <p class="wound-intro">A Minor Wound is nothing more than a scratch, bruise, or superficial cut. It might sting, but it won't slow your character down.</p>
            <p class="wound-effect-good"><strong>Your character can keep fighting as normal.</strong></p>
          </div>
        `;
        break;
        
      case 'wound-serious':
        headerClass = 'wound-info-header-serious';
        title.innerHTML = '⚠️ Serious Wound';
        content = `
          <div class="wound-info-section">
            <p class="wound-intro">A Serious Wound happens when a Hit Location is reduced to <strong>0 HP or below</strong>. These wounds are painful and debilitating.</p>
          </div>
          
          <div class="wound-info-section">
            <h4>Effects of a Serious Wound:</h4>
            <ul class="wound-effects-list">
              <li>The location is <strong>scarred permanently</strong>.</li>
              <li>Your character is <strong>stunned for 1d3 Turns</strong>, unable to attack or cast spells (but they can still Parry or Evade).</li>
              <li>Your character must make an <strong>Opposed Endurance roll</strong> against the attacker's roll to avoid further effects.</li>
            </ul>
            <div class="wound-roll-section">
              <button type="button" class="btn btn-roll-endurance" id="btn-roll-endurance-serious">
                🎲 Roll Endurance (${enduranceValue}%)
              </button>
            </div>
          </div>
          
          <div class="wound-info-section wound-penalties">
            <h4>Additional Penalties for Specific Locations:</h4>
            
            <div class="wound-location-group">
              <h5>🦵 Arm or Leg Wound:</h5>
              <ul>
                <li>Failing the Endurance roll means the <strong>limb is useless</strong> until it's healed.</li>
                <li>If it's a <strong>leg</strong>, your character <strong>falls prone</strong>.</li>
                <li>If it's an <strong>arm</strong>, your character <strong>drops whatever they're holding</strong> unless it's strapped on.</li>
              </ul>
            </div>
            
            <div class="wound-location-group">
              <h5>💀 Abdomen, Chest, or Head Wound:</h5>
              <ul>
                <li>Failing the Endurance roll results in <strong>unconsciousness</strong> for a number of minutes equal to the damage taken.</li>
              </ul>
            </div>
            
            <p class="wound-note">Even if your character remains conscious, any tasks involving the wounded location suffer a penalty of <strong>one Difficulty Grade</strong> until the wound is downgraded to Minor.</p>
          </div>
        `;
        break;
        
      case 'wound-major':
        headerClass = 'wound-info-header-major';
        title.innerHTML = '💀 Major Wound';
        content = `
          <div class="wound-info-section">
            <p class="wound-intro wound-intro-major">A Major Wound happens when a Hit Location's Hit Points are reduced to a <strong>negative score equal to or greater than its starting HP</strong> (e.g., going from 6 to -6). These wounds are <strong>catastrophic and life-threatening</strong>.</p>
          </div>
          
          <div class="wound-info-section">
            <h4>Effects of a Major Wound:</h4>
            <ul class="wound-effects-list wound-effects-major">
              <li>Your character is <strong>immediately Incapacitated</strong> and can't continue fighting.</li>
              <li>The affected limb is <strong>severed, shattered, or ripped off</strong>.</li>
              <li>Your character <strong>falls prone</strong> and must make an <strong>Opposed Endurance roll</strong> against the attacker's roll to avoid unconsciousness.</li>
            </ul>
            <div class="wound-roll-section">
              <button type="button" class="btn btn-roll-endurance btn-roll-major" id="btn-roll-endurance-major">
                🎲 Roll Endurance (${enduranceValue}%)
              </button>
            </div>
          </div>
          
          <div class="wound-info-section wound-fatal">
            <h4>⚰️ Abdomen, Chest, or Head Wound:</h4>
            <p class="wound-death-warning">Failing the Endurance roll means <strong>instant death</strong>. This could be decapitation, being chopped in half, or impalement through the heart.</p>
          </div>
          
          <div class="wound-info-section wound-survival">
            <h4>🩸 If Your Character Survives:</h4>
            <p>They still need <strong>immediate medical attention</strong>. The wound must be treated within <strong>${combatRounds} Combat Rounds</strong> (2× Healing Rate of ${healingRate}).</p>
            <p class="wound-death-warning">If not treated in time, your character will <strong>die from Blood Loss and shock</strong>.</p>
          </div>
        `;
        break;
        
      default:
        return; // Don't show modal for "No Damage" or empty status
    }
    
    // Update header class
    header.className = `modal-header wound-info-header ${headerClass}`;
    
    // Set content and show modal
    body.innerHTML = content;
    modal.classList.remove('hidden');
    
    // Add roll button listeners
    const seriousRollBtn = document.getElementById('btn-roll-endurance-serious');
    const majorRollBtn = document.getElementById('btn-roll-endurance-major');
    
    if (seriousRollBtn) {
      seriousRollBtn.addEventListener('click', () => {
        this.rollD100('Endurance', enduranceValue);
      });
    }
    if (majorRollBtn) {
      majorRollBtn.addEventListener('click', () => {
        this.rollD100('Endurance', enduranceValue);
      });
    }
  },

  /**
   * Close wound info modal
   */
  closeWoundInfoModal() {
    const modal = document.getElementById('wound-info-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Start a new game session - restore Luck Points to maximum
   */
  startNewGame() {
    // Get the maximum Luck Points (calculated value)
    const luckPointsMax = document.getElementById('luck-original')?.value || '0';
    const luckPointsCurrent = document.getElementById('luck-current');
    
    if (luckPointsCurrent) {
      luckPointsCurrent.value = luckPointsMax;
    }
    
    // Save the change
    this.scheduleAutoSave();
    
    // Update the modal display and show it
    const luckDisplay = document.getElementById('new-game-luck-value');
    if (luckDisplay) {
      luckDisplay.textContent = luckPointsMax;
    }
    
    const modal = document.getElementById('new-game-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
  },

  /**
   * Close the New Game modal
   */
  closeNewGameModal() {
    const modal = document.getElementById('new-game-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Show the Finish Game modal
   */
  showFinishGameModal() {
    // Get current EXP Rolls
    const expRollsInput = document.getElementById('exp-rolls');
    const currentExp = parseInt(expRollsInput?.value, 10) || 0;
    
    // Update the display
    const currentExpDisplay = document.getElementById('finish-game-current-exp');
    if (currentExpDisplay) {
      currentExpDisplay.textContent = currentExp;
    }
    
    // Reset the input to 1
    const expInput = document.getElementById('finish-game-exp');
    if (expInput) {
      expInput.value = 1;
    }
    
    // Update the preview
    this.updateFinishGamePreview();
    
    // Show the modal
    const modal = document.getElementById('finish-game-modal');
    if (modal) {
      modal.classList.remove('hidden');
    }
  },

  /**
   * Update the Finish Game EXP preview
   */
  updateFinishGamePreview() {
    const expRollsInput = document.getElementById('exp-rolls');
    const currentExp = parseInt(expRollsInput?.value, 10) || 0;
    
    const earnedInput = document.getElementById('finish-game-exp');
    const earned = parseInt(earnedInput?.value, 10) || 0;
    
    const newTotal = currentExp + earned;
    
    const newExpDisplay = document.getElementById('finish-game-new-exp');
    if (newExpDisplay) {
      newExpDisplay.textContent = newTotal;
    }
  },

  /**
   * Confirm and apply Finish Game changes
   */
  confirmFinishGame() {
    const expRollsInput = document.getElementById('exp-rolls');
    const currentExp = parseInt(expRollsInput?.value, 10) || 0;
    
    const earnedInput = document.getElementById('finish-game-exp');
    const earned = parseInt(earnedInput?.value, 10) || 0;
    
    if (earned > 0 && expRollsInput) {
      expRollsInput.value = currentExp + earned;
    }
    
    // Close the modal
    this.closeFinishGameModal();
    
    // Save the character sheet
    this.scheduleAutoSave();
    
    // Show confirmation (could be a toast in the future)
    console.log(`Game session finished! Added ${earned} EXP Rolls. Total: ${currentExp + earned}`);
  },

  /**
   * Close the Finish Game modal
   */
  closeFinishGameModal() {
    const modal = document.getElementById('finish-game-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Save hit locations data to character object
   */
  saveHitLocationsToCharacter() {
    if (!this.character.combat) this.character.combat = {};
    this.character.combat.hitLocations = [];
    
    // Save up to 9 locations (max for syrin)
    for (let i = 0; i < 9; i++) {
      const armorInput = document.getElementById(`loc-${i}-armor`);
      const apInput = document.getElementById(`loc-${i}-ap`);
      const hpInput = document.getElementById(`loc-${i}-hp`);
      const currentInput = document.getElementById(`loc-${i}-current`);
      
      // Only save if we found at least the HP input (always exists)
      if (hpInput || currentInput) {
        this.character.combat.hitLocations.push({
          armor: armorInput?.value || '',
          ap: apInput?.value || '',
          hp: hpInput?.value || '',
          current: currentInput?.value || ''
        });
      }
    }
  },

  /**
   * Load hit locations data from character object
   */
  loadHitLocationsFromCharacter() {
    if (!this.character.combat || !this.character.combat.hitLocations) return;
    
    this.character.combat.hitLocations.forEach((loc, i) => {
      const armorInput = document.getElementById(`loc-${i}-armor`);
      const apInput = document.getElementById(`loc-${i}-ap`);
      const hpInput = document.getElementById(`loc-${i}-hp`);
      const currentInput = document.getElementById(`loc-${i}-current`);
      
      if (armorInput && loc.armor) armorInput.value = loc.armor;
      if (apInput && loc.ap) apInput.value = loc.ap;
      if (hpInput && loc.hp !== undefined && loc.hp !== '') hpInput.value = loc.hp;
      if (currentInput && loc.current) currentInput.value = loc.current;
    });
    
    // Update wound statuses after loading
    this.updateAllWoundStatuses();
  },

  /**
   * Generate weapon table rows
   */
  generateWeaponRows() {
    // Melee weapons - only create rows for saved weapons
    const meleeBody = document.getElementById('melee-weapons-body');
    if (meleeBody) {
      meleeBody.innerHTML = '';
      const savedMelee = (this.character.combat && this.character.combat.meleeWeapons) || [];
      const numMelee = savedMelee.length;
      
      for (let i = 0; i < numMelee; i++) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><input type="text" id="melee-${i}-name" class="weapon-name" placeholder=""></td>
          <td><input type="text" id="melee-${i}-hands" placeholder=""></td>
          <td><div class="damage-cell"><input type="text" id="melee-${i}-damage" class="weapon-damage" placeholder=""><button type="button" class="dice-btn weapon-dice-btn" title="Roll damage">🎲</button></div></td>
          <td><input type="text" id="melee-${i}-size" placeholder=""></td>
          <td><input type="text" id="melee-${i}-effects" placeholder=""></td>
          <td><input type="text" id="melee-${i}-aphp" placeholder=""></td>
          <td><input type="text" id="melee-${i}-traits" placeholder=""></td>
        `;
        meleeBody.appendChild(tr);
        
        // Add autofill listener for weapon name field
        const nameInput = tr.querySelector(`#melee-${i}-name`);
        const rowIndex = i;
        if (nameInput) {
          nameInput.addEventListener('blur', () => {
            // Convert to title case
            if (nameInput.value.trim()) {
              nameInput.value = this.toTitleCase(nameInput.value.trim());
            }
            if (window.WeaponData && window.WeaponData.autofillMeleeWeapon) {
              window.WeaponData.autofillMeleeWeapon(rowIndex, nameInput.value);
              this.highlightSpecializedWeapons();
              this.syncCombatToEquipment(nameInput.value.trim(), 'melee');
              this.scheduleAutoSave();
            }
          });
        }
        
        // Mark row as user-modified when any non-name field is edited
        tr.querySelectorAll('input').forEach(input => {
          input.addEventListener('input', () => {
            // If editing any field other than name, mark this row as user-modified
            if (!input.id.endsWith('-name')) {
              const nameInput = tr.querySelector(`#melee-${rowIndex}-name`);
              if (nameInput) nameInput.dataset.userModified = 'true';
              // Update baseDamage when user edits the damage field
              if (input.id.endsWith('-damage') && input.dataset.baseDamage !== undefined) {
                const wName = nameInput ? nameInput.value : '';
                input.dataset.baseDamage = window.WeaponData.extractBaseDamage(input.value, wName);
              }
            }
            this.scheduleAutoSave();
          });
        });
      }
    }
    
    // Ranged weapons - only create rows for saved weapons
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (rangedBody) {
      rangedBody.innerHTML = '';
      const savedRanged = (this.character.combat && this.character.combat.rangedWeapons) || [];
      const numRanged = savedRanged.length;
      
      for (let i = 0; i < numRanged; i++) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td><input type="text" id="ranged-${i}-name" class="weapon-name" placeholder=""></td>
          <td><input type="text" id="ranged-${i}-hands" placeholder=""></td>
          <td><div class="damage-cell"><input type="text" id="ranged-${i}-damage" class="weapon-damage" placeholder=""><button type="button" class="dice-btn weapon-dice-btn" title="Roll damage">🎲</button></div></td>
          <td><input type="text" id="ranged-${i}-dm" placeholder=""></td>
          <td><input type="text" id="ranged-${i}-range" placeholder=""></td>
          <td><input type="text" id="ranged-${i}-load" placeholder=""></td>
          <td><input type="text" id="ranged-${i}-effects" placeholder=""></td>
          <td><input type="text" id="ranged-${i}-impl" placeholder=""></td>
          <td><input type="text" id="ranged-${i}-aphp" placeholder=""></td>
          <td><input type="text" id="ranged-${i}-traits" placeholder=""></td>
        `;
        rangedBody.appendChild(tr);
        
        // Add autofill listener for ranged weapon name field
        const nameInput = tr.querySelector(`#ranged-${i}-name`);
        const rowIndex = i;
        if (nameInput) {
          nameInput.addEventListener('blur', () => {
            // Convert to title case
            if (nameInput.value.trim()) {
              nameInput.value = this.toTitleCase(nameInput.value.trim());
            }
            if (window.WeaponData && window.WeaponData.autofillRangedWeapon) {
              window.WeaponData.autofillRangedWeapon(rowIndex, nameInput.value);
              this.highlightSpecializedWeapons();
              this.syncCombatToEquipment(nameInput.value.trim(), 'ranged');
              // Apply load reduction after autofill sets the base load value
              this.applyRangedSpecLoadReduction();
              this.scheduleAutoSave();
            }
          });
        }
        
        // Mark row as user-modified when any non-name field is edited
        tr.querySelectorAll('input').forEach(input => {
          input.addEventListener('input', () => {
            // If editing any field other than name, mark this row as user-modified
            if (!input.id.endsWith('-name')) {
              const nameInput = tr.querySelector(`#ranged-${rowIndex}-name`);
              if (nameInput) nameInput.dataset.userModified = 'true';
              // Update baseDamage when user edits the damage field
              if (input.id.endsWith('-damage') && input.dataset.baseDamage !== undefined) {
                const wName = nameInput ? nameInput.value : '';
                input.dataset.baseDamage = window.WeaponData.extractBaseDamage(input.value, wName);
              }
            }
            this.scheduleAutoSave();
          });
        });
      }
    }
  },
  
  /**
   * Add a new melee weapon row
   */
  addMeleeWeaponRow() {
    const meleeBody = document.getElementById('melee-weapons-body');
    if (!meleeBody) return;
    
    const i = meleeBody.querySelectorAll('tr').length;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="text" id="melee-${i}-name" class="weapon-name" placeholder=""></td>
      <td><input type="text" id="melee-${i}-hands" placeholder=""></td>
      <td><div class="damage-cell"><input type="text" id="melee-${i}-damage" class="weapon-damage" placeholder=""><button type="button" class="dice-btn weapon-dice-btn" title="Roll damage">🎲</button></div></td>
      <td><input type="text" id="melee-${i}-size" placeholder=""></td>
      <td><input type="text" id="melee-${i}-effects" placeholder=""></td>
      <td><input type="text" id="melee-${i}-aphp" placeholder=""></td>
      <td><input type="text" id="melee-${i}-traits" placeholder=""></td>
    `;
    meleeBody.appendChild(tr);
    
    const nameInput = tr.querySelector(`#melee-${i}-name`);
    const rowIndex = i;
    if (nameInput) {
      nameInput.addEventListener('blur', () => {
        if (nameInput.value.trim()) {
          nameInput.value = this.toTitleCase(nameInput.value.trim());
        }
        if (window.WeaponData && window.WeaponData.autofillMeleeWeapon) {
          window.WeaponData.autofillMeleeWeapon(rowIndex, nameInput.value);
          this.syncCombatToEquipment(nameInput.value.trim(), 'melee');
          this.scheduleAutoSave();
        }
      });
    }
    
    tr.querySelectorAll('input').forEach(input => {
      input.addEventListener('input', () => {
        if (!input.id.endsWith('-name')) {
          const nameInput = tr.querySelector(`#melee-${rowIndex}-name`);
          if (nameInput) nameInput.dataset.userModified = 'true';
          // Update baseDamage when user edits the damage field
          if (input.id.endsWith('-damage') && input.dataset.baseDamage !== undefined) {
            const wName = nameInput ? nameInput.value : '';
            input.dataset.baseDamage = window.WeaponData.extractBaseDamage(input.value, wName);
          }
        }
        this.scheduleAutoSave();
      });
    });
    
    this.scheduleAutoSave();
  },
  
  /**
   * Ensure Unarmed is always present as a melee weapon
   */
  ensureUnarmedWeapon() {
    const meleeBody = document.getElementById('melee-weapons-body');
    if (!meleeBody) return;
    
    // Check if Unarmed already exists
    const rows = meleeBody.querySelectorAll('tr');
    for (const row of rows) {
      const nameInput = row.querySelector('.weapon-name');
      if (nameInput && nameInput.value.toLowerCase().trim() === 'unarmed') {
        return; // Already exists, don't add
      }
    }
    
    // Add Unarmed as first melee weapon
    this.addMeleeWeaponRow();
    const newRowIndex = meleeBody.querySelectorAll('tr').length - 1;
    const nameInput = document.getElementById(`melee-${newRowIndex}-name`);
    if (nameInput) {
      nameInput.value = 'Unarmed';
      // Trigger autofill
      if (window.WeaponData && window.WeaponData.autofillMeleeWeapon) {
        window.WeaponData.autofillMeleeWeapon(newRowIndex, 'Unarmed');
      }
    }
  },
  
  /**
   * Add a new ranged weapon row
   */
  addRangedWeaponRow() {
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (!rangedBody) return;
    
    const i = rangedBody.querySelectorAll('tr').length;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="text" id="ranged-${i}-name" class="weapon-name" placeholder=""></td>
      <td><input type="text" id="ranged-${i}-hands" placeholder=""></td>
      <td><div class="damage-cell"><input type="text" id="ranged-${i}-damage" class="weapon-damage" placeholder=""><button type="button" class="dice-btn weapon-dice-btn" title="Roll damage">🎲</button></div></td>
      <td><input type="text" id="ranged-${i}-dm" placeholder=""></td>
      <td><input type="text" id="ranged-${i}-range" placeholder=""></td>
      <td><input type="text" id="ranged-${i}-load" placeholder=""></td>
      <td><input type="text" id="ranged-${i}-effects" placeholder=""></td>
      <td><input type="text" id="ranged-${i}-impl" placeholder=""></td>
      <td><input type="text" id="ranged-${i}-aphp" placeholder=""></td>
      <td><input type="text" id="ranged-${i}-traits" placeholder=""></td>
    `;
    rangedBody.appendChild(tr);
    
    const nameInput = tr.querySelector(`#ranged-${i}-name`);
    const rowIndex = i;
    if (nameInput) {
      nameInput.addEventListener('blur', () => {
        if (nameInput.value.trim()) {
          nameInput.value = this.toTitleCase(nameInput.value.trim());
        }
        if (window.WeaponData && window.WeaponData.autofillRangedWeapon) {
          window.WeaponData.autofillRangedWeapon(rowIndex, nameInput.value);
              this.highlightSpecializedWeapons();
          this.syncCombatToEquipment(nameInput.value.trim(), 'ranged');
          // Apply load reduction after autofill sets the base load value
          this.applyRangedSpecLoadReduction();
          this.scheduleAutoSave();
        }
      });
    }
    
    tr.querySelectorAll('input').forEach(input => {
      input.addEventListener('input', () => {
        if (!input.id.endsWith('-name')) {
          const nameInput = tr.querySelector(`#ranged-${rowIndex}-name`);
          if (nameInput) nameInput.dataset.userModified = 'true';
          // Update baseDamage when user edits the damage field
          if (input.id.endsWith('-damage') && input.dataset.baseDamage !== undefined) {
            const wName = nameInput ? nameInput.value : '';
            input.dataset.baseDamage = window.WeaponData.extractBaseDamage(input.value, wName);
          }
        }
        this.scheduleAutoSave();
      });
    });
    
    this.scheduleAutoSave();
  },

  /**
   * Generate class ability inputs - dynamic list that only shows filled abilities
   */
  generateSpecialAbilities() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    container.innerHTML = '';
    
    // Setup add/remove buttons
    this.setupClassAbilityButtons();
    
    // Rows will be populated by populateForm if saved data exists
    // User can click + to add new abilities
  },
  
  /**
   * Setup add/remove buttons for class abilities
   */
  setupClassAbilityButtons() {
    const addBtn = document.getElementById('btn-add-ability');
    const removeBtn = document.getElementById('btn-remove-ability');
    
    if (addBtn) {
      addBtn.addEventListener('click', () => {
        this.addClassAbilityRow();
      });
    }
    
    if (removeBtn) {
      removeBtn.addEventListener('click', () => {
        this.removeLastClassAbilityRow();
      });
    }
  },
  
  /**
   * Add a new class ability row
   */
  addClassAbilityRow(abilityName = '', source = null) {
    const container = document.getElementById('class-abilities-list');
    if (!container) return null;
    
    const index = container.children.length;
    
    const row = document.createElement('div');
    row.className = 'class-ability-row';
    row.dataset.index = index;
    
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'class-ability-input';
    input.id = `ability-${index}`;
    input.placeholder = '';
    input.value = abilityName ? this.toTitleCase(abilityName) : '';
    input.dataset.previousValue = input.value;
    if (source) {
      input.dataset.classAbility = source;
    }
    
    const infoBtn = document.createElement('button');
    infoBtn.type = 'button';
    infoBtn.className = 'class-ability-info-btn';
    infoBtn.innerHTML = 'ℹ';
    infoBtn.title = 'Click for ability details';
    infoBtn.style.display = abilityName ? '' : 'none';
    
    // Handle ability changes
    input.addEventListener('blur', () => {
      this.handleAbilityChange(input);
      this.cleanupEmptyClassAbilityRows();
      this.syncClassAbilitiesToCharacter();
    });
    
    input.addEventListener('input', () => {
      infoBtn.style.display = input.value.trim() ? '' : 'none';
      this.syncClassAbilitiesToCharacter();
      this.scheduleAutoSave();
    });
    
    // Info button click handler
    infoBtn.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      const name = input.value.trim();
      if (name) {
        this.showAbilityDetail(name);
      }
    });
    
    row.appendChild(input);
    row.appendChild(infoBtn);
    container.appendChild(row);
    
    // Apply ability effect if applicable
    if (abilityName) {
      this.applyAbilityEffect(abilityName);
      
      // Check visibility for ability-specific UI sections
      const normalizedName = abilityName.toLowerCase().trim();
      if (normalizedName === 'berserk rage') {
        this.checkBerserkRageVisibility();
      } else if (normalizedName === 'forceful strike') {
        this.checkForcefulStrikeVisibility();
      } else if (normalizedName === 'brute strength') {
        this.checkBruteStrengthVisibility();
      } else if (normalizedName === 'just a scratch') {
        this.checkJustAScratchVisibility();
      } else if (normalizedName === 'commanding') {
        this.checkCommandingVisibility();
    this.checkHolyStrikeVisibility();
    this.checkLayOnHandsVisibility();
    this.checkDetectEvilVisibility();
    this.checkCureDiseaseVisibility();
    this.checkDivineProtectionVisibility();
    this.checkCircleOfPowerVisibility();
    this.checkImprovedAimVisibility();
    this.checkSpeciesEnemyVisibility();
      } else if (normalizedName.startsWith('mental strength')) {
        this.checkMentalStrengthVisibility();
      } else if (normalizedName === 'turn undead') {
        this.checkTurnUndeadVisibility();
      } else if (normalizedName.startsWith('animal companion')) {
        this.checkAnimalCompanionVisibility();
      } else if (normalizedName.startsWith('shape change')) {
        this.checkShapeChangeVisibility();
      } else if (normalizedName.startsWith('weapon specialization')) {
        this.checkWeaponSpecVisibility();
        // If it's the base name without a weapon chosen, prompt for selection
        // Don't prompt during initialization (loading saved data)
        if (normalizedName === 'weapon specialization' && !this.isInitializing) {
          setTimeout(() => {
            // Guard: ensure input is still in the DOM (not removed by rapid class change)
            if (input && input.isConnected) {
              // Check if character is a ranger — use ranger-specific prompt
              if (this.getCurrentClasses().includes('ranger')) {
                this.promptRangerWeaponSpecialization(input);
              } else {
                this.promptWeaponSpecialization(input);
              }
            }
          }, 150);
        }
      } else if (['weapon master', 'high master', 'grand master', 'legendary master'].includes(normalizedName)) {
        this.checkWeaponMasterProgression(abilityName);
      } else if (normalizedName === 'mystic healing') {
        this.checkMysticHealingVisibility();
      } else if (normalizedName === 'pain control') {
        this.checkPainControlVisibility();
      } else if (normalizedName === 'nether walk') {
        this.checkNertherWalkVisibility();
      } else if (normalizedName === 'quivering palm') {
        this.checkQuiveringPalmVisibility();
      } else if (normalizedName === 'perfection') {
        this.checkPerfectionVisibility();
      } else if (normalizedName.startsWith('speak with animals') && !this.isInitializing) {
        // If it's the base name without animal chosen, prompt for selection
        if (normalizedName === 'speak with animals') {
          setTimeout(() => {
            if (input && input.isConnected) {
              this.promptSpeakWithAnimals(input);
            }
          }, 150);
        }
      } else if (normalizedName.match(/^species enem(y|ies)\s*(i{1,3}|iv|v|\d)?$/i) && !this.isInitializing) {
        // Species Enemy without a parenthesized species — prompt for name
        if (!normalizedName.includes('(')) {
          setTimeout(() => {
            if (input && input.isConnected) {
              this.promptSpeciesEnemy(input);
            }
          }, 150);
        }
        this.checkSpeciesEnemyVisibility();
      }
    }
    
    this.scheduleAutoSave();
    return input;
  },
  
  /**
   * Remove last class ability row (warn if has content)
   */
  removeLastClassAbilityRow() {
    const container = document.getElementById('class-abilities-list');
    if (!container || container.children.length === 0) return;
    
    const rows = Array.from(container.children);
    const lastRow = rows[rows.length - 1];
    const input = lastRow.querySelector('.class-ability-input');
    const hasContent = input && input.value.trim();
    
    if (hasContent) {
      // Remove ability effect before deleting
      this.removeAbilityEffect(input.value);
      
      const confirmed = confirm(`Remove "${input.value.trim()}"?\n\nThis will delete this ability.`);
      if (!confirmed) return;
    }
    
    lastRow.remove();
    this.reindexClassAbilityRows();
    this.syncClassAbilitiesToCharacter();
    
    // Re-check weapon spec visibility in case a specialization was removed
    if (hasContent && input.value.toLowerCase().includes('weapon specialization')) {
      this.checkWeaponSpecVisibility();
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Clean up empty class ability rows (remove all empty rows)
   */
  cleanupEmptyClassAbilityRows() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    const rows = Array.from(container.children);
    
    // Remove all empty rows and sort spacers
    rows.forEach(row => {
      if (row.classList.contains('class-ability-sort-spacer')) {
        row.remove();
        return;
      }
      const input = row.querySelector('.class-ability-input');
      if (input && !input.value.trim()) {
        row.remove();
      }
    });
    
    this.reindexClassAbilityRows();
    this.syncClassAbilitiesToCharacter();
  },
  
  /**
   * Reindex class ability rows after removal
   */
  reindexClassAbilityRows() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    const rows = container.children;
    for (let i = 0; i < rows.length; i++) {
      rows[i].dataset.index = i;
      const input = rows[i].querySelector('.class-ability-input');
      if (input) {
        input.id = `ability-${i}`;
      }
    }
  },
  
  /**
   * Get all class abilities from dynamic list
   */
  getAllClassAbilities() {
    const abilities = [];
    const container = document.getElementById('class-abilities-list');
    if (!container) return abilities;
    
    const inputs = container.querySelectorAll('.class-ability-input');
    inputs.forEach(input => {
      if (input.value.trim()) {
        abilities.push({
          name: input.value.trim(),
          source: input.dataset.classAbility || null
        });
      }
    });
    return abilities;
  },
  
  /**
   * Handle ability input change - check duplicates, update tooltip, track removals
   */
  handleAbilityChange(input) {
    const value = input.value.trim();
    const previousValue = input.dataset.previousValue || '';
    
    // Get info button
    const wrapper = input.closest('.ability-input-wrapper');
    const infoBtn = wrapper ? wrapper.querySelector('.ability-info-btn') : null;
    
    if (!value) {
      // Ability was cleared - remove from tracking if it was previously tracked
      if (previousValue) {
        this.removeAbilityFromTracking(previousValue);
      }
      
      // Reset tooltip for empty input
      input.title = 'Enter a Special Ability name';
      input.classList.remove('duplicate-warning');
      input.dataset.previousValue = '';
      // Hide info button
      if (infoBtn) infoBtn.style.display = 'none';
      return;
    }
    
    // Convert to title case
    input.value = this.toTitleCase(value);
    
    // Store current value as previous for next change
    input.dataset.previousValue = input.value;
    
    // Special handling for Woodland Languages - show modal
    const normalizedValue = value.toLowerCase().trim().replace(/[']/g, "'");
    if (normalizedValue === 'woodland languages') {
      // Store the input for later reference when modal closes
      this._woodlandLanguagesInput = input;
      this.showWoodlandLanguagesModal();
      // Update tooltip
      this.updateAbilityTooltip(input);
      if (infoBtn) infoBtn.style.display = '';
      return;
    }

    // Special handling for Weapon Specialization - show selection modal
    // Only trigger if they typed the base name without a specific weapon
    if (normalizedValue === 'weapon specialization') {
      if (this.getCurrentClasses().includes('ranger')) {
        this.promptRangerWeaponSpecialization(input);
      } else {
        this.promptWeaponSpecialization(input);
      }
      return;
    }
    
    // Special handling for Species Enemy - prompt for species name
    if (normalizedValue.match(/^species enem(y|ies)\s*(i{1,3}|iv|v|\d)?$/) && !normalizedValue.includes('(')) {
      this.promptSpeciesEnemy(input);
      return;
    }
    
    // Check for duplicates
    const isDuplicate = this.checkAbilityDuplicate(input);
    
    if (isDuplicate) {
      input.classList.add('duplicate-warning');
    } else {
      input.classList.remove('duplicate-warning');
      // Apply ability effect if this is a new ability (not a duplicate)
      this.applyAbilityEffect(input.value);
    }
    
    // Update tooltip with ability description
    this.updateAbilityTooltip(input);
    
    // Show info button
    if (infoBtn) infoBtn.style.display = '';
  },

  /**
   * Remove an ability from tracking when deleted from the sheet
   */
  removeAbilityFromTracking(abilityName) {
    if (!abilityName) return;
    
    const baseName = abilityName.split('(')[0].trim().toLowerCase();
    const fullName = abilityName.toLowerCase().trim();
    
    // Remove from acquiredAbilities
    if (this.character.acquiredAbilities) {
      // For repeatable abilities (like Weapon Specialization), only remove the exact match
      const isRepeatable = window.isRepeatableAbility && window.isRepeatableAbility(abilityName);
      
      this.character.acquiredAbilities = this.character.acquiredAbilities.filter(name => {
        const trackFullName = name.toLowerCase().trim();
        if (isRepeatable) {
          // Exact match only for repeatable abilities
          return trackFullName !== fullName;
        }
        // Base name match for non-repeatable abilities
        const trackBaseName = name.split('(')[0].trim().toLowerCase();
        return trackBaseName !== baseName && trackFullName !== fullName;
      });
    }
    
    // Special handling for Characteristic Increase
    if (baseName === 'characteristic increase') {
      // Clear all characteristic increases (user deleted the ability)
      // Note: This doesn't reverse the stat increases - those remain
      this.character.characteristicIncreases = [];
    }

    // Special handling for Weapon Specialization - re-sync and update display
    if (baseName === 'weapon specialization') {
      this.checkWeaponSpecVisibility();
    }
    
    // Check for ability effects to remove
    this.removeAbilityEffect(abilityName);
    
    this.scheduleAutoSave();
  },

  /**
   * Check if an ability has a special effect and apply it
   */
  applyAbilityEffect(abilityName) {
    if (!abilityName) return;
    
    const baseName = abilityName.split('(')[0].trim().toLowerCase();
    const effect = this.ABILITY_EFFECTS[baseName];
    
    if (!effect) return;
    
    // Skip ENC-dependent abilities during initialization - handled by final setTimeout
    if (this.isInitializing && (baseName === 'artful dodger' || baseName === 'agile' || baseName === 'very agile')) {
      return;
    }
    
    // Check if effect is already active (no stacking)
    if (this.activeAbilityEffects[baseName]) {
      console.log(`Ability effect "${baseName}" already active, not stacking.`);
      return;
    }
    
    // Mark as active and apply
    this.activeAbilityEffects[baseName] = { active: true };
    effect.apply(this);
  },

  /**
   * Remove an ability's special effect
   */
  removeAbilityEffect(abilityName) {
    if (!abilityName) return;
    
    const baseName = abilityName.split('(')[0].trim().toLowerCase();
    const effect = this.ABILITY_EFFECTS[baseName];
    
    if (!effect) return;
    
    // Check if effect is active
    if (!this.activeAbilityEffects[baseName]) {
      return; // Effect wasn't active
    }
    
    // Check if the ability still exists elsewhere on the sheet (from another class)
    if (this.hasAbilityOnSheet(baseName)) {
      console.log(`Ability "${baseName}" still exists on sheet, keeping effect.`);
      return;
    }
    
    // Remove the effect
    effect.remove(this);
    delete this.activeAbilityEffects[baseName];
    console.log(`Removed ability effect: ${baseName}`);
  },

  /**
   * Check if an ability (by base name) still exists on the sheet (class or species)
   */
  hasAbilityOnSheet(baseName) {
    const normalizedBase = baseName.toLowerCase().trim();
    
    // Check class abilities
    const classContainer = document.getElementById('class-abilities-list');
    if (classContainer) {
      const inputs = classContainer.querySelectorAll('.class-ability-input');
      for (const input of inputs) {
        if (input.value.trim()) {
          const abilityBase = input.value.split('(')[0].trim().toLowerCase();
          if (abilityBase === normalizedBase) {
            return true;
          }
        }
      }
    }
    
    // Check species abilities
    const speciesAbilities = this.getSpeciesAbilities();
    for (const ability of speciesAbilities) {
      const abilityBase = ability.split('(')[0].trim().toLowerCase();
      if (abilityBase === normalizedBase) {
        return true;
      }
    }
    
    return false;
  },

  /**
   * Get damage modifier for a given STR+SIZ or STR+DEX sum
   */
  getDamageModifierForSum(sum) {
    const table = [
      { max: 5, mod: '-1d8' },
      { max: 10, mod: '-1d6' },
      { max: 15, mod: '-1d4' },
      { max: 20, mod: '-1d2' },
      { max: 25, mod: '+0' },
      { max: 30, mod: '+1d2' },
      { max: 35, mod: '+1d4' },
      { max: 40, mod: '+1d6' },
      { max: 45, mod: '+1d8' },
      { max: 50, mod: '+1d10' },
      { max: 60, mod: '+1d12' },
      { max: 70, mod: '+2d6' },
      { max: 80, mod: '+1d8+1d6' },
      { max: 90, mod: '+2d8' },
      { max: 100, mod: '+1d10+1d8' },
      { max: 110, mod: '+2d10' },
      { max: 120, mod: '+2d10+1d2' },
      { max: 130, mod: '+2d10+1d4' }
    ];
    
    // Handle values beyond the table
    if (sum > 130) {
      const extraTens = Math.floor((sum - 130) / 10);
      const diceProgression = ['+2d10+1d6', '+2d10+1d8', '+2d10+1d10', '+2d10+1d12', '+3d10'];
      const idx = Math.min(extraTens, diceProgression.length - 1);
      return diceProgression[idx];
    }
    
    for (const entry of table) {
      if (sum <= entry.max) {
        return entry.mod;
      }
    }
    return '+0';
  },

  /**
   * Compare two damage modifiers and return the better (higher) one
   */
  compareDamageModifiers(mod1, mod2) {
    // Convert damage modifiers to a numeric ranking for comparison
    const ranking = [
      '-1d8', '-1d6', '-1d4', '-1d2', '+0',
      '+1d2', '+1d4', '+1d6', '+1d8', '+1d10', '+1d12',
      '+2d6', '+1d8+1d6', '+2d8', '+1d10+1d8', '+2d10',
      '+2d10+1d2', '+2d10+1d4', '+2d10+1d6', '+2d10+1d8', '+2d10+1d10', '+2d10+1d12', '+3d10'
    ];
    
    const rank1 = ranking.indexOf(mod1);
    const rank2 = ranking.indexOf(mod2);
    
    // If not found in ranking, assume it's high
    const effectiveRank1 = rank1 === -1 ? 100 : rank1;
    const effectiveRank2 = rank2 === -1 ? 100 : rank2;
    
    return effectiveRank1 >= effectiveRank2 ? mod1 : mod2;
  },

  /**
   * Restore ability effects on page load
   */
  restoreAbilityEffects() {
    // Check all class abilities on the sheet and apply their effects
    // Skip Artful Dodger and Agile during init - they're handled by the final setTimeout
    const classContainer = document.getElementById('class-abilities-list');
    if (classContainer) {
      const inputs = classContainer.querySelectorAll('.class-ability-input');
      inputs.forEach(input => {
        if (input.value.trim()) {
          const baseName = input.value.split('(')[0].trim().toLowerCase();
          // Skip ENC-dependent abilities during initialization
          if (this.isInitializing && (baseName === 'artful dodger' || baseName === 'agile' || baseName === 'very agile')) {
            return;
          }
          const effect = this.ABILITY_EFFECTS[baseName];
          if (effect && !this.activeAbilityEffects[baseName]) {
            this.activeAbilityEffects[baseName] = { active: true };
            effect.apply(this);
          }
        }
      });
    }
    
    // Also check species abilities (already applied in initSpeciesAbilities, but ensure coverage)
    const speciesAbilities = this.getSpeciesAbilities();
    speciesAbilities.forEach(ability => {
      const baseName = ability.split('(')[0].trim().toLowerCase();
      // Skip ENC-dependent abilities during initialization
      if (this.isInitializing && (baseName === 'artful dodger' || baseName === 'agile' || baseName === 'very agile')) {
        return;
      }
      const effect = this.ABILITY_EFFECTS[baseName];
      if (effect && !this.activeAbilityEffects[baseName]) {
        this.activeAbilityEffects[baseName] = { active: true };
        effect.apply(this);
      }
    });
  },

  /**
   * Handle rank decrease - remove abilities and characteristic increases for ranks above the new rank
   */
  handleRankDecrease(rankFieldId, previousRank, newRank) {
    // Determine which class this rank belongs to
    const classFieldId = rankFieldId.replace('rank-', 'class-');
    const className = document.getElementById(classFieldId)?.value?.trim().toLowerCase() || '';
    
    if (!className) return;
    
    // Remove characteristic increases for ranks above the new rank
    if (this.character.characteristicIncreases && this.character.characteristicIncreases.length > 0) {
      const removed = this.character.characteristicIncreases.filter(inc => inc.rank > newRank);
      this.character.characteristicIncreases = this.character.characteristicIncreases.filter(inc => inc.rank <= newRank);
      
      // If we removed any, update the display on the sheet
      if (removed.length > 0) {
        // Notify user about removed characteristic increases
        const removedList = removed.map(inc => `Rank ${inc.rank}: ${inc.char.toUpperCase()}`).join(', ');
        console.log(`Removed Characteristic Increases due to rank decrease: ${removedList}`);
        
        // Update or remove the Characteristic Increase ability on sheet
        if (this.character.characteristicIncreases.length > 0) {
          const displayName = this.buildCharacteristicIncreaseName();
          this.updateCharacteristicIncreaseOnSheet(displayName);
        } else {
          // Remove it entirely from the sheet
          this.removeAbilityFromSheet('Characteristic Increase');
        }
      }
    }
    
    // Note: For other abilities, we don't automatically remove them since
    // the user may have purchased them with EXP and should decide what to do.
    // The Unlock Abilities modal will show them as "Already Acquired" regardless.
  },

  /**
   * Remove an ability from the Class Abilities sheet
   */
  removeAbilityFromSheet(abilityBaseName) {
    const baseNameLower = abilityBaseName.toLowerCase();
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    const rows = Array.from(container.querySelectorAll('.class-ability-row'));
    for (const row of rows) {
      const input = row.querySelector('.class-ability-input');
      if (input && input.value.toLowerCase().startsWith(baseNameLower)) {
        row.remove();
        this.reindexClassAbilityRows();
        return;
      }
    }
  },
  
  /**
   * Check if ability is duplicated elsewhere
   * @returns {boolean} true if duplicate found
   */
  checkAbilityDuplicate(currentInput) {
    const currentValue = currentInput.value.trim().toLowerCase();
    if (!currentValue) return false;
    
    // Get base name for repeatable ability check
    const currentBaseName = currentValue.split('(')[0].trim();
    
    // Check all other ability inputs
    const container = document.getElementById('class-abilities-list');
    if (!container) return false;
    
    const inputs = container.querySelectorAll('.class-ability-input');
    for (const input of inputs) {
      if (input === currentInput) continue;
      
      const otherValue = input.value.trim().toLowerCase();
      if (otherValue === currentValue) {
        // Exact duplicate - show warning
        const keepDuplicate = confirm(
          `This ability "${currentInput.value}" already exists in another slot.\n\n` +
          `Do you want to keep this duplicate?\n\n` +
          `Click OK to keep, Cancel to clear this entry.`
        );
        
        if (!keepDuplicate) {
          const row = currentInput.closest('.class-ability-row');
          if (row) row.remove();
          this.reindexClassAbilityRows();
          this.scheduleAutoSave();
          return false;
        }
        return true;
      }
      // For repeatable abilities (like Weapon Specialization), different specializations are OK
      // Only warn if it's an exact duplicate, not just same base name
    }
    return false;
  },
  
  /**
   * Update tooltip with ability description
   */
  updateAbilityTooltip(input) {
    const value = input.value.trim();
    
    // Remove hover tooltip - we use click popup instead
    input.title = '';
    
    if (!value) {
      return;
    }
    
    // The click handler is set up in setupAbilityInputs
  },

  /**
   * Setup click handlers for ability inputs to show popup
   */
  setupAbilityInputClickHandlers() {
    // For class abilities, the click handlers are set up when rows are created
    // This function is kept for compatibility but doesn't need to iterate old columns
  },

  /**
   * Show ability detail popup
   */
  showAbilityDetail(abilityName) {
    if (!abilityName) return;
    
    // Get or create the popup overlay
    let overlay = document.getElementById('ability-detail-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'ability-detail-overlay';
      overlay.className = 'ability-detail-overlay';
      overlay.innerHTML = `
        <div class="ability-detail-popup">
          <div class="ability-detail-header">
            <h3 class="ability-detail-title"></h3>
            <button class="ability-detail-close">&times;</button>
          </div>
          <div class="ability-detail-body">
            <div class="ability-detail-description"></div>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);
      
      // Close handlers
      overlay.querySelector('.ability-detail-close').addEventListener('click', () => {
        this.closeAbilityDetail();
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          this.closeAbilityDetail();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && overlay.classList.contains('active')) {
          this.closeAbilityDetail();
        }
      });
    }
    
    // Get the description
    let description = 'No description available for this ability.';
    let source = '';
    
    if (window.AbilityDescriptions) {
      const desc = AbilityDescriptions.getDescription(abilityName);
      if (desc) {
        description = desc;
      }
    }
    
    // Replace dynamic placeholders in description
    description = this.replaceDynamicPlaceholders(description);
    
    // Check if it's a species ability
    const speciesName = document.getElementById('species')?.value || '';
    if (speciesName && window.SpeciesData) {
      if (SpeciesData.isSpeciesAbility(abilityName, speciesName)) {
        source = `Species Ability (${this.toTitleCase(speciesName)})`;
      }
    }
    
    // Check if it's a class ability
    if (!source) {
      const classes = this.getCurrentClasses();
      for (const cls of classes) {
        if (window.ClassAbilitiesData && ClassAbilitiesData[cls]) {
          const classAbilities = ClassAbilitiesData[cls].map(a => a.toLowerCase());
          if (classAbilities.includes(abilityName.toLowerCase().replace(/\s*\(.*\)/, '').trim())) {
            source = `Class Ability (${this.toTitleCase(cls)})`;
            break;
          }
        }
      }
    }
    
    // Get base name for title (capitalize properly)
    const displayName = this.toTitleCase(abilityName);
    
    // Format the description with HTML - convert bullet points to list
    let formattedContent = this.formatAbilityDescription(description);
    
    if (source) {
      formattedContent += `<p class="ability-source"><strong>Source:</strong> ${source}</p>`;
    }
    
    // Add a note about "See description" abilities
    if (description.toLowerCase().includes('see description')) {
      formattedContent += `<p class="ability-note"><em>Refer to the Classic Fantasy rulebook for complete details.</em></p>`;
    }
    
    // Update content
    overlay.querySelector('.ability-detail-title').textContent = displayName;
    overlay.querySelector('.ability-detail-description').innerHTML = formattedContent;
    
    // Populate Skirmishing dynamic values and roll button
    if (abilityName.toLowerCase().trim() === 'skirmishing') {
      this.populateSkirmishingDetail(overlay);
    }
    
    // Show overlay
    overlay.classList.add('active');
  },
  
  /**
   * Populate Skirmishing ability detail with dynamic skill values and roll button
   */
  populateSkirmishingDetail(overlay) {
    const combatSkillField = document.getElementById('combat-skill-1-percent');
    const athleticsField = document.getElementById('athletics-current');
    
    const combatPct = parseInt(combatSkillField?.value, 10) || 0;
    const athleticsPct = parseInt(athleticsField?.value, 10) || 0;
    
    // Fill in the skill value spans
    const combatSpan = overlay.querySelector('.skirmish-combat-skill');
    const athleticsSpan = overlay.querySelector('.skirmish-athletics-skill');
    if (combatSpan) combatSpan.textContent = `(${combatPct}%)`;
    if (athleticsSpan) athleticsSpan.textContent = `(${athleticsPct}%)`;
    
    // Determine effective skill (lower of the two)
    const effectivePct = Math.min(combatPct, athleticsPct);
    const limitedBy = effectivePct === athleticsPct ? 'Athletics' : 'Combat Skill';
    
    // Add roll button section
    const descEl = overlay.querySelector('.ability-detail-description');
    if (descEl) {
      const rollSection = document.createElement('div');
      rollSection.className = 'ability-callout skirmish-roll-section';
      rollSection.innerHTML = `
        <div class="skirmish-effective">
          <strong>Effective Skill:</strong> ${effectivePct}% <span class="skirmish-limited-by">(limited by ${limitedBy})</span>
        </div>
        <button class="ability-nav-btn skirmish-roll-btn" title="Roll d100 against ${effectivePct}%">
          🎲 Roll Skirmishing (${effectivePct}%)
        </button>
      `;
      descEl.appendChild(rollSection);
      
      // Wire up roll button
      rollSection.querySelector('.skirmish-roll-btn').addEventListener('click', () => {
        this.closeAbilityDetail();
        this.rollD100('Skirmishing', effectivePct);
      });
    }
  },
  
  /**
   * Format ability description - convert bullet points to HTML list
   */
  formatAbilityDescription(description) {
    // Check if description contains bullet points
    if (description.includes('\n•')) {
      // Split into intro and bullets
      const parts = description.split('\n•');
      const intro = parts[0].trim();
      const bullets = parts.slice(1).map(b => b.trim()).filter(b => b);
      
      let html = '';
      if (intro) {
        // Handle paragraph breaks in intro
        const introParagraphs = intro.split('\n\n').filter(p => p.trim());
        introParagraphs.forEach(p => {
          html += `<p class="ability-intro">${p.trim()}</p>`;
        });
      }
      if (bullets.length > 0) {
        html += '<ul class="ability-bullets">';
        bullets.forEach(bullet => {
          html += `<li>${bullet}</li>`;
        });
        html += '</ul>';
      }
      return html;
    }
    
    // Check for paragraph breaks (\n\n)
    if (description.includes('\n\n')) {
      const paragraphs = description.split('\n\n').filter(p => p.trim());
      return paragraphs.map(p => `<p class="ability-description-text">${p.trim()}</p>`).join('');
    }
    
    // No bullets or paragraph breaks - just return as paragraph
    return `<p class="ability-description-text">${description}</p>`;
  },

  /**
   * Close ability detail popup
   */
  closeAbilityDetail() {
    const overlay = document.getElementById('ability-detail-overlay');
    if (overlay) {
      overlay.classList.remove('active');
    }
  },

  /**
   * Replace dynamic placeholders in ability descriptions with calculated values
   */
  replaceDynamicPlaceholders(description) {
    // Replace {INFLUENCE_10TH} with 1/10th of Influence, rounded up
    if (description.includes('{INFLUENCE_10TH}')) {
      const influenceValue = this.getSkillValueByName('Influence') || 0;
      const influence10th = Math.ceil(influenceValue / 10);
      description = description.replace('{INFLUENCE_10TH}', influence10th);
    }
    
    // Add more placeholder replacements here as needed
    
    return description;
  },

  /**
   * Attribute descriptions data for info modals
   */
  ATTRIBUTE_INFO: {
    'action-points': {
      title: 'Action Points',
      content: `
        <p>Action Points determine how often a character can act during a Combat Round. Starting characters begin with 2 Action Points but gain more as they advance in Rank.</p>
        <table class="attr-info-table">
          <thead><tr><th>Combined Rank</th><th>Action Points</th></tr></thead>
          <tbody>
            <tr><td>0–1</td><td>2</td></tr>
            <tr><td>2–3</td><td>3</td></tr>
            <tr><td>4–5</td><td>4</td></tr>
          </tbody>
        </table>
      `
    },
    'damage-mod': {
      title: 'Damage Modifier',
      content: `
        <p>The Damage Modifier reflects the bonus (or penalty) applied to damage from physical strikes or force. This modifier is used in combat and when attempting to break objects—an extra die roll added to or subtracted from weapon or tool damage.</p>
        <p>If a negative modifier reduces damage to zero or less, no damage is inflicted.</p>
        <p>Add together STR and SIZ, then consult the table below. <em>Note: some Class Abilities allow for STR+SIZ+DEX, but still refer to this table.</em></p>
        <table class="attr-info-table">
          <thead><tr><th>STR+SIZ</th><th>Damage Mod</th></tr></thead>
          <tbody>
            <tr><td>5 or less</td><td>−1d8</td></tr>
            <tr><td>6–10</td><td>−1d6</td></tr>
            <tr><td>11–15</td><td>−1d4</td></tr>
            <tr><td>16–20</td><td>−1d2</td></tr>
            <tr><td>21–25</td><td>+0</td></tr>
            <tr><td>26–30</td><td>+1d2</td></tr>
            <tr><td>31–35</td><td>+1d4</td></tr>
            <tr><td>36–40</td><td>+1d6</td></tr>
            <tr><td>41–45</td><td>+1d8</td></tr>
            <tr><td>46–50</td><td>+1d10</td></tr>
            <tr><td>51–60</td><td>+1d12</td></tr>
            <tr><td>61–70</td><td>+2d6</td></tr>
            <tr><td>71–80</td><td>+1d8+1d6</td></tr>
            <tr><td>81–90</td><td>+2d8</td></tr>
            <tr><td>91–100</td><td>+1d10+1d8</td></tr>
            <tr><td>101–110</td><td>+2d10</td></tr>
            <tr><td>111–120</td><td>+2d10+1d2</td></tr>
            <tr><td>121–130</td><td>+2d10+1d4</td></tr>
            <tr><td>Each +10</td><td>Continue progression</td></tr>
          </tbody>
        </table>
      `
    },
    'precision-dmg': {
      title: 'Weapon Precision Damage Modifier',
      content: `
        <p>Weapon Precision replaces STR with DEX for Damage Modifier calculations with finesse weapons.</p>
        <p><strong>Applies to:</strong> clubs, daggers, garrotes, knives, shortswords, main gauche, rapiers, unarmed, darts, slings, short bows, and javelins.</p>
        <p>Uses DEX+SIZ instead of STR+SIZ for the Damage Modifier table.</p>
      `
    },
    'graceful-dmg': {
      title: 'Graceful Strike Damage Modifier',
      content: `
        <p>Graceful Strike uses DEX+POW instead of STR+SIZ for the Damage Modifier when making Unarmed attacks.</p>
        <p><strong>Applies to:</strong> Unarmed attacks only.</p>
        <p><strong>Conditions:</strong> Monk must be Extremely Unburdened and wearing no armor, and DEX+POW must be higher than STR+SIZ.</p>
        <p>The highest available Damage Modifier is always used (comparing normal DM, Weapon Precision DM, and Graceful Strike DM).</p>
      `
    },
    'exp-mod': {
      title: 'Experience Modifier',
      content: `
        <p>Characters grow and improve through Experience Rolls. A character's CHA score represents their reputation and ability to build relationships.</p>
        <ul>
          <li><strong>High CHA:</strong> Makes it easier to find support and training.</li>
          <li><strong>Low CHA:</strong> Can create challenges, such as difficulty finding a sparring partner.</li>
        </ul>
        <table class="attr-info-table">
          <thead><tr><th>CHA</th><th>Exp. Modifier</th></tr></thead>
          <tbody>
            <tr><td>6 or less</td><td>−1</td></tr>
            <tr><td>7–12</td><td>+0</td></tr>
            <tr><td>13–18</td><td>+1</td></tr>
            <tr><td>Each +6</td><td>+1</td></tr>
          </tbody>
        </table>
      `
    },
    'healing-rate': {
      title: 'Healing Rate',
      content: `
        <p>Healing Rate determines how quickly a character recovers naturally from injuries. Depending on the severity of the injury (see the Combat/Abilities page), it specifies the number of Hit Points the character regains each day, week, or month.</p>
        <table class="attr-info-table">
          <thead><tr><th>CON</th><th>Healing Rate</th></tr></thead>
          <tbody>
            <tr><td>6 or less</td><td>1</td></tr>
            <tr><td>7–12</td><td>2</td></tr>
            <tr><td>13–18</td><td>3</td></tr>
            <tr><td>Each +6</td><td>+1</td></tr>
          </tbody>
        </table>
      `
    },
    'initiative': {
      title: 'Initiative Modifier',
      content: `
        <p>The Initiative Modifier determines how quickly a character reacts in combat and influences when they can act in comparison to others.</p>
        <p><strong>Formula:</strong> (DEX + INT) ÷ 2, rounded up.</p>
      `
    },
    'luck-points': {
      title: 'Luck Points',
      content: `
        <p>Luck Points represent that extraordinary force that sets adventurers apart. Call it fate, karma, or sheer good fortune. Players can spend Luck Points to:</p>
        <ul>
          <li>Re-roll unfavorable dice results</li>
          <li>Mitigate damage or misfortune</li>
          <li>Gain a crucial edge in combat</li>
        </ul>
        <p>Once spent, Luck Points reduce the character's pool and cannot be replenished until the next session (using the <strong>New Game</strong> button at the top of this page), unless awarded by the Games Master.</p>
        <table class="attr-info-table">
          <thead><tr><th>POW</th><th>Luck Points</th></tr></thead>
          <tbody>
            <tr><td>6 or less</td><td>1</td></tr>
            <tr><td>7–12</td><td>2</td></tr>
            <tr><td>13–18</td><td>3</td></tr>
            <tr><td>Each +6</td><td>+1</td></tr>
          </tbody>
        </table>
        <p><em>Note: Humans receive +1 bonus Luck Point.</em></p>
      `
    },
    'magic-points': {
      title: 'Magic Points',
      content: `
        <p>Magic Points fuel spellcasting in Classic Fantasy. While some campaigns or professions may not require this Attribute, all casters rely on it for spellcasting.</p>
        <ul>
          <li><strong>Magic Points:</strong> Equal to the character's POW.</li>
          <li><strong>Usage:</strong> Points are spent based on spell type and replenished after depletion.</li>
          <li><strong>Exhaustion:</strong> A caster at 0 MP may still cast, but each MP of deficit causes one Level of Fatigue.</li>
        </ul>
      `
    },
    'movement-rate': {
      title: 'Movement Rate',
      content: `
        <p>Every creature has a Movement Rate that indicates how far they can travel in a given period. This value is species-specific and isn't derived from Characteristics.</p>
        <p>Certain skills and Class Abilities can improve Movement Rate. Even running, sprinting, swimming and more can affect the Movement Rate. See the section on Movement (the Combat/Abilities page) for details.</p>
        <table class="attr-info-table">
          <thead><tr><th>Species</th><th>Move (ft)</th><th>Squares</th></tr></thead>
          <tbody>
            <tr><td>Abyssar</td><td>20</td><td>4</td></tr>
            <tr><td>Bruxx</td><td>25</td><td>5</td></tr>
            <tr><td>Dwarf</td><td>15</td><td>3</td></tr>
            <tr><td>Elf</td><td>20</td><td>4</td></tr>
            <tr><td>Gnome</td><td>15</td><td>3</td></tr>
            <tr><td>Half-Elf</td><td>20</td><td>4</td></tr>
            <tr><td>Half-Orc</td><td>20</td><td>4</td></tr>
            <tr><td>Halfling</td><td>15</td><td>3</td></tr>
            <tr><td>Human</td><td>20</td><td>4</td></tr>
            <tr><td>Khelmar</td><td>15</td><td>3</td></tr>
            <tr><td>Syrin</td><td>20</td><td>4</td></tr>
            <tr><td>Vulpan</td><td>15</td><td>3</td></tr>
          </tbody>
        </table>
      `
    },
    'tenacity': {
      title: 'Tenacity Points',
      content: `
        <p>Tenacity Points represent a character's mental stamina—like psychological Hit Points. They take damage the same way physical Hit Points do and can drop when a character goes through mental or emotional trauma.</p>
        <p>A character's Tenacity Points start equal to their <strong>POW</strong> score, which reflects their mental strength.</p>
        <p>As Tenacity Points drop, the character becomes more likely to suffer certain Conditions. If their Tenacity Points fall below zero, any Conditions caused by traumatic, horrifying, or sanity-breaking events become <strong>permanent</strong>.</p>
        <p>If their Tenacity Points reach a negative number equal to their starting value, the character is permanently insane or mentally broken and cannot recover.</p>
      `
    }
  },

  /**
   * Setup click handlers for attribute info buttons
   */
  setupAttributeInfoButtons() {
    const buttons = document.querySelectorAll('.attr-info-btn');
    buttons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const attrKey = btn.dataset.attr;
        if (attrKey) {
          this.showAttributeInfo(attrKey);
        }
      });
    });
  },

  /**
   * Show attribute info modal
   */
  showAttributeInfo(attrKey) {
    // Accept either a string key (lookup in ATTRIBUTE_INFO) or an object with title/content
    let info;
    if (typeof attrKey === 'object' && attrKey._skillInfoOverride) {
      info = attrKey;
    } else {
      info = this.ATTRIBUTE_INFO[attrKey];
    }
    if (!info) return;

    // Get or create the popup overlay (reuse ability detail structure)
    let overlay = document.getElementById('attr-info-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'attr-info-overlay';
      overlay.className = 'ability-detail-overlay';
      overlay.innerHTML = `
        <div class="ability-detail-popup attr-info-popup">
          <div class="ability-detail-header">
            <h3 class="ability-detail-title"></h3>
            <button class="ability-detail-close">&times;</button>
          </div>
          <div class="ability-detail-body">
            <div class="ability-detail-description"></div>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);

      // Close handlers
      overlay.querySelector('.ability-detail-close').addEventListener('click', () => {
        this.closeAttributeInfo();
      });

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          this.closeAttributeInfo();
        }
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && overlay.classList.contains('active')) {
          this.closeAttributeInfo();
        }
      });
    }

    // Update content
    overlay.querySelector('.ability-detail-title').textContent = info.title;
    overlay.querySelector('.ability-detail-description').innerHTML = info.content;

    // Show
    overlay.classList.add('active');
  },

  /**
   * Close attribute info modal
   */
  closeAttributeInfo() {
    const overlay = document.getElementById('attr-info-overlay');
    if (overlay) {
      overlay.classList.remove('active');
    }
  },

  /**
   * Update all ability tooltips and info buttons (called on load)
   */
  updateAllAbilityTooltips() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    const inputs = container.querySelectorAll('.class-ability-input');
    inputs.forEach(input => {
      const hasValue = input.value.trim();
      
      // Set previousValue for tracking (used when abilities are deleted)
      input.dataset.previousValue = hasValue || '';
      
      // Update tooltip (removes hover, we use click popup instead)
      this.updateAbilityTooltip(input);
      
      // Show/hide info button
      const infoBtn = input.parentElement?.querySelector('.class-ability-info-btn');
      if (infoBtn) {
        infoBtn.style.display = hasValue ? '' : 'none';
      }
    });
    
    // Setup click handlers for popups
    this.setupAbilityInputClickHandlers();
  },

  /**
   * Abilities where higher tiers replace lower ones in the Class Abilities list.
   * When "Defensive Reflexes II" is gained, "Defensive Reflexes I" is removed.
   * Abilities NOT in this list (like Extra Rage) stack and are all kept.
   */
  SUPERSEDING_ABILITY_BASES: [
    'defensive reflexes',
    'inspire courage',
    'mental strength'
  ],

  /**
   * Parse a tiered ability name into base name and tier number.
   * Handles Roman (I–V) and Arabic (1–5) numerals at the end.
   * @returns {{ base: string, tier: number } | null}
   */
  parseTieredAbility(name) {
    const normalized = name.toLowerCase().trim();
    const romanMatch = normalized.match(/^(.+?)\s+(i{1,3}|iv|v)$/);
    if (romanMatch) {
      const romanMap = { 'i': 1, 'ii': 2, 'iii': 3, 'iv': 4, 'v': 5 };
      const tier = romanMap[romanMatch[2]];
      if (tier) return { base: romanMatch[1].trim(), tier };
    }
    const arabicMatch = normalized.match(/^(.+?)\s+(\d+)$/);
    if (arabicMatch) {
      const tier = parseInt(arabicMatch[2], 10);
      if (tier > 0 && tier <= 10) return { base: arabicMatch[1].trim(), tier };
    }
    return null;
  },

  /**
   * Remove a lower-tier ability from the sheet when a higher-tier version is purchased.
   * Only applies to abilities in SUPERSEDING_ABILITY_BASES (e.g. Defensive Reflexes).
   * Called from finalizeAbilityUnlock only — never during init/refresh.
   */
  removeSupersededAbility(newAbilityName) {
    const parsed = this.parseTieredAbility(newAbilityName);
    if (!parsed) return;
    if (!this.SUPERSEDING_ABILITY_BASES.includes(parsed.base)) return;
    if (parsed.tier <= 1) return; // Tier 1 has nothing to replace

    const container = document.getElementById('class-abilities-list');
    if (!container) return;

    const normalizeApostrophes = (str) => str.replace(/[']/g, "'");
    const rows = Array.from(container.querySelectorAll('.class-ability-row'));
    let removed = false;

    for (const row of rows) {
      const input = row.querySelector('.class-ability-input');
      if (!input || !input.value.trim()) continue;

      const existingParsed = this.parseTieredAbility(normalizeApostrophes(input.value.trim()));
      if (!existingParsed) continue;

      // Same base but lower tier → remove it
      if (existingParsed.base === parsed.base && existingParsed.tier < parsed.tier) {
        const oldName = input.value.trim();
        console.log(`Superseding "${oldName}" with "${newAbilityName}"`);

        // Remove ability effect if active
        this.removeAbilityEffect(oldName);
        row.remove();
        removed = true;

        // Remove from acquiredAbilities tracking
        if (this.character.acquiredAbilities) {
          this.character.acquiredAbilities = this.character.acquiredAbilities.filter(a =>
            a.toLowerCase().trim() !== oldName.toLowerCase().trim()
          );
        }
      }
    }

    if (removed) {
      this.reindexClassAbilityRows();
    }
  },

  /**
   * Add an ability to the Special Abilities section (first empty slot)
   * @param {string} abilityName - Name of the ability to add
   * @returns {boolean} - True if successfully added
   */
  addAbilityToSheet(abilityName) {
    const container = document.getElementById('class-abilities-list');
    if (!container) {
      console.warn('addAbilityToSheet: container not found');
      return false;
    }
    
    if (!abilityName || !abilityName.trim()) {
      console.warn('addAbilityToSheet: empty ability name');
      return false;
    }
    
    // Normalize apostrophes for comparison
    const normalizeApostrophes = (str) => str.replace(/[']/g, "'");
    const normalizedName = normalizeApostrophes(abilityName.toLowerCase().trim());
    
    // Handle Mental Strength upgrades - remove lower versions when higher is added
    if (normalizedName.startsWith('mental strength')) {
      this.handleMentalStrengthUpgrade(abilityName);
    }
    
    // Handle Greater Overrun - removes Overrun when gained
    if (normalizedName === 'greater overrun') {
      this.removeAbilityFromSheet('Overrun');
    }
    
    // Handle Greater Sweeping Strike - removes Sweeping Strike when gained
    if (normalizedName === 'greater sweeping strike') {
      this.removeAbilityFromSheet('Sweeping Strike');
    }
    
    // Handle Holy Smite upgrades - remove previous tier when upgrading
    if (normalizedName === 'improved holy smite') {
      this.removeAbilityFromSheet('Holy Smite');
    }
    if (normalizedName === 'greater holy smite') {
      this.removeAbilityFromSheet('Improved Holy Smite');
      this.removeAbilityFromSheet('Holy Smite'); // In case they skipped a tier
    }
    
    // Handle Woodland Languages - show modal to select language
    if (normalizedName === 'woodland languages') {
      this.showWoodlandLanguagesModal();
      return true; // The modal will handle adding the ability if needed
    }
    
    // Handle Animal Companion abilities - show modal to select companion
    if (normalizedName.startsWith('animal companion')) {
      // Determine the tier from the ability name
      let tier = 1;
      if (normalizedName.includes('v') || normalizedName.includes('5')) tier = 5;
      else if (normalizedName.includes('iv') || normalizedName.includes('4')) tier = 4;
      else if (normalizedName.includes('iii') || normalizedName.includes('3')) tier = 3;
      else if (normalizedName.includes('ii') || normalizedName.includes('2')) tier = 2;
      
      // Show the modal to select a companion
      this.showAnimalCompanionModal(tier);
      return true; // The modal will handle adding the ability if needed
    }
    
    // Check if ability already exists
    const existingInputs = container.querySelectorAll('.class-ability-input');
    for (const input of existingInputs) {
      if (input.value.trim()) {
        const normalizedExisting = normalizeApostrophes(input.value.trim().toLowerCase());
        if (normalizedExisting === normalizedName) {
          console.log('addAbilityToSheet: ability already exists:', abilityName);
          return true; // Already exists, that's fine
        }
      }
    }
    
    // Find first empty slot
    for (const input of existingInputs) {
      if (!input.value.trim()) {
        // Found empty slot - fill it
        input.value = this.toTitleCase(abilityName);
        input.dataset.previousValue = input.value;
        this.updateAbilityTooltip(input);
        
        // Show the info button
        const infoBtn = input.parentElement?.querySelector('.class-ability-info-btn');
        if (infoBtn) {
          infoBtn.style.display = '';
        }
        
        // Apply ability effect if applicable
        this.applyAbilityEffect(abilityName);
        
        console.log('addAbilityToSheet: filled existing empty slot with:', abilityName);
        
        // Check if Berserk Rage section should now be visible
        if (normalizedName === 'berserk rage') {
          this.checkBerserkRageVisibility();
        }
        
        // Check if Forceful Strike section should now be visible
        if (normalizedName === 'forceful strike') {
          this.checkForcefulStrikeVisibility();
        }
        
        // Check if Brute Strength section should now be visible
        if (normalizedName === 'brute strength') {
          this.checkBruteStrengthVisibility();
        }
        
        // Check if Just a Scratch section should now be visible
        if (normalizedName === 'just a scratch') {
          this.checkJustAScratchVisibility();
        }
        
        // Check if Mystic Healing section should now be visible
        if (normalizedName === 'mystic healing') {
          this.checkMysticHealingVisibility();
        }
        
        // Check if Pain Control section should now be visible
        if (normalizedName === 'pain control') {
          this.checkPainControlVisibility();
        }
        
        // Check if Nether Walk section should now be visible
        if (normalizedName === 'nether walk') {
          this.checkNertherWalkVisibility();
        }
        
        // Check if Quivering Palm section should now be visible
        if (normalizedName === 'quivering palm') {
          this.checkQuiveringPalmVisibility();
        }
        
        // Check if Perfection section should now be visible
        if (normalizedName === 'perfection') {
          this.checkPerfectionVisibility();
        }
        
        // Check if Commanding section should now be visible
        if (normalizedName === 'commanding') {
          this.checkCommandingVisibility();
        }
        
        // Check paladin ability sections
        if (normalizedName === 'holy strike') this.checkHolyStrikeVisibility();
        if (normalizedName === 'lay on hands') this.checkLayOnHandsVisibility();
        if (normalizedName === 'detect evil') this.checkDetectEvilVisibility();
        if (normalizedName === 'cure disease') this.checkCureDiseaseVisibility();
        if (normalizedName === 'divine protection') this.checkDivineProtectionVisibility();
    this.checkCircleOfPowerVisibility();
    this.checkImprovedAimVisibility();
    this.checkSpeciesEnemyVisibility();
        
        // Check if Turn Undead section should now be visible
        if (normalizedName === 'turn undead') {
          this.checkTurnUndeadVisibility();
        }
        
        // Check if Animal Companion section should now be visible
        if (normalizedName.startsWith('animal companion')) {
          this.checkAnimalCompanionVisibility();
        }
        
        // Check if Shape Change section should now be visible
        if (normalizedName.startsWith('shape change')) {
          this.checkShapeChangeVisibility();
        }
        
        // Weapon Specialization: prompt for weapon choice
        if (normalizedName === 'weapon specialization') {
          setTimeout(() => {
            if (input && input.isConnected) {
              if (this.getCurrentClasses().includes('ranger')) {
                this.promptRangerWeaponSpecialization(input);
              } else {
                this.promptWeaponSpecialization(input);
              }
            }
          }, 100);
        }
        
        // Species Enemy: prompt for species name
        if (normalizedName.match(/^species enem(y|ies)\s*(i{1,3}|iv|v|\d)?$/) && !normalizedName.includes('(')) {
          setTimeout(() => {
            if (input && input.isConnected) this.promptSpeciesEnemy(input);
          }, 100);
        }
        
        this.scheduleAutoSave();
        return true;
      }
    }
    
    // No empty slot found - create new row with the ability
    console.log('addAbilityToSheet: creating new row for:', abilityName);
    const newInput = this.addClassAbilityRow(abilityName);
    
    // Check if Berserk Rage section should now be visible
    if (normalizedName === 'berserk rage') {
      this.checkBerserkRageVisibility();
    }
    
    // Check if Forceful Strike section should now be visible
    if (normalizedName === 'forceful strike') {
      this.checkForcefulStrikeVisibility();
    }
    
    // Check if Brute Strength section should now be visible
    if (normalizedName === 'brute strength') {
      this.checkBruteStrengthVisibility();
    }
    
    // Check if Just a Scratch section should now be visible
    if (normalizedName === 'just a scratch') {
      this.checkJustAScratchVisibility();
    }
    
    // Check if Commanding section should now be visible
    if (normalizedName === 'commanding') {
      this.checkCommandingVisibility();
    }
    
    // Check paladin ability sections
    if (normalizedName === 'holy strike') this.checkHolyStrikeVisibility();
    if (normalizedName === 'lay on hands') this.checkLayOnHandsVisibility();
    if (normalizedName === 'detect evil') this.checkDetectEvilVisibility();
    if (normalizedName === 'cure disease') this.checkCureDiseaseVisibility();
    if (normalizedName === 'divine protection') this.checkDivineProtectionVisibility();
    this.checkCircleOfPowerVisibility();
    this.checkImprovedAimVisibility();
    this.checkSpeciesEnemyVisibility();
    
    // Check if Turn Undead section should now be visible
    if (normalizedName === 'turn undead') {
      this.checkTurnUndeadVisibility();
    }
    
    // Check if Animal Companion section should now be visible
    if (normalizedName.startsWith('animal companion')) {
      this.checkAnimalCompanionVisibility();
    }
    
    // Check if Shape Change section should now be visible
    if (normalizedName.startsWith('shape change')) {
      this.checkShapeChangeVisibility();
    }
    
    // Weapon Specialization: prompt for weapon choice
    if (normalizedName === 'weapon specialization' && newInput) {
      setTimeout(() => {
        if (newInput.isConnected) {
          if (this.getCurrentClasses().includes('ranger')) {
            this.promptRangerWeaponSpecialization(newInput);
          } else {
            this.promptWeaponSpecialization(newInput);
          }
        }
      }, 100);
    }
    
    // Species Enemy: prompt for species name
    if (normalizedName.match(/^species enem(y|ies)\s*(i{1,3}|iv|v|\d)?$/) && !normalizedName.includes('(') && newInput) {
      setTimeout(() => {
        if (newInput.isConnected) this.promptSpeciesEnemy(newInput);
      }, 100);
    }
    
    return !!newInput;
  },

  /**
   * Sort special abilities alphabetically
   */
  sortSpecialAbilities() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    // Collect all non-empty abilities
    const inputs = Array.from(container.querySelectorAll('.class-ability-input'));
    const abilities = [];
    
    inputs.forEach(input => {
      if (input.value.trim()) {
        abilities.push({
          value: input.value.trim(),
          classAbility: input.dataset.classAbility || ''
        });
      }
    });
    
    if (abilities.length === 0) return;
    
    // Sort alphabetically
    abilities.sort((a, b) => a.value.toLowerCase().localeCompare(b.value.toLowerCase()));
    
    // Calculate column-major layout for 3-column CSS grid
    // We want: col1 reads down, col2 reads down, col3 reads down
    // But CSS grid fills row-by-row, so we interleave
    const numCols = 3;
    const itemsPerCol = Math.ceil(abilities.length / numCols);
    
    // Split into columns
    const columns = [
      abilities.slice(0, itemsPerCol),
      abilities.slice(itemsPerCol, itemsPerCol * 2),
      abilities.slice(itemsPerCol * 2)
    ];
    
    // Interleave: row0 = col1[0], col2[0], col3[0]; row1 = col1[1], col2[1], col3[1]; etc.
    // Include null for empty grid slots to maintain alignment
    const interleaved = [];
    for (let row = 0; row < itemsPerCol; row++) {
      for (let col = 0; col < numCols; col++) {
        if (columns[col] && columns[col][row]) {
          interleaved.push(columns[col][row]);
        } else {
          interleaved.push(null); // Empty grid slot placeholder
        }
      }
    }
    
    // Clear container and rebuild
    container.innerHTML = '';
    interleaved.forEach((item) => {
      if (item) {
        const input = this.addClassAbilityRow(item.value, item.classAbility || null);
        if (input) {
          input.dataset.previousValue = item.value;
        }
      } else {
        // Add invisible spacer div for grid alignment (no class-ability-row to avoid cleanup)
        const spacer = document.createElement('div');
        spacer.className = 'class-ability-sort-spacer';
        container.appendChild(spacer);
      }
    });
    
    // Update tooltips after sorting
    this.updateAllAbilityTooltips();
    
    // Update character data to match the sorted DOM
    this.syncClassAbilitiesToCharacter();
    
    // Check Just a Scratch visibility
    this.checkJustAScratchVisibility();
    this.checkMysticHealingVisibility();
    this.checkPainControlVisibility();
    this.checkNertherWalkVisibility();
    this.checkQuiveringPalmVisibility();
    this.checkPerfectionVisibility();
    
    this.scheduleAutoSave();
  },
  
  /**
   * Sync class abilities from DOM to character data
   * Called when abilities are added, edited, or sorted
   */
  syncClassAbilitiesToCharacter() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    this.character.combat.specialAbilities = [];
    const inputs = container.querySelectorAll('.class-ability-input');
    inputs.forEach(input => {
      if (input.value.trim()) {
        this.character.combat.specialAbilities.push({
          name: input.value.trim(),
          source: input.dataset.classAbility || null
        });
      }
    });
  },

  /**
   * Generate spell rows for all ranks - starts empty, rows added dynamically
   */
  generateSpellRows() {
    const ranks = ['cantrips', 'rank1', 'rank2', 'rank3', 'rank4', 'rank5'];
    
    ranks.forEach(rank => {
      const tbody = document.getElementById(`${rank}-body`);
      if (!tbody) return;
      tbody.innerHTML = '';
      
      // Max memorized input listener
      const maxInput = document.getElementById(`${rank}-max`);
      if (maxInput) {
        maxInput.addEventListener('input', () => this.scheduleAutoSave());
      }
    });
  },
  
  /**
   * Rank labels for display
   */
  spellRankLabels: {
    'cantrips': 'Cantrip',
    'rank1': 'Rank 1',
    'rank2': 'Rank 2',
    'rank3': 'Rank 3',
    'rank4': 'Rank 4',
    'rank5': 'Rank 5'
  },
  
  /**
   * Update the Magic Points display bars on spell pages
   * Syncs from the main magic-points-current and magic-points-original fields
   */
  updateMagicMPDisplay() {
    const mpCurrent = parseInt(document.getElementById('magic-points-current')?.value, 10) || 0;
    const mpMax = parseInt(document.getElementById('magic-points-original')?.value, 10) || 0;
    
    ['1', '2'].forEach(pageNum => {
      const currentEl = document.getElementById(`magic-mp-display-${pageNum}`);
      const maxEl = document.getElementById(`magic-mp-max-display-${pageNum}`);
      const bar = currentEl?.closest('.magic-mp-bar');
      
      if (currentEl && parseInt(currentEl.value, 10) !== mpCurrent) {
        currentEl.value = mpCurrent;
      }
      if (maxEl) maxEl.textContent = mpMax;
      
      // Setup listener once
      if (currentEl && !currentEl.dataset.syncAdded) {
        currentEl.dataset.syncAdded = 'true';
        currentEl.addEventListener('input', (e) => {
          // Enforce max
          const max = parseInt(document.getElementById('magic-points-original')?.value, 10) || 0;
          let val = parseInt(e.target.value, 10);
          if (!isNaN(val) && val > max) {
            val = max;
            e.target.value = val;
          }
          if (val < 0) {
            val = 0;
            e.target.value = val;
          }
          
          // Sync to main field
          const mainField = document.getElementById('magic-points-current');
          if (mainField) {
            mainField.value = e.target.value;
            this.character.derived = this.character.derived || {};
            this.character.derived.magicPointsCurrent = e.target.value;
          }
          
          // Sync to other magic page display
          const otherId = pageNum === '1' ? 'magic-mp-display-2' : 'magic-mp-display-1';
          const otherEl = document.getElementById(otherId);
          if (otherEl) otherEl.value = e.target.value;
          
          // Update bar styling
          this._updateMPBarStyling();
          this.scheduleAutoSave();
        });
      }
      
      if (bar) {
        bar.classList.remove('mp-low', 'mp-empty');
        if (mpCurrent <= 0) {
          bar.classList.add('mp-empty');
        } else if (mpMax > 0 && mpCurrent <= Math.floor(mpMax * 0.25)) {
          bar.classList.add('mp-low');
        }
      }
    });
  },
  
  /**
   * Update MP bar color styling on both pages
   */
  _updateMPBarStyling() {
    const mpCurrent = parseInt(document.getElementById('magic-points-current')?.value, 10) || 0;
    const mpMax = parseInt(document.getElementById('magic-points-original')?.value, 10) || 0;
    
    ['1', '2'].forEach(pageNum => {
      const currentEl = document.getElementById(`magic-mp-display-${pageNum}`);
      const bar = currentEl?.closest('.magic-mp-bar');
      if (bar) {
        bar.classList.remove('mp-low', 'mp-empty');
        if (mpCurrent <= 0) {
          bar.classList.add('mp-empty');
        } else if (mpMax > 0 && mpCurrent <= Math.floor(mpMax * 0.25)) {
          bar.classList.add('mp-low');
        }
      }
    });
  },
  
  /**
   * Add a single spell row to a rank
   * @param {string} rankKey - The rank key (cantrips, rank1, etc.)
   * @param {Object} data - Optional spell data {name, cost, memorized, classSpell}
   * @returns {HTMLElement} The created row element
   */
  addSpellRow(rankKey, data = null) {
    const tbody = document.getElementById(`${rankKey}-body`);
    if (!tbody) return null;
    
    const index = tbody.rows.length;
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td><input type="checkbox" id="${rankKey}-${index}-mem" class="spell-memorized"></td>
      <td class="spell-name-cell">
        <input type="text" id="${rankKey}-${index}-name" class="spell-name" placeholder="" autocomplete="off">
      </td>
      <td><input type="text" id="${rankKey}-${index}-cost" class="spell-cost" placeholder=""></td>
      <td class="spell-cast-cell"><button type="button" class="btn-cast-spell" id="${rankKey}-${index}-cast" title="Cast this spell">✦</button></td>
    `;
    tbody.appendChild(tr);
    
    const nameInput = tr.querySelector('.spell-name');
    const costInput = tr.querySelector('.spell-cost');
    const memCheck = tr.querySelector('.spell-memorized');
    
    // Populate data if provided
    if (data) {
      if (data.name) {
        nameInput.value = this.toTitleCase(data.name);
        if (data.classSpell) {
          nameInput.dataset.classSpell = data.classSpell;
        }
        if (window.SpellData) {
          const description = window.SpellData.getSpellDescription(data.name);
          if (description) nameInput.title = description;
        }
      }
      if (data.cost) costInput.value = data.cost;
      if (data.memorized) memCheck.checked = true;
    }
    
    // Memorize limit check
    memCheck.addEventListener('change', (e) => {
      if (e.target.checked) {
        const maxInput = document.getElementById(`${rankKey}-max`);
        const maxAllowed = parseInt(maxInput?.value, 10) || 0;
        const currentlyMemorized = tbody.querySelectorAll('.spell-memorized:checked').length;
        
        if (currentlyMemorized > maxAllowed) {
          e.target.checked = false;
          const label = this.spellRankLabels[rankKey];
          this.showMemorizeWarning(`You may only memorize ${maxAllowed} ${label} spell${maxAllowed !== 1 ? 's' : ''}. Forget one before you memorize another.`);
          return;
        }
      }
      this.scheduleAutoSave();
    });
    
    // Auto-fill cost on spell name change, auto-remove if cleared
    nameInput.addEventListener('change', () => {
      const spellName = nameInput.value.trim();
      if (spellName && window.SpellData) {
        nameInput.value = this.toTitleCase(spellName);
        const rankNum = rankKey === 'cantrips' ? 0 : parseInt(rankKey.replace('rank', ''), 10);
        const cost = window.SpellData.getSpellCost(spellName, rankNum);
        if (cost) costInput.value = cost;
        const description = window.SpellData.getSpellDescription(spellName);
        nameInput.title = description || '';
      } else if (!spellName) {
        // Name was cleared - remove the row
        this.removeSpellRow(rankKey, tr);
        return;
      }
      this.scheduleAutoSave();
    });
    
    nameInput.addEventListener('input', () => this.scheduleAutoSave());
    costInput.addEventListener('input', () => this.scheduleAutoSave());
    costInput.addEventListener('change', () => this.scheduleAutoSave());
    
    // Cast button
    const castBtn = tr.querySelector('.btn-cast-spell');
    castBtn.addEventListener('click', () => {
      const idx = Array.from(tbody.rows).indexOf(tr);
      this.castSpell(rankKey, idx);
    });
    
    return tr;
  },
  
  /**
   * Remove a spell row and re-index remaining rows
   */
  removeSpellRow(rankKey, tr) {
    const tbody = document.getElementById(`${rankKey}-body`);
    if (!tbody || !tr) return;
    
    tr.remove();
    this.reindexSpellRows(rankKey);
    this.scheduleAutoSave();
    this.updateSpellFillButtons();
  },
  
  /**
   * Re-index all spell row IDs in a rank to be sequential
   */
  reindexSpellRows(rankKey) {
    const tbody = document.getElementById(`${rankKey}-body`);
    if (!tbody) return;
    
    Array.from(tbody.rows).forEach((tr, i) => {
      const mem = tr.querySelector('.spell-memorized');
      const name = tr.querySelector('.spell-name');
      const cost = tr.querySelector('.spell-cost');
      const cast = tr.querySelector('.btn-cast-spell');
      
      if (mem) mem.id = `${rankKey}-${i}-mem`;
      if (name) name.id = `${rankKey}-${i}-name`;
      if (cost) cost.id = `${rankKey}-${i}-cost`;
      if (cast) cast.id = `${rankKey}-${i}-cast`;
    });
  },

  /**
   * Show memorize limit warning
   */
  showMemorizeWarning(message) {
    // Create or get warning overlay
    let overlay = document.getElementById('memorize-warning-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'memorize-warning-overlay';
      overlay.className = 'damage-result-overlay';
      overlay.innerHTML = `
        <div class="damage-result-content memorize-warning-content">
          <div class="memorize-warning-icon">⚠️</div>
          <div class="memorize-warning-message"></div>
          <button class="damage-close">OK</button>
        </div>
      `;
      document.body.appendChild(overlay);
      
      overlay.querySelector('.damage-close').addEventListener('click', () => {
        overlay.classList.remove('visible');
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.classList.remove('visible');
        }
      });
    }
    
    overlay.querySelector('.memorize-warning-message').textContent = message;
    overlay.classList.add('visible');
  },

  /**
   * Populate form with character data
   */
  populateForm() {
    // Info fields
    const infoMapping = {
      'character-name': 'characterName',
      'species': 'species',
      'culture': 'culture',
      'class-primary': 'classPrimary',
      'class-secondary': 'classSecondary',
      'class-tertiary': 'classTertiary',
      'rank-name': 'rankName',
      'gender': 'gender',
      'age': 'age',
      'handedness': 'handedness',
      'height': 'height',
      'weight': 'weight',
      'hair': 'hair',
      'eyes': 'eyes',
      'rank-primary': 'rankPrimary',
      'rank-secondary': 'rankSecondary',
      'rank-tertiary': 'rankTertiary',
      'tenacity-current': 'tenacityCurrent',
      'tenacity-max': 'tenacityMax',
      'exp-rolls': 'expRolls'
    };
    
    for (const [fieldId, key] of Object.entries(infoMapping)) {
      const field = document.getElementById(fieldId);
      if (field && this.character.info[key] !== undefined) {
        field.value = this.character.info[key];
      }
    }
    
    // Attributes (single value)
    for (const attr of ['STR', 'CON', 'SIZ', 'DEX', 'INT', 'POW', 'CHA']) {
      const input = document.getElementById(`${attr.toLowerCase()}-value`);
      if (input && this.character.attributes[attr] !== undefined) {
        input.value = this.character.attributes[attr];
      }
    }
    
    // Derived stats (current values)
    const derivedMapping = {
      'action-points-current': 'actionPointsCurrent',
      'damage-mod-current': 'damageModCurrent',
      'exp-mod-current': 'expModCurrent',
      'healing-rate-current': 'healingRateCurrent',
      'initiative-current': 'initiativeCurrent',
      'luck-current': 'luckCurrent',
      'magic-points-current': 'magicPointsCurrent',
      'movement-current': 'movementCurrent',
      'tenacity-current': 'tenacityCurrent'
    };
    
    for (const [fieldId, key] of Object.entries(derivedMapping)) {
      const field = document.getElementById(fieldId);
      if (field && this.character.derived[key] !== undefined) {
        field.value = this.character.derived[key];
        // Store as original value for ENC penalty system (initiative and movement)
        if (fieldId === 'initiative-current' || fieldId === 'movement-current') {
          field.dataset.originalValue = this.character.derived[key];
        }
      }
    }
    
    // Restore locked characteristics state if locked
    if (this.character.originalsLocked) {
      // Update button state to show locked
      const btn = document.getElementById('unlock-originals-btn');
      if (btn) {
        btn.textContent = '🔒 Unlock Characteristics';
        btn.classList.remove('unlocked');
      }
    }
    
    // Standard skills
    for (const skillKey of Object.keys(SKILL_DEFINITIONS.standard)) {
      const input = document.getElementById(`${this.kebabCase(skillKey)}-current`);
      if (input && this.character.standardSkills[skillKey] !== undefined) {
        input.value = this.character.standardSkills[skillKey];
        // Store as original value for ENC penalty system
        input.dataset.originalValue = this.character.standardSkills[skillKey];
      }
    }
    
    // Notes are now loaded via setupNotesPage -> loadNotesData
    
    // Images
    if (this.character.images.fullBody) {
      this.displayImage('full-body', this.character.images.fullBody);
    }
    if (this.character.images.portrait) {
      this.displayImage('portrait', this.character.images.portrait);
    }
    
    // ENC automation
    const encToggle = document.getElementById('enc-automation-toggle');
    if (encToggle) {
      encToggle.checked = !this.character.encAutomation;
    }
    
    // Equipment
    if (this.character.equipment) {
      this.character.equipment.forEach((item, i) => {
        const nameInput = document.getElementById(`equip-${i}-name`);
        const encInput = document.getElementById(`equip-${i}-enc`);
        if (nameInput && item.name) nameInput.value = this.toTitleCase(item.name);
        if (encInput && item.enc) encInput.value = item.enc;
      });
    }
    
    // Money
    if (this.character.money) {
      const moneyTypes = ['copper', 'silver', 'gold', 'platinum', 'electrum'];
      moneyTypes.forEach(type => {
        const input = document.getElementById(`money-${type}`);
        if (input && this.character.money[type] !== undefined && this.character.money[type] !== '') {
          input.value = this.character.money[type];
        }
      });
      this.updateMoneyEnc();
    }
    
    // Professional Skills
    if (this.character.professionalSkills) {
      this.character.professionalSkills.forEach((skill, i) => {
        const nameInput = document.getElementById(`prof-skill-${i}-name`);
        const baseInput = document.getElementById(`prof-skill-${i}-base`);
        const currentInput = document.getElementById(`prof-skill-${i}-current`);
        const prereqKeys = document.getElementById(`prof-skill-${i}-prereq`);
        if (nameInput && skill.name) nameInput.value = this.toTitleCase(skill.name);
        if (baseInput) {
          // If base formula was saved, use it; otherwise try to auto-fill from skill name
          if (skill.base) {
            baseInput.value = skill.base;
          } else if (skill.name) {
            // Try to auto-fill the formula from skill definitions
            const skillNameLower = skill.name.replace(/\s*\(.*?\)/g, '').trim().toLowerCase();
            if (SKILL_DEFINITIONS.professional && SKILL_DEFINITIONS.professional[skillNameLower]) {
              baseInput.value = SKILL_DEFINITIONS.professional[skillNameLower].formula;
            }
          }
        }
        if (currentInput && skill.current) {
          currentInput.value = skill.current;
          // Store as original value for ENC penalty system
          currentInput.dataset.originalValue = skill.current;
        }
        // Update prereq-keys data attribute
        if (prereqKeys && skill.name) prereqKeys.dataset.skillName = this.toTitleCase(skill.name);
        // Update ENC indicator visibility
        this.updateProfSkillEncIndicator(i);
      });
      // Recalculate base values after loading
      this.recalculateProfessionalSkillBases();
    }
    
    // Alignments
    if (this.character.alignments) {
      this.character.alignments.forEach((item, i) => {
        const nameInput = document.getElementById(`alignment-${i+1}-name`);
        const currentInput = document.getElementById(`alignment-${i+1}-current`);
        if (nameInput && item.name) nameInput.value = item.name;
        if (currentInput && item.current) currentInput.value = item.current;
      });
    }
    
    // Passions
    if (this.character.passions) {
      this.character.passions.forEach((item, i) => {
        const nameInput = document.getElementById(`passion-${i+1}-name`);
        const formulaInput = document.getElementById(`passion-${i+1}-formula`);
        const currentInput = document.getElementById(`passion-${i+1}-current`);
        if (nameInput && item.name) nameInput.value = item.name;
        if (formulaInput && item.formula) formulaInput.value = item.formula;
        if (currentInput && item.current) currentInput.value = item.current;
      });
    }
    
    // Oaths
    if (this.character.oaths) {
      this.character.oaths.forEach((item, i) => {
        const nameInput = document.getElementById(`oath-${i+1}-name`);
        const currentInput = document.getElementById(`oath-${i+1}-current`);
        if (nameInput && item.name) nameInput.value = item.name;
        if (currentInput && item.current) currentInput.value = item.current;
      });
    }
    
    // Languages
    if (this.character.languages) {
      // Native tongue
      if (this.character.languages[0]) {
        const nativeName = document.getElementById('native-tongue-name');
        const nativeCurrent = document.getElementById('native-tongue-current');
        if (nativeName && this.character.languages[0].name) nativeName.value = this.character.languages[0].name;
        if (nativeCurrent && this.character.languages[0].current) nativeCurrent.value = this.character.languages[0].current;
      }
      // Additional languages
      for (let i = 1; i < this.character.languages.length; i++) {
        const item = this.character.languages[i];
        const nameInput = document.getElementById(`language-${i+1}-name`);
        const currentInput = document.getElementById(`language-${i+1}-current`);
        if (nameInput && item.name) nameInput.value = item.name;
        if (currentInput && item.current) currentInput.value = item.current;
      }
    }
    
    // Combat Skills
    if (this.character.combat && this.character.combat.skills && this.character.combat.skills[0]) {
      const skill = this.character.combat.skills[0];
      const nameInput = document.getElementById('combat-skill-1-name');
      const percentInput = document.getElementById('combat-skill-1-percent');
      const weaponsInput = document.getElementById('combat-skill-1-weapons');
      if (nameInput && skill.name) nameInput.value = skill.name;
      if (percentInput && skill.percent) percentInput.value = skill.percent;
      if (weaponsInput && skill.weapons) weaponsInput.value = skill.weapons;
    }
    
    // Unarmed
    if (this.character.combat) {
      const unarmedInput = document.getElementById('unarmed-percent');
      if (unarmedInput && this.character.combat.unarmedPercent) {
        unarmedInput.value = this.character.combat.unarmedPercent;
      }
    }
    
    // Hit Locations
    if (this.character.combat && this.character.combat.hitLocations) {
      this.character.combat.hitLocations.forEach((loc, i) => {
        const armorInput = document.getElementById(`loc-${i}-armor`);
        const apInput = document.getElementById(`loc-${i}-ap`);
        const hpInput = document.getElementById(`loc-${i}-hp`);
        const currentInput = document.getElementById(`loc-${i}-current`);
        if (armorInput && loc.armor) armorInput.value = loc.armor;
        if (apInput && loc.ap) apInput.value = loc.ap;
        if (hpInput && loc.hp !== undefined && loc.hp !== '') hpInput.value = loc.hp;
        if (currentInput && loc.current) currentInput.value = loc.current;
      });
    }
    
    // Melee Weapons
    if (this.character.combat && this.character.combat.meleeWeapons) {
      this.character.combat.meleeWeapons.forEach((weapon, i) => {
        const fields = ['name', 'hands', 'damage', 'size', 'effects', 'aphp', 'traits'];
        const nameInput = document.getElementById(`melee-${i}-name`);
        fields.forEach(field => {
          const input = document.getElementById(`melee-${i}-${field}`);
          if (input && weapon[field]) {
            input.value = field === 'name' ? this.toTitleCase(weapon[field]) : weapon[field];
          }
          // Restore baseDamage data attribute for damage field
          if (field === 'damage' && input && weapon.baseDamage) {
            input.dataset.baseDamage = weapon.baseDamage;
          }
        });
        // Restore userModified flag
        if (nameInput && weapon.userModified) {
          nameInput.dataset.userModified = 'true';
        }
      });
    }
    
    // Ranged Weapons
    if (this.character.combat && this.character.combat.rangedWeapons) {
      this.character.combat.rangedWeapons.forEach((weapon, i) => {
        const fields = ['name', 'hands', 'damage', 'dm', 'range', 'load', 'effects', 'impl', 'aphp', 'traits'];
        const nameInput = document.getElementById(`ranged-${i}-name`);
        fields.forEach(field => {
          const input = document.getElementById(`ranged-${i}-${field}`);
          if (input && weapon[field]) {
            input.value = field === 'name' ? this.toTitleCase(weapon[field]) : weapon[field];
          }
          // Restore baseDamage data attribute for damage field
          if (field === 'damage' && input && weapon.baseDamage) {
            input.dataset.baseDamage = weapon.baseDamage;
          }
          // Restore original load: use the saved original so reduction applies cleanly
          if (field === 'load' && input && weapon.originalLoad) {
            input.value = weapon.originalLoad;
            input.dataset.originalLoad = weapon.originalLoad;
          }
        });
        // Restore userModified flag
        if (nameInput && weapon.userModified) {
          nameInput.dataset.userModified = 'true';
        }
      });
    }
    
    // Update Unarmed AP/HP from arm hit locations
    this.updateUnarmedAPHP();
    
    // Special Abilities (dynamic format)
    if (this.character.combat && this.character.combat.specialAbilities) {
      this.character.combat.specialAbilities.forEach((ability) => {
        if (ability) {
          // Handle both new format (object with name/source) and old format (string)
          if (typeof ability === 'object' && ability.name && ability.name.trim()) {
            this.addClassAbilityRow(ability.name, ability.source);
          } else if (typeof ability === 'string' && ability.trim()) {
            this.addClassAbilityRow(ability);
          }
        }
      });
      // Update tooltips after loading abilities
      this.updateAllAbilityTooltips();
    }
    
    // Flying Speed
    if (this.character.combat) {
      const flyingInput = document.getElementById('flying-speed');
      if (flyingInput && this.character.combat.flyingSpeed) {
        flyingInput.value = this.character.combat.flyingSpeed;
      }
    }
    
    // Magic Skills
    if (this.character.magic) {
      const magicFields = {
        'deity-name': 'deity',
        'channel-percent': 'channelPercent',
        'piety-percent': 'pietyPercent',
        'arcane-casting-percent': 'arcaneCastingPercent',
        'arcane-knowledge-percent': 'arcaneKnowledgePercent',
        'arcane-sorcery-percent': 'arcaneSorceryPercent',
        'sorcerous-wisdom-percent': 'sorcerousWisdomPercent',
        'musicianship-percent': 'musicianshipPercent',
        'lyrical-magic-percent': 'lyricalMagicPercent'
      };
      for (const [fieldId, key] of Object.entries(magicFields)) {
        const input = document.getElementById(fieldId);
        if (input && this.character.magic[key]) input.value = this.character.magic[key];
      }
    }
    
    // Spells
    if (this.character.magic && this.character.magic.spells) {
      const ranks = ['cantrips', 'rank1', 'rank2', 'rank3', 'rank4', 'rank5'];
      ranks.forEach(rank => {
        if (this.character.magic.spells[rank]) {
          // Max spells
          const maxInput = document.getElementById(`${rank}-max`);
          if (maxInput && this.character.magic.spells[rank].max) {
            maxInput.value = this.character.magic.spells[rank].max;
          }
          // Individual spells - create a row for each saved spell
          if (this.character.magic.spells[rank].spells) {
            this.character.magic.spells[rank].spells.forEach(spell => {
              if (spell.name) {
                this.addSpellRow(rank, spell);
              }
            });
          }
        }
      });
    }
    
    // Update weapon damages with current damage modifier after all data is loaded
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    
    // Restore fatigue state
    if (this.character.fatigueState && this.character.fatigueState !== 'fresh') {
      this.setFatigueState(this.character.fatigueState, false); // false = don't re-save yet
    }
    
    // Ensure ALL skill fields have originalValue set for penalty system
    this.initializeOriginalValues();
  },

  /**
   * Collect all form data into character object
   */
  collectFormData() {
    // This is called before save/export to ensure all data is captured
    // Most data is already saved via event listeners, but this catches anything missed
    
    // Equipment - collect from actual rows
    this.character.equipment = [];
    const equipmentContainer = document.getElementById('equipment-container');
    if (equipmentContainer) {
      const equipmentRows = equipmentContainer.querySelectorAll('.equipment-row');
      equipmentRows.forEach((row, i) => {
        const nameInput = document.getElementById(`equip-${i}-name`);
        const encInput = document.getElementById(`equip-${i}-enc`);
        if (nameInput && encInput && nameInput.value.trim()) {
          this.character.equipment.push({
            name: nameInput.value,
            enc: encInput.value
          });
        }
      });
    }
    
    // Money
    this.character.money = {
      copper: document.getElementById('money-copper')?.value || '',
      silver: document.getElementById('money-silver')?.value || '',
      gold: document.getElementById('money-gold')?.value || '',
      platinum: document.getElementById('money-platinum')?.value || '',
      electrum: document.getElementById('money-electrum')?.value || ''
    };
    
    // Alignments (dynamic rows) - only save rows with a name
    this.character.alignments = [];
    const alignmentContainer = document.getElementById('alignment-container');
    if (alignmentContainer) {
      const alignmentRows = alignmentContainer.querySelectorAll('.belief-row');
      alignmentRows.forEach((row, i) => {
        const nameInput = row.querySelector('.belief-name');
        const currentInput = row.querySelector('.belief-input');
        if (nameInput?.value?.trim()) {
          this.character.alignments.push({
            name: nameInput.value,
            current: currentInput?.value || ''
          });
        }
      });
    }
    
    // Passions (dynamic rows with custom formulas) - only save rows with a name
    this.character.passions = [];
    const passionsContainer = document.getElementById('passions-container');
    if (passionsContainer) {
      const passionRows = passionsContainer.querySelectorAll('.belief-row');
      passionRows.forEach((row, i) => {
        const nameInput = row.querySelector('.belief-name');
        const formulaInput = row.querySelector('.belief-formula-input');
        const currentInput = row.querySelector('.belief-input');
        if (nameInput?.value?.trim()) {
          this.character.passions.push({
            name: nameInput.value,
            formula: formulaInput?.value || 'POW+INT+50',
            current: currentInput?.value || ''
          });
        }
      });
    }
    
    // Oaths (dynamic rows) - only save rows with a name
    this.character.oaths = [];
    const oathsContainer = document.getElementById('oaths-container');
    if (oathsContainer) {
      const oathRows = oathsContainer.querySelectorAll('.belief-row');
      oathRows.forEach((row, i) => {
        const nameInput = row.querySelector('.belief-name');
        const currentInput = row.querySelector('.belief-input');
        if (nameInput?.value?.trim()) {
          this.character.oaths.push({
            name: nameInput.value,
            current: currentInput?.value || ''
          });
        }
      });
    }
    
    // Languages - native tongue always saved, others only if they have a name
    this.character.languages = [];
    const nativeName = document.getElementById('native-tongue-name');
    const nativeCurrent = document.getElementById('native-tongue-current');
    if (nativeName && nativeCurrent) {
      this.character.languages.push({
        name: nativeName.value,
        current: nativeCurrent.value,
        isNative: true
      });
    }
    
    // Additional languages - use querySelectorAll to find all non-native language rows
    const languageContainer = document.getElementById('language-container');
    if (languageContainer) {
      const languageRows = languageContainer.querySelectorAll('.language-row:not(.native)');
      languageRows.forEach(row => {
        const nameInput = row.querySelector('.language-name');
        const currentInput = row.querySelector('.language-input');
        if (nameInput?.value?.trim()) {
          this.character.languages.push({
            name: nameInput.value,
            current: currentInput?.value || '',
            isNative: false
          });
        }
      });
    }
    
    // Professional Skills - collect from actual rows
    this.character.professionalSkills = [];
    const profSkillsContainer = document.getElementById('professional-skills-container');
    if (profSkillsContainer) {
      const profSkillRows = profSkillsContainer.querySelectorAll('.professional-skill-row');
      profSkillRows.forEach((row, i) => {
        const nameInput = document.getElementById(`prof-skill-${i}-name`);
        const baseInput = document.getElementById(`prof-skill-${i}-base`);
        const currentInput = document.getElementById(`prof-skill-${i}-current`);
        if (nameInput && baseInput && currentInput && nameInput.value.trim()) {
          this.character.professionalSkills.push({
            name: nameInput.value,
            base: baseInput.value,
            // Save original (pre-penalty) value if available
            current: currentInput.dataset.originalValue || currentInput.value
          });
        }
      });
    }
    
    // Combat Skills
    this.character.combat.skills = [];
    const nameInput = document.getElementById('combat-skill-1-name');
    const percentInput = document.getElementById('combat-skill-1-percent');
    const weaponsInput = document.getElementById('combat-skill-1-weapons');
    if (nameInput) {
      this.character.combat.skills.push({
        name: nameInput?.value || '',
        percent: percentInput?.dataset.originalValue || percentInput?.value || '',
        weapons: weaponsInput?.value || ''
      });
    }
    
    // Unarmed
    const unarmedInput = document.getElementById('unarmed-percent');
    if (unarmedInput) {
      this.character.combat.unarmedPercent = unarmedInput.dataset.originalValue || unarmedInput.value;
    }
    
    // Hit Locations
    this.character.combat.hitLocations = [];
    const hitLocCount = this.sheetType === 'syrin' ? 9 : 7;
    for (let i = 0; i < hitLocCount; i++) {
      const armorInput = document.getElementById(`loc-${i}-armor`);
      const apInput = document.getElementById(`loc-${i}-ap`);
      const hpInput = document.getElementById(`loc-${i}-hp`);
      const currentInput = document.getElementById(`loc-${i}-current`);
      this.character.combat.hitLocations.push({
        armor: armorInput?.value || '',
        ap: apInput?.value || '',
        hp: hpInput?.value || '',
        current: currentInput?.value || ''
      });
    }
    
    // Melee Weapons - collect from actual rows
    this.character.combat.meleeWeapons = [];
    const meleeBody = document.getElementById('melee-weapons-body');
    if (meleeBody) {
      const meleeRows = meleeBody.querySelectorAll('tr');
      meleeRows.forEach((row, i) => {
        const nameInput = document.getElementById(`melee-${i}-name`);
        if (nameInput?.value?.trim()) {
          const weapon = {};
          const fields = ['name', 'hands', 'damage', 'size', 'effects', 'aphp', 'traits'];
          fields.forEach(field => {
            const input = document.getElementById(`melee-${i}-${field}`);
            weapon[field] = input?.value || '';
            // Save baseDamage data attribute for damage field
            if (field === 'damage' && input?.dataset?.baseDamage) {
              weapon.baseDamage = input.dataset.baseDamage;
            }
          });
          // Save userModified flag
          if (nameInput?.dataset?.userModified === 'true') {
            weapon.userModified = true;
          }
          this.character.combat.meleeWeapons.push(weapon);
        }
      });
    }
    
    // Ranged Weapons - collect from actual rows
    this.character.combat.rangedWeapons = [];
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (rangedBody) {
      const rangedRows = rangedBody.querySelectorAll('tr');
      rangedRows.forEach((row, i) => {
        const nameInput = document.getElementById(`ranged-${i}-name`);
        if (nameInput?.value?.trim()) {
          const weapon = {};
          const fields = ['name', 'hands', 'damage', 'dm', 'range', 'load', 'effects', 'impl', 'aphp', 'traits'];
          fields.forEach(field => {
            const input = document.getElementById(`ranged-${i}-${field}`);
            weapon[field] = input?.value || '';
            // Save baseDamage data attribute for damage field
            if (field === 'damage' && input?.dataset?.baseDamage) {
              weapon.baseDamage = input.dataset.baseDamage;
            }
            // Save original (unreduced) load value if spec-reduced
            if (field === 'load' && input?.dataset?.originalLoad) {
              weapon.originalLoad = input.dataset.originalLoad;
            }
          });
          // Save userModified flag
          if (nameInput?.dataset?.userModified === 'true') {
            weapon.userModified = true;
          }
          this.character.combat.rangedWeapons.push(weapon);
        }
      });
    }
    
    // Special Abilities (dynamic list format)
    this.character.combat.specialAbilities = [];
    const abilityContainer = document.getElementById('class-abilities-list');
    if (abilityContainer) {
      const abilityInputs = abilityContainer.querySelectorAll('.class-ability-input');
      abilityInputs.forEach(input => {
        if (input.value.trim()) {
          this.character.combat.specialAbilities.push({
            name: input.value.trim(),
            source: input.dataset.classAbility || null
          });
        }
      });
    }
    
    // Flying Speed
    const flyingInput = document.getElementById('flying-speed');
    if (flyingInput) {
      this.character.combat.flyingSpeed = flyingInput.value;
    }
    
    // Magic Skills
    const magicFields = {
      'deity-name': 'deity',
      'channel-percent': 'channelPercent',
      'piety-percent': 'pietyPercent',
      'arcane-casting-percent': 'arcaneCastingPercent',
      'arcane-knowledge-percent': 'arcaneKnowledgePercent',
      'arcane-sorcery-percent': 'arcaneSorceryPercent',
      'sorcerous-wisdom-percent': 'sorcerousWisdomPercent',
      'musicianship-percent': 'musicianshipPercent',
      'lyrical-magic-percent': 'lyricalMagicPercent'
    };
    for (const [fieldId, key] of Object.entries(magicFields)) {
      const input = document.getElementById(fieldId);
      if (input) {
        // Use original (unpenalized) value if available to prevent double-penalizing on reload
        this.character.magic[key] = input.dataset.originalValue || input.value;
      }
    }
    
    // Spells
    const ranks = ['cantrips', 'rank1', 'rank2', 'rank3', 'rank4', 'rank5'];
    ranks.forEach(rank => {
      // Max spells
      const maxInput = document.getElementById(`${rank}-max`);
      if (maxInput) {
        this.character.magic.spells[rank].max = maxInput.value;
      }
      // Individual spells - iterate actual rows
      this.character.magic.spells[rank].spells = [];
      const tbody = document.getElementById(`${rank}-body`);
      if (tbody) {
        Array.from(tbody.rows).forEach((tr, i) => {
          const nameInput = tr.querySelector('.spell-name');
          const costInput = tr.querySelector('.spell-cost');
          const memCheck = tr.querySelector('.spell-memorized');
          if (nameInput && nameInput.value.trim()) {
            this.character.magic.spells[rank].spells.push({
              name: nameInput.value || '',
              cost: costInput?.value || '',
              memorized: memCheck?.checked || false,
              classSpell: nameInput.dataset.classSpell || null
            });
          }
        });
      }
    });
    
    // Notes - save rich text sections and journal
    this.saveNotesData();
    
    // Species Abilities
    this.character.speciesAbilities = [];
    const speciesContainer = document.getElementById('species-abilities-list');
    if (speciesContainer) {
      const speciesInputs = speciesContainer.querySelectorAll('.species-ability-input');
      speciesInputs.forEach(input => {
        if (input.value.trim()) {
          this.character.speciesAbilities.push(input.value.trim());
        }
      });
    }
    
    // Berserk Rage state (already tracked in this.character but ensure it's captured)
    // rageUsesRemaining, isRaging, and preRageValues are already set directly on this.character
  },

  /**
   * Recalculate all derived values
   */
  recalculateAll() {
    const attrs = this.character.attributes;
    
    // Calculate combined rank from all classes
    const primaryRank = parseInt(document.getElementById('rank-primary')?.value, 10) || 0;
    const secondaryRank = parseInt(document.getElementById('rank-secondary')?.value, 10) || 0;
    const tertiaryRank = parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0;
    const combinedRank = primaryRank + secondaryRank + tertiaryRank;
    
    // Update the combined rank display field
    const combinedRankField = document.getElementById('rank-combined');
    if (combinedRankField) {
      combinedRankField.value = combinedRank;
    }
    
    // Check if character is human (for luck bonus)
    const species = document.getElementById('species')?.value?.toLowerCase().trim() || '';
    const isHuman = species === 'human';
    
    // Check if character has Resilient trait (HP uses STR+CON+SIZ)
    // Check multiple sources since DOM may not be populated yet during init:
    // 1. DOM (class abilities list)
    // 2. activeAbilityEffects (persistent effects tracking)
    // 3. Saved character data (this.character.combat.specialAbilities)
    const resilientInDOM = this.hasAbilityOnSheet('resilient');
    const resilientInEffects = !!this.activeAbilityEffects['resilient'];
    const savedAbilities = this.character.combat?.specialAbilities || [];
    const resilientInSaved = savedAbilities.some(a => {
      const name = (typeof a === 'object' ? a.name : a) || '';
      return name.toLowerCase().trim() === 'resilient';
    });
    const hasResilient = resilientInDOM || resilientInEffects || resilientInSaved;
    
    const results = Calculator.recalculateAll(attrs, this.sheetType, combinedRank, isHuman, hasResilient);
    
    // Always update original attribute values (they are auto-calculated and readonly)
    const apOrig = document.getElementById('action-points-original');
    if (apOrig) {
      const oldAP = parseInt(apOrig.value, 10) || 0;
      const newAP = results.derived.actionPoints;
      apOrig.value = newAP;
      
      // CRITICAL: Update the dataset.originalValue cache used by the fatigue/ENC penalty system.
      // Without this, applyActionPointPenalty() will overwrite the new value with the stale cache.
      if (apOrig.dataset.originalValue !== undefined) {
        apOrig.dataset.originalValue = newAP;
      }
      
      // Sync current AP when original increases (rank-up)
      const apCurr = document.getElementById('action-points-current');
      if (apCurr && newAP !== oldAP && oldAP > 0) {
        const currentVal = parseInt(apCurr.value, 10);
        if (newAP > oldAP) {
          // Increase: bump current by the same delta
          if (isNaN(currentVal) || currentVal === oldAP) {
            apCurr.value = newAP;
          } else {
            apCurr.value = currentVal + (newAP - oldAP);
          }
        } else {
          // Decrease: cap current to new max
          if (!isNaN(currentVal) && currentVal > newAP) {
            apCurr.value = newAP;
          }
        }
        // Update the penalty cache for current too
        if (apCurr.dataset.originalValue !== undefined) {
          apCurr.dataset.originalValue = apCurr.value;
        }
        this.character.derived.actionPointsCurrent = apCurr.value;
      }
    }
    
    const dmgOrig = document.getElementById('damage-mod-original');
    if (dmgOrig) {
      dmgOrig.value = results.derived.damageModifier;
    }
    
    const expOrig = document.getElementById('exp-mod-original');
    if (expOrig) {
      expOrig.value = results.derived.expMod;
    }
    
    const healOrig = document.getElementById('healing-rate-original');
    if (healOrig) {
      healOrig.value = results.derived.healingRate;
    }
    
    const initOrig = document.getElementById('initiative-original');
    if (initOrig) {
      initOrig.value = results.derived.initiative;
    }
    
    const luckOrig = document.getElementById('luck-original');
    if (luckOrig) {
      luckOrig.value = results.derived.luckPoints;
    }
    
    const magicOrig = document.getElementById('magic-points-original');
    if (magicOrig) {
      magicOrig.value = results.derived.magicPoints;
    }
    
    // Update hit location HPs (original only)
    this.updateHitLocationHPs(results.hitLocations);
    
    // Save derived original values to character data for persistence
    this.saveDerivedOriginalValues();
    
    // Seed empty current values from originals (first load or new character)
    const seedPairs = [
      ['action-points-original', 'action-points-current', 'actionPointsCurrent'],
      ['luck-original', 'luck-current', 'luckCurrent'],
      ['magic-points-original', 'magic-points-current', 'magicPointsCurrent'],
      ['initiative-original', 'initiative-current', 'initiativeCurrent'],
      ['damage-mod-original', 'damage-mod-current', 'damageModCurrent'],
      ['exp-mod-original', 'exp-mod-current', 'expModCurrent'],
      ['healing-rate-original', 'healing-rate-current', 'healingRateCurrent']
    ];
    for (const [origId, currId, dataKey] of seedPairs) {
      const origEl = document.getElementById(origId);
      const currEl = document.getElementById(currId);
      if (origEl && currEl && origEl.value && !currEl.value) {
        currEl.value = origEl.value;
        this.character.derived[dataKey] = origEl.value;
      }
    }
    
    // Update movement rate from species
    const movementOrig = document.getElementById('movement-original');
    if (movementOrig && window.SpeciesData) {
      const speciesData = window.SpeciesData.getSpecies(species);
      movementOrig.value = speciesData ? speciesData.movement : 20;
    }
    
    // Update weapon damage displays when damage modifier changes
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    
    // Update MP display on spell pages
    this.updateMagicMPDisplay();
    
    // Tenacity Max is always equal to POW (not affected by lock)
    const tenacityMax = document.getElementById('tenacity-max');
    if (tenacityMax) {
      tenacityMax.value = attrs.POW || '';
    }
    
    // Update skill bases
    for (const [skillKey, baseValue] of Object.entries(results.skills)) {
      const baseSpan = document.getElementById(`${this.kebabCase(skillKey)}-base`);
      if (baseSpan) {
        baseSpan.textContent = baseValue;
      }
    }
    
    // Update alignment bases (dynamic count)
    const alignmentContainer = document.getElementById('alignment-container');
    if (alignmentContainer) {
      const alignmentRows = alignmentContainer.querySelectorAll('.belief-row');
      alignmentRows.forEach(row => {
        const alignmentBase = row.querySelector('.belief-base');
        if (alignmentBase) alignmentBase.textContent = results.beliefs.alignment;
      });
    }
    
    // Update all passion bases (dynamic count) - each passion can have a custom formula
    const passionsContainer = document.getElementById('passions-container');
    if (passionsContainer) {
      const passionRows = passionsContainer.querySelectorAll('.belief-row');
      passionRows.forEach(row => {
        const formulaInput = row.querySelector('.belief-formula-input');
        const passionBase = row.querySelector('.belief-base');
        if (formulaInput && passionBase) {
          const formula = formulaInput.value.trim();
          if (formula) {
            const result = this.calculateFormulaValue(formula.toUpperCase());
            passionBase.textContent = result !== null ? result : '0';
          } else {
            passionBase.textContent = '0';
          }
        }
      });
    }
    
    // Update all oath bases (dynamic count)
    const oathsContainer = document.getElementById('oaths-container');
    if (oathsContainer) {
      const oathRows = oathsContainer.querySelectorAll('.belief-row');
      oathRows.forEach(row => {
        const oathBase = row.querySelector('.belief-base');
        if (oathBase) oathBase.textContent = results.beliefs.oath;
      });
    }
    
    // Update language bases
    const nativeBase = document.getElementById('native-tongue-base');
    if (nativeBase) nativeBase.textContent = results.languages.native;
    
    // Update all additional language bases (dynamic count)
    const langContainer = document.getElementById('language-container');
    if (langContainer) {
      const langRows = langContainer.querySelectorAll('.language-row:not(.native)');
      langRows.forEach((row, idx) => {
        const langBase = row.querySelector('.language-base');
        if (langBase) langBase.textContent = results.languages.additional;
      });
    }
    
    // Update professional skill base values
    this.recalculateProfessionalSkillBases();
    
    // Note: Hit location HP Original values are auto-calculated based on CON+SIZ (or STR+CON+SIZ with Resilient)
    // Current HP values are user-editable and saved/loaded from storage
    
    // Update combat quick reference
    this.updateCombatQuickRef();
    
    // Update movement
    this.updateMovementDisplay();
    
    // Update jumps
    this.updateJumpDisplay();
    
    // Update total ENC
    this.updateTotalEnc();
    
    // Update weapon damages with current damage modifier
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    
    // Update spell memorization limits (depends on INT)
    this.updateSpellMemorization();
    
    // Update spell fill/clear buttons (no longer auto-populates)
    this.updateSpellFillButtons();
    
    // Populate class abilities
    this.updateClassAbilities(null);
    
    // Re-apply ability effects (Artful Dodger, Weapon Precision, etc.)
    // These modify calculated values and need to be reapplied after base recalculation
    this.reapplyAbilityEffects();
    
    // After recalculation, ensure DM current matches the new original if no ability is stepping it
    this.resetDamageModToOriginalIfClean();
  },
  
  /**
   * Re-apply ability effects after recalculation
   * This is called after base values are recalculated to re-add bonuses
   * Skips persistent effects (like Lucky, Gifted) which modify input fields
   */
  reapplyAbilityEffects() {
    // Remember which persistent effects were already active (don't clear them)
    const persistentEffects = {};
    for (const [baseName, data] of Object.entries(this.activeAbilityEffects)) {
      const effect = this.ABILITY_EFFECTS[baseName];
      if (effect && effect.persistent) {
        persistentEffects[baseName] = data;
      }
    }
    
    // Clear non-persistent active tracking (base values were just recalculated)
    this.activeAbilityEffects = { ...persistentEffects };
    
    // Check all class abilities on the sheet and apply their effects
    const classContainer = document.getElementById('class-abilities-list');
    if (classContainer) {
      const inputs = classContainer.querySelectorAll('.class-ability-input');
      inputs.forEach(input => {
        if (input.value.trim()) {
          const baseName = input.value.split('(')[0].trim().toLowerCase();
          // Skip ENC-dependent abilities during initialization
          if (this.isInitializing && (baseName === 'artful dodger' || baseName === 'agile' || baseName === 'very agile')) {
            return;
          }
          const effect = this.ABILITY_EFFECTS[baseName];
          // Skip persistent effects - they were already applied when gained
          if (effect && !effect.persistent && !this.activeAbilityEffects[baseName]) {
            this.activeAbilityEffects[baseName] = { active: true };
            effect.apply(this);
          }
        }
      });
    }
    
    // Also check species abilities
    const speciesAbilities = this.getSpeciesAbilities();
    speciesAbilities.forEach(ability => {
      const baseName = ability.split('(')[0].trim().toLowerCase();
      // Skip ENC-dependent abilities during initialization
      if (this.isInitializing && (baseName === 'artful dodger' || baseName === 'agile' || baseName === 'very agile')) {
        return;
      }
      const effect = this.ABILITY_EFFECTS[baseName];
      // Skip persistent effects - they were already applied when gained
      if (effect && !effect.persistent && !this.activeAbilityEffects[baseName]) {
        this.activeAbilityEffects[baseName] = { active: true };
        effect.apply(this);
      }
    });
  },

  /**
   * Update combat quick reference values
   */
  updateCombatQuickRef() {
    const initCurrent = document.getElementById('initiative-current');
    const combatInit = document.getElementById('combat-initiative');
    if (initCurrent && combatInit) {
      combatInit.textContent = initCurrent.value || '-';
    }
    
    const luckCurrent = document.getElementById('luck-current');
    const combatLuck = document.getElementById('combat-luck');
    if (luckCurrent && combatLuck) {
      combatLuck.textContent = luckCurrent.value || '-';
    }
    
    const combatAP = document.getElementById('combat-action-points');
    if (combatAP) {
      const apCurrent = document.getElementById('action-points-current');
      const apOrig = document.getElementById('action-points-original');
      combatAP.textContent = (apCurrent && apCurrent.value) ? apCurrent.value : (apOrig ? apOrig.value : '');
    }
    
    // Combat Skill from combat page
    const combatSkillRef = document.getElementById('combat-skill-ref');
    const combatSkillPercent = document.getElementById('combat-skill-1-percent');
    if (combatSkillRef && combatSkillPercent) {
      combatSkillRef.textContent = combatSkillPercent.value ? `${combatSkillPercent.value}%` : '-';
      // Mirror forceful-penalized styling
      if (combatSkillPercent.classList.contains('forceful-penalized')) {
        combatSkillRef.classList.add('forceful-penalized');
      } else {
        combatSkillRef.classList.remove('forceful-penalized');
      }
    }
    
    // Damage Modifier
    const combatDmgMod = document.getElementById('combat-damage-mod');
    const dmgModCurrent = document.getElementById('damage-mod-current');
    const dmgModOriginal = document.getElementById('damage-mod-original');
    if (combatDmgMod) {
      const dmgVal = (dmgModCurrent && dmgModCurrent.value.trim()) ? dmgModCurrent.value.trim() 
                   : (dmgModOriginal && dmgModOriginal.value.trim()) ? dmgModOriginal.value.trim() 
                   : '-';
      combatDmgMod.textContent = dmgVal;
      // Mirror forceful-boosted styling
      if (dmgModCurrent && dmgModCurrent.classList.contains('forceful-boosted')) {
        combatDmgMod.classList.add('forceful-boosted');
      } else {
        combatDmgMod.classList.remove('forceful-boosted');
      }
    }
    
    // Combat-relevant skills - show the user's entered % value from Character page
    const skillRefs = ['athletics', 'brawn', 'endurance', 'evade', 'perception', 'stealth', 'swim', 'willpower'];
    skillRefs.forEach(skill => {
      const refItem = document.getElementById(`ref-${skill}`);
      const skillInput = document.getElementById(`${skill}-current`);
      if (refItem) {
        const valueSpan = refItem.querySelector('.ref-skill-value');
        if (valueSpan) {
          valueSpan.textContent = skillInput && skillInput.value ? `${skillInput.value}%` : '-';
        }
      }
    });
  },

  /**
   * Update combat skill name from class fields
   * Combines Primary/Secondary/Tertiary classes with "/" separator
   * @param {boolean} forceUpdate - If true, overwrites existing value (used when classes change)
   */
  updateCombatSkillName(forceUpdate = false) {
    const primaryClass = document.getElementById('class-primary');
    const secondaryClass = document.getElementById('class-secondary');
    const tertiaryClass = document.getElementById('class-tertiary');
    const combatSkillName = document.getElementById('combat-skill-1-name');
    
    if (!combatSkillName) return;
    
    // Only auto-fill if the field is empty, unless forceUpdate is true
    if (!forceUpdate && combatSkillName.value.trim()) return;
    
    const classes = [];
    if (primaryClass && primaryClass.value.trim()) {
      classes.push(primaryClass.value.trim());
    }
    if (secondaryClass && secondaryClass.value.trim()) {
      classes.push(secondaryClass.value.trim());
    }
    if (tertiaryClass && tertiaryClass.value.trim()) {
      classes.push(tertiaryClass.value.trim());
    }
    
    if (classes.length > 0) {
      combatSkillName.value = classes.join('/');
    } else if (forceUpdate) {
      // Clear if all classes are empty and we're forcing update
      combatSkillName.value = '';
    }
  },

  /**
   * Update weapons known from class fields
   * Combines weapons from all classes
   * @param {boolean} forceUpdate - If true, overwrites existing value (used when classes change)
   */
  updateWeaponsKnown(forceUpdate = false) {
    const primaryClass = document.getElementById('class-primary');
    const secondaryClass = document.getElementById('class-secondary');
    const tertiaryClass = document.getElementById('class-tertiary');
    const weaponsKnown = document.getElementById('combat-skill-1-weapons');
    
    if (!weaponsKnown) return;
    
    // Only auto-fill if the field is empty, unless forceUpdate is true
    if (!forceUpdate && weaponsKnown.value.trim()) return;
    
    // Check if WeaponData is available
    if (!window.WeaponData || !window.WeaponData.combineClassWeapons) return;
    
    const classes = [];
    if (primaryClass && primaryClass.value.trim()) {
      classes.push(primaryClass.value.trim());
    }
    if (secondaryClass && secondaryClass.value.trim()) {
      classes.push(secondaryClass.value.trim());
    }
    if (tertiaryClass && tertiaryClass.value.trim()) {
      classes.push(tertiaryClass.value.trim());
    }
    
    if (classes.length > 0) {
      weaponsKnown.value = window.WeaponData.combineClassWeapons(classes);
    } else if (forceUpdate) {
      // Clear if all classes are empty and we're forcing update
      weaponsKnown.value = '';
    }
  },

  /**
   * Validate multiclass restrictions and update field states
   * @param {string} changedFieldId - The field that was just changed
   */
  validateAndUpdateClasses(changedFieldId) {
    if (!window.ClassRankData) return;
    
    const primaryField = document.getElementById('class-primary');
    const secondaryField = document.getElementById('class-secondary');
    const tertiaryField = document.getElementById('class-tertiary');
    const rankSecondaryField = document.getElementById('rank-secondary');
    const rankTertiaryField = document.getElementById('rank-tertiary');
    
    const primary = primaryField?.value?.trim() || '';
    const secondary = secondaryField?.value?.trim() || '';
    const tertiary = tertiaryField?.value?.trim() || '';
    
    // Check if primary class can multiclass
    if (primary) {
      const canMulti = window.ClassRankData.canClassMulticlass(primary);
      
      if (!canMulti) {
        // Disable secondary and tertiary fields
        this.setMulticlassFieldsEnabled(false);
        
        // Clear any existing secondary/tertiary values with warning
        if (secondary || tertiary) {
          this.showMulticlassWarning(`${primary} cannot multiclass.`);
          if (secondaryField) {
            secondaryField.value = '';
            this.character.info.classSecondary = '';
          }
          if (tertiaryField) {
            tertiaryField.value = '';
            this.character.info.classTertiary = '';
          }
          if (rankSecondaryField) {
            rankSecondaryField.value = '';
            this.character.info.rankSecondary = '';
          }
          if (rankTertiaryField) {
            rankTertiaryField.value = '';
            this.character.info.rankTertiary = '';
          }
        }
        return;
      } else {
        // Enable secondary and tertiary fields
        this.setMulticlassFieldsEnabled(true);
      }
    } else {
      // No primary class - enable fields but they're essentially useless
      this.setMulticlassFieldsEnabled(true);
    }
    
    // Validate specific combinations
    if (changedFieldId === 'class-secondary' && secondary) {
      const check = window.ClassRankData.canCombineClasses(primary, secondary);
      if (!check.allowed) {
        this.showMulticlassWarning(check.reason);
        secondaryField.value = '';
        this.character.info.classSecondary = '';
        if (rankSecondaryField) {
          rankSecondaryField.value = '';
          this.character.info.rankSecondary = '';
        }
        return;
      }
    }
    
    if (changedFieldId === 'class-tertiary' && tertiary) {
      // Check tertiary against primary
      const check1 = window.ClassRankData.canCombineClasses(primary, tertiary);
      if (!check1.allowed) {
        this.showMulticlassWarning(check1.reason);
        tertiaryField.value = '';
        this.character.info.classTertiary = '';
        if (rankTertiaryField) {
          rankTertiaryField.value = '';
          this.character.info.rankTertiary = '';
        }
        return;
      }
      
      // Check tertiary against secondary
      if (secondary) {
        const check2 = window.ClassRankData.canCombineClasses(secondary, tertiary);
        if (!check2.allowed) {
          this.showMulticlassWarning(check2.reason);
          tertiaryField.value = '';
          this.character.info.classTertiary = '';
          if (rankTertiaryField) {
            rankTertiaryField.value = '';
            this.character.info.rankTertiary = '';
          }
          return;
        }
      }
    }
    
    // If primary changed, re-validate existing secondary/tertiary
    if (changedFieldId === 'class-primary' && primary) {
      if (secondary) {
        const check = window.ClassRankData.canCombineClasses(primary, secondary);
        if (!check.allowed) {
          this.showMulticlassWarning(check.reason);
          secondaryField.value = '';
          this.character.info.classSecondary = '';
          if (rankSecondaryField) {
            rankSecondaryField.value = '';
            this.character.info.rankSecondary = '';
          }
        }
      }
      if (tertiary) {
        const check = window.ClassRankData.canCombineClasses(primary, tertiary);
        if (!check.allowed) {
          this.showMulticlassWarning(check.reason);
          tertiaryField.value = '';
          this.character.info.classTertiary = '';
          if (rankTertiaryField) {
            rankTertiaryField.value = '';
            this.character.info.rankTertiary = '';
          }
        }
      }
    }
  },
  
  /**
   * Enable or disable secondary/tertiary class and rank fields
   */
  setMulticlassFieldsEnabled(enabled) {
    const fields = [
      'class-secondary', 'class-tertiary',
      'rank-secondary', 'rank-tertiary'
    ];
    
    fields.forEach(fieldId => {
      const field = document.getElementById(fieldId);
      if (field) {
        field.disabled = !enabled;
        if (enabled) {
          field.classList.remove('field-disabled');
        } else {
          field.classList.add('field-disabled');
        }
      }
    });
  },
  
  /**
   * Update prerequisite key icons on all skills based on current classes
   */
  updatePrereqKeys() {
    if (!window.ClassRankData) return;
    
    const primaryClass = document.getElementById('class-primary')?.value?.trim() || '';
    const secondaryClass = document.getElementById('class-secondary')?.value?.trim() || '';
    const tertiaryClass = document.getElementById('class-tertiary')?.value?.trim() || '';
    
    const primaryRank = parseInt(document.getElementById('rank-primary')?.value, 10) || 0;
    const secondaryRank = parseInt(document.getElementById('rank-secondary')?.value, 10) || 0;
    const tertiaryRank = parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0;
    
    // Update prereq label visibility based on whether classes are selected
    this.updatePrereqLabelVisibility(secondaryClass, tertiaryClass);
    
    // Get rank requirements for each class slot
    const primaryReq = primaryClass ? window.ClassRankData.getNextRankRequirement(primaryRank, 'primary') : null;
    const secondaryReq = secondaryClass ? window.ClassRankData.getNextRankRequirement(secondaryRank, 'secondary') : null;
    const tertiaryReq = tertiaryClass ? window.ClassRankData.getNextRankRequirement(tertiaryRank, 'tertiary') : null;
    
    // Find all prereq-keys containers
    const allPrereqContainers = document.querySelectorAll('.prereq-keys');
    
    allPrereqContainers.forEach(container => {
      const skillName = container.dataset.skillName;
      if (!skillName) {
        container.innerHTML = '';
        return;
      }
      
      const keys = window.ClassRankData.getPrereqKeysForSkill(skillName, primaryClass, secondaryClass, tertiaryClass);
      
      // Build key icons HTML
      let html = '';
      if (keys.primary) {
        const tooltip = primaryReq 
          ? `${primaryClass}: Rank ${primaryReq.nextRank} requires ${primaryReq.skillsNeeded} skills at ${primaryReq.percentRequired}%`
          : `${primaryClass}: Max Rank`;
        html += this.getPrereqKeySvg('gold', tooltip);
      }
      if (keys.secondary) {
        const tooltip = secondaryReq 
          ? `${secondaryClass}: Rank ${secondaryReq.nextRank} requires ${secondaryReq.skillsNeeded} skills at ${secondaryReq.percentRequired}%`
          : `${secondaryClass}: Max Rank`;
        html += this.getPrereqKeySvg('silver', tooltip);
      }
      if (keys.tertiary) {
        const tooltip = tertiaryReq 
          ? `${tertiaryClass}: Rank ${tertiaryReq.nextRank} requires ${tertiaryReq.skillsNeeded} skills at ${tertiaryReq.percentRequired}%`
          : `${tertiaryClass}: Max Rank`;
        html += this.getPrereqKeySvg('blue', tooltip);
      }
      
      container.innerHTML = html;
    });
    
    // Set up click handlers for all prereq keys
    this.setupPrereqKeyClicks();
  },
  
  /**
   * Set up click handlers for prerequisite key icons
   */
  setupPrereqKeyClicks() {
    document.querySelectorAll('.prereq-key[data-key-info]').forEach(key => {
      // Remove existing listener to avoid duplicates
      key.removeEventListener('click', key._clickHandler);
      
      key._clickHandler = (e) => {
        e.stopPropagation();
        const info = key.dataset.keyInfo;
        const color = key.dataset.keyColor;
        
        if (info) {
          this.showKeyPopup(info, color, e);
        }
      };
      
      key.addEventListener('click', key._clickHandler);
    });
  },
  
  /**
   * Show a small popup for prerequisite key info
   */
  showKeyPopup(info, color, event) {
    // Remove existing popup
    const existing = document.getElementById('key-popup');
    if (existing) existing.remove();
    
    // Parse the info string: "ClassName: Rank X requires Y skills at Z%"
    const parts = info.split(':');
    const className = parts[0].trim();
    const details = parts[1]?.trim() || '';
    
    // Determine header color based on key color
    const headerColors = {
      'gold': '#c9a227',
      'silver': '#808080',
      'blue': '#4a90e2'
    };
    const headerColor = headerColors[color] || headerColors.gold;
    
    // Create popup
    const popup = document.createElement('div');
    popup.id = 'key-popup';
    popup.className = 'key-popup';
    popup.innerHTML = `
      <div class="key-popup-header" style="background: ${headerColor};">
        <span>${className} (Class)</span>
        <button class="key-popup-close">&times;</button>
      </div>
      <div class="key-popup-content">
        <p class="key-popup-label">Prerequisite Skill</p>
        <p class="key-popup-details">${details}</p>
      </div>
    `;
    
    document.body.appendChild(popup);
    
    // Position near the clicked key
    const rect = event.target.closest('.prereq-key').getBoundingClientRect();
    const popupRect = popup.getBoundingClientRect();
    
    let left = rect.left + rect.width / 2 - popupRect.width / 2;
    let top = rect.bottom + 8;
    
    // Keep within viewport
    if (left < 10) left = 10;
    if (left + popupRect.width > window.innerWidth - 10) {
      left = window.innerWidth - popupRect.width - 10;
    }
    if (top + popupRect.height > window.innerHeight - 10) {
      top = rect.top - popupRect.height - 8;
    }
    
    popup.style.left = left + 'px';
    popup.style.top = top + 'px';
    
    // Close handlers
    const closeBtn = popup.querySelector('.key-popup-close');
    closeBtn.addEventListener('click', () => popup.remove());
    
    // Close when clicking outside
    setTimeout(() => {
      const outsideClickHandler = (e) => {
        if (!popup.contains(e.target) && !e.target.closest('.prereq-key')) {
          popup.remove();
          document.removeEventListener('click', outsideClickHandler);
        }
      };
      document.addEventListener('click', outsideClickHandler);
    }, 10);
    
    // Close on Escape
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        popup.remove();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  },
  
  /**
   * Update visibility of prereq label links based on whether classes are selected
   * Hide "Subclass 1 Prereq. Skill" if no secondary class
   * Hide "Subclass 2 Prereq. Skill" if no tertiary class
   */
  updatePrereqLabelVisibility(secondaryClass, tertiaryClass) {
    // Get the prereq row containers (the whole row with key icon + label)
    const secondaryLabel = document.getElementById('prereq-label-secondary');
    const tertiaryLabel = document.getElementById('prereq-label-tertiary');
    
    // Get parent prereq-row elements
    const secondaryRow = secondaryLabel?.closest('.prereq-row');
    const tertiaryRow = tertiaryLabel?.closest('.prereq-row');
    
    // Show/hide based on whether class is selected
    if (secondaryRow) {
      secondaryRow.style.display = secondaryClass ? '' : 'none';
    }
    if (tertiaryRow) {
      tertiaryRow.style.display = tertiaryClass ? '' : 'none';
    }
  },
  
  /**
   * Setup click handlers for prerequisite skill labels
   */
  setupPrereqLabelClicks() {
    const labels = document.querySelectorAll('.prereq-label.clickable');
    labels.forEach(label => {
      label.addEventListener('click', () => {
        const classSlot = label.dataset.classSlot;
        this.showPrereqStatus(classSlot);
      });
    });
  },
  
  /**
   * Show prerequisite skill status popup for a class slot
   */
  showPrereqStatus(classSlot) {
    if (!window.ClassRankData) return;
    
    // Get class name and rank for this slot
    const classInput = document.getElementById(`class-${classSlot}`);
    const rankInput = document.getElementById(`rank-${classSlot}`);
    
    const className = classInput?.value?.trim() || '';
    const currentRank = parseInt(rankInput?.value, 10) || 0;
    
    if (!className) {
      this.showPrereqModal('No Class Selected', '<p>No class selected for this slot.</p>');
      return;
    }
    
    // Get next rank requirement
    const req = window.ClassRankData.getNextRankRequirement(currentRank, classSlot);
    
    if (!req) {
      this.showPrereqModal(`${className} - Max Rank`, `<p>${className} is at maximum rank (Rank 5).</p>`);
      return;
    }
    
    // Get prereq skills for this class
    const prereqSkills = window.ClassRankData.getPrereqSkillsForClass(className);
    
    if (!prereqSkills || prereqSkills.length === 0) {
      this.showPrereqModal(`${className}`, `<p>No prerequisite skills defined for ${className}.</p>`);
      return;
    }
    
    // Collect current skill values from the character sheet
    const skillStatus = this.getPrereqSkillStatus(prereqSkills, req.percentRequired);
    
    // Build HTML content
    const slotName = classSlot === 'primary' ? 'Class' : 
                     classSlot === 'secondary' ? 'Subclass 1' : 'Subclass 2';
    
    const metCount = skillStatus.filter(s => s.met).length;
    const metSkills = skillStatus.filter(s => s.met);
    const unmetSkills = skillStatus.filter(s => !s.met);
    
    let html = `
      <div class="prereq-info">
        <p><strong>Current Rank:</strong> ${currentRank}</p>
        <p><strong>Next Rank:</strong> ${req.nextRank}</p>
        <p><strong>Requires:</strong> ${req.skillsNeeded} skills at ${req.percentRequired}%</p>
      </div>
      <div class="prereq-progress ${metCount >= req.skillsNeeded ? 'ready' : ''}">
        Progress: ${metCount}/${req.skillsNeeded} skills met
        ${metCount >= req.skillsNeeded ? ' ★ READY TO ADVANCE! ★' : ''}
      </div>
    `;
    
    if (metSkills.length > 0) {
      html += `<div class="prereq-section met">
        <h4>✓ Skills at ${req.percentRequired}%+</h4>
        <ul>`;
      metSkills.forEach(s => {
        html += `<li><span class="skill-name">${s.name}</span><span class="skill-value">${s.value}%</span></li>`;
      });
      html += `</ul></div>`;
    }
    
    if (unmetSkills.length > 0) {
      html += `<div class="prereq-section unmet">
        <h4>✗ Skills below ${req.percentRequired}%</h4>
        <ul>`;
      unmetSkills.forEach(s => {
        const needed = req.percentRequired - s.value;
        html += `<li><span class="skill-name">${s.name}</span><span class="skill-value">${s.value}% <span class="needed">(need +${needed}%)</span></span></li>`;
      });
      html += `</ul></div>`;
    }
    
    this.showPrereqModal(`${className} (${slotName})`, html);
  },
  
  /**
   * Show a modal dialog for prerequisite skill status
   */
  showPrereqModal(title, content) {
    // Remove existing modal if present
    const existing = document.getElementById('prereq-modal');
    if (existing) existing.remove();
    
    // Create modal
    const modal = document.createElement('div');
    modal.id = 'prereq-modal';
    modal.className = 'prereq-modal-overlay';
    modal.innerHTML = `
      <div class="prereq-modal">
        <div class="prereq-modal-header">
          <h3>${title}</h3>
          <button class="prereq-modal-close">&times;</button>
        </div>
        <div class="prereq-modal-content">
          ${content}
        </div>
      </div>
    `;
    
    document.body.appendChild(modal);
    
    // Close handlers
    const closeBtn = modal.querySelector('.prereq-modal-close');
    closeBtn.addEventListener('click', () => modal.remove());
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
    
    // Close on Escape
    const escHandler = (e) => {
      if (e.key === 'Escape') {
        modal.remove();
        document.removeEventListener('keydown', escHandler);
      }
    };
    document.addEventListener('keydown', escHandler);
  },
  
  /**
   * Get current values of prerequisite skills
   */
  getPrereqSkillStatus(prereqSkills, requiredPercent) {
    const status = [];
    
    // Define which skills are standard skills (not professional)
    const standardSkillMap = {
      'athletics': 'athletics',
      'boating': 'boating',
      'brawn': 'brawn',
      'conceal': 'conceal',
      'customs': 'customs',
      'dance': 'dance',
      'deceit': 'deceit',
      'drive': 'drive',
      'endurance': 'endurance',
      'evade': 'evade',
      'first aid': 'first-aid',
      'influence': 'influence',
      'insight': 'insight',
      'locale': 'locale',
      'perception': 'perception',
      'ride': 'ride',
      'sing': 'sing',
      'stealth': 'stealth',
      'swim': 'swim',
      'willpower': 'willpower'
    };
    
    // Combat page skills use -percent suffix instead of -current
    const combatSkillMap = {
      'unarmed': 'unarmed-percent',
      'combat skill': 'combat-skill-1-percent'
    };
    
    prereqSkills.forEach(skillName => {
      const normalizedSkill = skillName.toLowerCase().trim();
      let skillValue = 0;
      let found = false;
      
      // 1. Check combat page skills first (Unarmed, Combat Skill)
      const combatSkillId = combatSkillMap[normalizedSkill];
      if (combatSkillId) {
        const input = document.getElementById(combatSkillId);
        skillValue = parseInt(input?.value, 10) || 0;
        found = true;
      }
      
      // 2. Check if it's a known standard skill
      if (!found) {
        const standardSkillId = standardSkillMap[normalizedSkill];
        if (standardSkillId) {
          // The -current input contains the TOTAL skill value, not points added
          const currentInput = document.getElementById(`${standardSkillId}-current`);
          skillValue = parseInt(currentInput?.value, 10) || 0;
          found = true;
        }
      }
      
      // 3. Check if it's a known magic skill
      if (!found) {
        const magicSkillMap = {
          'channel': 'channel-percent',
          'piety': 'piety-percent',
          'arcane casting': 'arcane-casting-percent',
          'arcane knowledge': 'arcane-knowledge-percent',
          'arcane sorcery': 'arcane-sorcery-percent',
          'sorcerous wisdom': 'sorcerous-wisdom-percent',
          'musicianship': 'musicianship-percent',
          'lyrical magic': 'lyrical-magic-percent'
        };
        
        const inputId = magicSkillMap[normalizedSkill];
        if (inputId) {
          const input = document.getElementById(inputId);
          skillValue = parseInt(input?.value, 10) || 0;
          found = true;
        }
      }
      
      // 4. Check professional skills for exact match
      if (!found) {
        for (let i = 0; i < 20; i++) {
          const nameInput = document.getElementById(`prof-skill-${i}-name`);
          const currentInput = document.getElementById(`prof-skill-${i}-current`);
          
          if (nameInput) {
            const name = nameInput.value?.trim().toLowerCase() || '';
            // Exact match only for professional skills
            if (name === normalizedSkill) {
              // Professional skill -current is the TOTAL
              skillValue = parseInt(currentInput?.value, 10) || 0;
              found = true;
              break;
            }
          }
        }
      }
      
      // 5. Check professional skills for partial match (e.g., "Lore" matching "Lore (History)")
      // Skills that can have specializations in parentheses
      const partialMatchSkills = ['lore', 'art', 'craft', 'musicianship'];
      if (!found && partialMatchSkills.includes(normalizedSkill)) {
        for (let i = 0; i < 20; i++) {
          const nameInput = document.getElementById(`prof-skill-${i}-name`);
          const currentInput = document.getElementById(`prof-skill-${i}-current`);
          
          if (nameInput) {
            const name = nameInput.value?.trim().toLowerCase() || '';
            // Check if the base name (before parenthesis) matches
            const baseName = name.split('(')[0].trim();
            if (baseName === normalizedSkill) {
              const total = parseInt(currentInput?.value, 10) || 0;
              // Take the highest value if multiple matches
              if (total > skillValue) {
                skillValue = total;
                found = true;
              }
            }
          }
        }
      }
      
      status.push({
        name: skillName,
        value: skillValue,
        met: skillValue >= requiredPercent
      });
    });
    
    // Sort: met skills first, then by value descending
    status.sort((a, b) => {
      if (a.met !== b.met) return b.met - a.met;
      return b.value - a.value;
    });
    
    return status;
  },
  
  /**
   * Update magic page and row visibility based on selected classes
   */
  updateMagicVisibility() {
    // Define which classes use which magic types
    const DIVINE_CLASSES = ['cleric', 'ranger', 'paladin', 'anti-paladin', 'druid'];
    const MAGE_CLASSES = ['mage'];
    const SORCERER_CLASSES = ['sorcerer'];
    const BARD_CLASSES = ['bard'];
    
    // Check if Syrin (Syrin cannot be Mages or Sorcerers)
    const species = document.getElementById('species')?.value?.trim().toLowerCase() || '';
    const isSyrin = species === 'syrin';
    
    // Get all selected classes (normalized to lowercase)
    const classes = [
      document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || ''
    ].filter(c => c);
    
    // If no classes selected, show everything (default state) but respect Syrin restrictions
    if (classes.length === 0) {
      document.querySelectorAll('.magic-class-divine, .magic-class-bard').forEach(row => {
        row.style.display = '';
      });
      // Mage and Sorcerer rows hidden for Syrin
      document.querySelectorAll('.magic-class-mage, .magic-class-sorcerer').forEach(row => {
        row.style.display = isSyrin ? 'none' : '';
      });
      document.querySelectorAll('.tab-btn[data-page="magic1"], .tab-btn[data-page="magic2"]').forEach(tab => {
        tab.parentElement.style.display = '';
      });
      return;
    }
    
    // Check which magic types are needed
    const needsDivine = classes.some(c => DIVINE_CLASSES.includes(c));
    // Syrin cannot be Mages or Sorcerers
    const needsMage = !isSyrin && classes.some(c => MAGE_CLASSES.includes(c));
    const needsSorcerer = !isSyrin && classes.some(c => SORCERER_CLASSES.includes(c));
    const needsBard = classes.some(c => BARD_CLASSES.includes(c));
    
    // Check if any magic is needed
    const needsAnyMagic = needsDivine || needsMage || needsSorcerer || needsBard;
    
    // Show/hide magic skill rows
    const divineRows = document.querySelectorAll('.magic-class-divine');
    const mageRows = document.querySelectorAll('.magic-class-mage');
    const sorcererRows = document.querySelectorAll('.magic-class-sorcerer');
    const bardRows = document.querySelectorAll('.magic-class-bard');
    
    divineRows.forEach(row => row.style.display = needsDivine ? '' : 'none');
    mageRows.forEach(row => row.style.display = needsMage ? '' : 'none');
    sorcererRows.forEach(row => row.style.display = needsSorcerer ? '' : 'none');
    bardRows.forEach(row => row.style.display = needsBard ? '' : 'none');
    
    // Show/hide magic page tabs
    const magicTabs = document.querySelectorAll('.tab-btn[data-page="magic1"], .tab-btn[data-page="magic2"]');
    magicTabs.forEach(tab => {
      tab.parentElement.style.display = needsAnyMagic ? '' : 'none';
    });
    
    // If currently on a magic page and no magic is needed, switch to main page
    if (!needsAnyMagic) {
      const activePage = document.querySelector('.sheet-page.active');
      if (activePage && (activePage.id === 'page-magic1' || activePage.id === 'page-magic2')) {
        // Switch to main page
        document.querySelectorAll('.sheet-page').forEach(p => p.classList.remove('active'));
        document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
        document.getElementById('page-main')?.classList.add('active');
        document.querySelector('.tab-btn[data-page="main"]')?.classList.add('active');
      }
    }
  },
  
  /**
   * Update spell memorization limits based on class, rank, and INT
   */
  updateSpellMemorization() {
    if (!window.ClassRankData) return;
    
    // Get INT value
    const intInput = document.getElementById('int-value');
    const intValue = parseInt(intInput?.value, 10) || 0;
    
    // Get all classes and ranks
    const classes = [
      {
        className: document.getElementById('class-primary')?.value?.trim() || '',
        classRank: parseInt(document.getElementById('rank-primary')?.value, 10) || 0
      },
      {
        className: document.getElementById('class-secondary')?.value?.trim() || '',
        classRank: parseInt(document.getElementById('rank-secondary')?.value, 10) || 0
      },
      {
        className: document.getElementById('class-tertiary')?.value?.trim() || '',
        classRank: parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0
      }
    ].filter(c => c.className);
    
    // Get combined spell memorization
    const spellLimits = window.ClassRankData.getCombinedSpellMemorization(classes, intValue);
    
    // Update the "May Memorize X Spells" inputs
    const spellRankMapping = {
      'cantrips': 'cantrips-max',
      'rank1': 'rank1-max',
      'rank2': 'rank2-max',
      'rank3': 'rank3-max',
      'rank4': 'rank4-max',
      'rank5': 'rank5-max'
    };
    
    for (const [spellRank, inputId] of Object.entries(spellRankMapping)) {
      const input = document.getElementById(inputId);
      if (input) {
        const limit = spellLimits[spellRank];
        if (limit !== undefined) {
          input.value = limit;
        } else {
          input.value = 0;
        }
      }
    }
    
    // Hide/show spell columns based on memorization values
    this.updateSpellColumnVisibility();
    
    // Hide/show Ranks 3-5 tab based on whether any rank 3-5 spells are available
    this.updateMagic2TabVisibility();
    
    // Update prereq keys on magic skills
    this.updateMagicPrereqKeys();
  },
  
  /**
   * Hide spell columns that have 0 memorization
   */
  updateSpellColumnVisibility() {
    const columnMapping = {
      'cantrips': '.spell-column.cantrips',
      'rank1': '.spell-column.rank1',
      'rank2': '.spell-column.rank2',
      'rank3': '.spell-column.rank3',
      'rank4': '.spell-column.rank4',
      'rank5': '.spell-column.rank5'
    };
    
    for (const [rank, selector] of Object.entries(columnMapping)) {
      const maxInput = document.getElementById(`${rank}-max`);
      const column = document.querySelector(selector);
      if (maxInput && column) {
        const maxVal = parseInt(maxInput.value, 10) || 0;
        if (maxVal === 0) {
          column.style.display = 'none';
        } else {
          column.style.display = '';
        }
      }
    }
  },
  
  /**
   * Hide Ranks 3-5 Spells tab if all rank 3, 4, 5 memorization is 0
   */
  updateMagic2TabVisibility() {
    const rank3Max = parseInt(document.getElementById('rank3-max')?.value, 10) || 0;
    const rank4Max = parseInt(document.getElementById('rank4-max')?.value, 10) || 0;
    const rank5Max = parseInt(document.getElementById('rank5-max')?.value, 10) || 0;
    
    const magic2Tab = document.querySelector('.tab-btn[data-page="magic2"]');
    if (magic2Tab) {
      if (rank3Max === 0 && rank4Max === 0 && rank5Max === 0) {
        magic2Tab.style.display = 'none';
        // If currently on magic2 page, switch to magic1
        if (magic2Tab.classList.contains('active')) {
          const magic1Tab = document.querySelector('.tab-btn[data-page="magic1"]');
          if (magic1Tab) {
            magic1Tab.click();
          }
        }
      } else {
        magic2Tab.style.display = '';
      }
    }
  },
  
  /**
   * Update prereq keys on magic casting and knowledge skills
   */
  updateMagicPrereqKeys() {
    if (!window.ClassRankData) return;
    
    // Get current classes and ranks
    const primaryClass = document.getElementById('class-primary')?.value?.trim() || '';
    const secondaryClass = document.getElementById('class-secondary')?.value?.trim() || '';
    const tertiaryClass = document.getElementById('class-tertiary')?.value?.trim() || '';
    
    const primaryRank = parseInt(document.getElementById('rank-primary')?.value, 10) || 0;
    const secondaryRank = parseInt(document.getElementById('rank-secondary')?.value, 10) || 0;
    const tertiaryRank = parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0;
    
    // Get rank requirements for each class slot
    const primaryReq = primaryClass ? window.ClassRankData.getNextRankRequirement(primaryRank, 'primary') : null;
    const secondaryReq = secondaryClass ? window.ClassRankData.getNextRankRequirement(secondaryRank, 'secondary') : null;
    const tertiaryReq = tertiaryClass ? window.ClassRankData.getNextRankRequirement(tertiaryRank, 'tertiary') : null;
    
    // Mapping of magic skill to classes that use it (both casting and knowledge skills)
    const skillClassMapping = {
      'channel': ['cleric', 'druid', 'paladin', 'ranger', 'anti-paladin'],
      'piety': ['cleric', 'druid', 'paladin', 'ranger', 'anti-paladin'],
      'arcane-casting': ['mage', 'magic-user'],
      'arcane-knowledge': ['mage', 'magic-user'],
      'arcane-sorcery': ['sorcerer'],
      'sorcerous-wisdom': ['sorcerer'],
      'musicianship': ['bard'],
      'lyrical-magic': ['bard']
    };
    
    // Clear all prereq key slots first
    document.querySelectorAll('.prereq-key-slot').forEach(slot => {
      slot.innerHTML = '';
    });
    
    // Helper to get tooltip for a class
    const getTooltip = (className, rank, req, keyColor) => {
      const colorName = keyColor === 'gold' ? 'Gold' : (keyColor === 'silver' ? 'Silver' : 'Blue');
      if (req) {
        return `${className}: Rank ${req.nextRank} requires ${req.percentRequired}% (${colorName})`;
      } else {
        return `${className}: Max Rank (${colorName})`;
      }
    };
    
    // Process each class
    const classData = [
      { className: primaryClass, rank: primaryRank, req: primaryReq, keyColor: 'gold' },
      { className: secondaryClass, rank: secondaryRank, req: secondaryReq, keyColor: 'silver' },
      { className: tertiaryClass, rank: tertiaryRank, req: tertiaryReq, keyColor: 'blue' }
    ];
    
    classData.forEach(({ className, rank, req, keyColor }) => {
      if (!className) return;
      
      const normalized = window.ClassRankData.normalizeClassName(className);
      
      for (const [skill, classesForSkill] of Object.entries(skillClassMapping)) {
        if (classesForSkill.includes(normalized)) {
          const tooltip = getTooltip(className, rank, req, keyColor);
          
          // Add to both page 1 and page 2
          document.querySelectorAll(`.prereq-key-slot[data-skill="${skill}"]`).forEach(slot => {
            slot.innerHTML += this.getPrereqKeySvg(keyColor, tooltip);
          });
        }
      }
    });
    
    // Set up click handlers for the dynamically added keys
    this.setupPrereqKeyClicks();
  },
  
  /**
   * Update spell fill/clear buttons when class or rank changes
   * Instead of auto-populating, we show buttons that let the user choose when to fill
   */
  updateClassSpells(previousClasses = null) {
    // Only clear spells when an existing spellcasting class was CHANGED or REMOVED.
    // Adding a new spellcasting class to a previously empty slot does NOT clear spells.
    if (previousClasses) {
      const currentClasses = [
        document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
        document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
        document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || ''
      ];
      const prevNames = previousClasses.map(c => (c.name || '').toLowerCase());

      // Check if an existing spellcasting class was replaced or removed
      // "Replaced" means: a slot that previously had a spellcasting class now has a DIFFERENT value
      // "Added" means: a slot that was empty now has a value — this should NOT trigger clearing
      const casterClasses = ['cleric', 'mage', 'sorcerer', 'bard', 'druid', 'paladin', 'ranger', 'anti-paladin', 'magic-user'];
      let existingCasterChanged = false;

      for (let i = 0; i < 3; i++) {
        const prev = prevNames[i] || '';
        const curr = currentClasses[i] || '';
        // Only counts as a "change" if the slot was previously occupied by a spellcasting class
        // AND the new value is different (including empty = class was removed)
        if (prev && prev !== curr) {
          const wasCaster = casterClasses.some(cc => prev.includes(cc));
          if (wasCaster) {
            existingCasterChanged = true;
            break;
          }
        }
      }

      if (existingCasterChanged) {
        const rankKeys = ['cantrips', 'rank1', 'rank2', 'rank3', 'rank4', 'rank5'];
        rankKeys.forEach(rankKey => {
          const tbody = document.getElementById(`${rankKey}-body`);
          if (tbody && tbody.rows.length > 0) {
            tbody.innerHTML = '';
          }
        });
        // Also reset memorization max fields
        rankKeys.forEach(rankKey => {
          const maxInput = document.getElementById(`${rankKey}-max`);
          if (maxInput) maxInput.value = '';
        });
        // Clear saved spell data
        if (this.character.magic && this.character.magic.spells) {
          rankKeys.forEach(rankKey => {
            if (this.character.magic.spells[rankKey]) {
              this.character.magic.spells[rankKey].spells = [];
              this.character.magic.spells[rankKey].max = '';
            }
          });
        }
        console.log('Spellcasting class changed — cleared all spells and memorization');
      } else {
        console.log('New spellcasting class added or non-caster changed — spells preserved');
      }
    }
    
    this.updateSpellFillButtons();
  },
  
  /**
   * Update the spell fill/clear buttons for each spell rank
   * Shows "Fill [Class] Spells" buttons for each spell-granting class that has access to that rank
   * Shows "Clear All" button if any spells exist in that rank
   */
  updateSpellFillButtons() {
    if (!window.ClassSpellLists) return;
    
    const rankKeys = ['cantrips', 'rank1', 'rank2', 'rank3', 'rank4', 'rank5'];
    
    // Get current spell-granting classes and their max spell ranks
    const currentClasses = [
      {
        name: document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
        rank: parseInt(document.getElementById('rank-primary')?.value, 10) || 0
      },
      {
        name: document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
        rank: parseInt(document.getElementById('rank-secondary')?.value, 10) || 0
      },
      {
        name: document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || '',
        rank: parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0
      }
    ].filter(c => c.name && window.ClassSpellLists.isSpellGrantingClass(c.name));
    
    // Class display names and icons for buttons
    const classDisplay = {
      cleric: { label: 'Cleric', icon: '✝️' },
      druid: { label: 'Druid', icon: '🌿' },
      paladin: { label: 'Paladin', icon: '🛡️' },
      ranger: { label: 'Ranger', icon: '🏹' }
    };
    
    rankKeys.forEach((rankKey, rankIndex) => {
      // Find or create the actions bar for this rank
      const spellColumn = document.querySelector(`.spell-column.${rankKey === 'cantrips' ? 'cantrips' : rankKey}`);
      if (!spellColumn) return;
      
      let actionsBar = spellColumn.querySelector('.spell-actions-bar');
      if (!actionsBar) {
        actionsBar = document.createElement('div');
        actionsBar.className = 'spell-actions-bar';
        // Insert after memorize-count
        const memorizeCount = spellColumn.querySelector('.memorize-count');
        if (memorizeCount) {
          memorizeCount.after(actionsBar);
        } else {
          // Fallback: insert before the table
          const table = spellColumn.querySelector('.spell-table');
          if (table) table.before(actionsBar);
        }
      }
      
      // Determine which classes have access to this spell rank
      const availableClasses = currentClasses.filter(c => {
        const maxSpellRank = window.ClassSpellLists.getMaxSpellRank(c.name, c.rank);
        return maxSpellRank >= rankIndex;
      });
      
      // Check if there's class spell data for this rank
      const classesWithSpells = availableClasses.filter(c => {
        const classList = window.ClassSpellLists[c.name];
        return classList && classList[rankKey] && classList[rankKey].length > 0;
      });
      
      // Build button HTML - always start with Add Spell button
      let buttonsHTML = `<button type="button" class="btn btn-small btn-add-spell" data-rank="${rankKey}" title="Add an empty spell row">+ Add Spell</button>`;
      
      classesWithSpells.forEach(c => {
        const display = classDisplay[c.name] || { label: this.toTitleCase(c.name), icon: '📖' };
        buttonsHTML += `<button type="button" class="btn btn-small btn-fill-spells" data-class="${c.name}" data-rank="${rankKey}" title="Fill with ${display.label} spells">${display.icon} Fill ${display.label}</button>`;
      });
      
      // Show Clear All if there are any rows
      const tbody = document.getElementById(`${rankKey}-body`);
      const hasRows = tbody && tbody.rows.length > 0;
      if (hasRows) {
        buttonsHTML += `<button type="button" class="btn btn-small btn-clear-spells" data-rank="${rankKey}" title="Clear all spells in this rank">🗑️ Clear All</button>`;
      }
      
      actionsBar.innerHTML = buttonsHTML;
      
      // Bar is always visible (always has at least the + button)
      actionsBar.style.display = '';
      
      // Attach event listeners
      actionsBar.querySelector('.btn-add-spell').addEventListener('click', () => {
        this.addSpellRow(rankKey);
        this.scheduleAutoSave();
        this.updateSpellFillButtons();
      });
      
      actionsBar.querySelectorAll('.btn-fill-spells').forEach(btn => {
        btn.addEventListener('click', () => {
          const className = btn.dataset.class;
          const rank = btn.dataset.rank;
          this.fillClassSpellsForRank(className, rank);
        });
      });
      
      const clearBtn = actionsBar.querySelector('.btn-clear-spells');
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          const rank = clearBtn.dataset.rank;
          this.clearSpellsInRank(rank);
        });
      }
    });
  },
  
  /**
   * Fill a specific spell rank with spells from a specific class
   * Only fills empty slots; skips duplicates
   */
  fillClassSpellsForRank(className, rankKey) {
    if (!window.ClassSpellLists || !window.SpellData) return;
    
    const classList = window.ClassSpellLists[className.toLowerCase()];
    if (!classList || !classList[rankKey]) return;
    
    const spellsToAdd = classList[rankKey];
    const existingSpells = this.getExistingSpellsInRank(rankKey);
    
    let addedCount = 0;
    
    spellsToAdd.forEach(spellName => {
      // Skip if spell already exists in this rank
      if (existingSpells.some(s => s.toLowerCase() === spellName.toLowerCase())) {
        return;
      }
      
      // Get cost for the spell
      const cost = window.SpellData.getSpellCost(spellName);
      
      this.addSpellRow(rankKey, {
        name: spellName,
        cost: cost || '',
        memorized: false,
        classSpell: className.toLowerCase()
      });
      
      addedCount++;
    });
    
    if (addedCount > 0) {
      console.log(`Filled ${addedCount} ${this.toTitleCase(className)} spells into ${rankKey}`);
      this.scheduleAutoSave();
    }
    
    // Refresh buttons
    this.updateSpellFillButtons();
  },
  
  /**
   * Clear all spells in a specific rank with confirmation
   */
  clearSpellsInRank(rankKey) {
    const tbody = document.getElementById(`${rankKey}-body`);
    if (!tbody || tbody.rows.length === 0) return;
    
    const spellCount = tbody.rows.length;
    const rankLabel = rankKey === 'cantrips' ? 'Cantrips' : `Rank ${rankKey.replace('rank', '')} Spells`;
    if (!confirm(`Clear all ${spellCount} spell(s) from ${rankLabel}?\n\nThis will remove all spells, costs, and memorized flags in this rank.`)) {
      return;
    }
    
    tbody.innerHTML = '';
    
    console.log(`Cleared all spells from ${rankKey}`);
    this.scheduleAutoSave();
    
    // Refresh buttons (Clear All may need to hide)
    this.updateSpellFillButtons();
  },
  
  /**
   * Cast a spell - deducts magic point cost from current MP
   */
  // =========================================================================
  //  SPELL CASTING MODAL
  // =========================================================================

  /**
   * State object for the casting modal
   */
  _castModal: {
    rankKey: null,
    slotIndex: null,
    spellName: '',
    spellDetails: null,
    classSource: '',
    castingType: '',
    castingSkillId: '',
    castingSkillPercent: 0,
    effectiveSkill: 0,
    intensity: 1,
    maxIntensity: 1,
    spellRank: 0,
    casterRank: 1,
    cost: 1,
    armorRestriction: null,
    hasRolled: false,
    rollResult: null,
    matchingClasses: [],
    selectedClassIndex: 0,
    // Non-memorized casting
    isNonMemorized: false,
    nonMemDifficulty: '',      // 'hard', 'formidable', 'herculean'
    nonMemPenalty: 0,          // -20, -40, -60
    nonMemSkillName: '',       // Override skill name (e.g. 'Piety' for divine)
    nonMemSkillId: '',         // Override skill ID
    nonMemSkillPercent: 0      // Override skill value
  },

  /**
   * Open the casting modal for a spell (replaces old castSpell)
   */
  castSpell(rankKey, slotIndex) {
    console.log(`castSpell called: ${rankKey}, ${slotIndex}`);
    const nameInput = document.getElementById(`${rankKey}-${slotIndex}-name`);
    if (!nameInput || !nameInput.value.trim()) {
      console.log('castSpell: no name found, aborting');
      return;
    }

    try {
      const spellName = nameInput.value.trim();
      const costInput = document.getElementById(`${rankKey}-${slotIndex}-cost`);
      const costStr = costInput?.value?.trim() || '';
      const classSpell = nameInput.dataset.classSpell || '';
      console.log(`castSpell: ${spellName}, cost=${costStr}, class=${classSpell}`);

      // Reset modal state
      const m = this._castModal;
      m.rankKey = rankKey;
      m.slotIndex = slotIndex;
      m.spellName = spellName;
      m.hasRolled = false;
      m.rollResult = null;
      m.intensity = 1;
      m.costStr = costStr;

      // Check memorized state — use row-based query for robustness
      // (IDs can desync after row removal/reindex; querySelector on the actual row is most reliable)
      const spellTbody = document.getElementById(`${rankKey}-body`);
      const spellRow = spellTbody?.rows[slotIndex];
      const memCheckByRow = spellRow?.querySelector('.spell-memorized');
      const memCheckById = document.getElementById(`${rankKey}-${slotIndex}-mem`);
      const memCheck = memCheckByRow || memCheckById;
      m.isNonMemorized = memCheck ? !memCheck.checked : false;
      console.log(`%c[CAST] memCheck: byRow=${!!memCheckByRow} byId=${!!memCheckById} checked=${memCheck?.checked} → isNonMemorized=${m.isNonMemorized}`, 'color: #c87832; font-weight: bold');
      if (memCheckByRow && memCheckById && memCheckByRow !== memCheckById) {
        console.warn('[CAST] WARNING: Row-based and ID-based checkbox are DIFFERENT elements! Row says checked=' + memCheckByRow.checked + ', ID says checked=' + memCheckById.checked);
      }

      // Determine spell rank number
      m.spellRank = rankKey === 'cantrips' ? 0 : parseInt(rankKey.replace('rank', ''), 10) || 0;

      // Look up spell details
      const L = window.SpellDetailsLookup;
      m.spellDetails = L ? L.get(spellName) : null;
      console.log(`castSpell: SpellDetailsLookup=${!!L}, details found=${!!m.spellDetails}`);

      // Determine casting class and skill
      this._determineCastingInfo(m, classSpell, costStr);
      console.log(`%c[CAST] FINAL: class=${m.classSource}, type=${m.castingType}, baseSkill=${m.castingSkillPercent}, effectiveSkill=${m.effectiveSkill}%, nonMem=${m.isNonMemorized}, penalty=${m.nonMemPenalty}, difficulty="${m.nonMemDifficulty}"`, 'color: #2a9d8f; font-weight: bold');

      // Populate and show modal
      this._populateCastModal(m, costStr);
      this._showCastModal();
      console.log('castSpell: modal shown');
    } catch (err) {
      console.error('castSpell ERROR:', err);
      // Show visual error on the cast button
      const castBtn = document.getElementById(`${rankKey}-${slotIndex}-cast`);
      if (castBtn) {
        castBtn.classList.add('cast-fail');
        castBtn.title = 'Error: ' + err.message;
        setTimeout(() => castBtn.classList.remove('cast-fail'), 2000);
      }
    }
  },

  /**
   * Determine casting class, skill, rank, and armor restrictions.
   * Finds ALL matching casting classes for multiclass support.
   */
  _determineCastingInfo(m, classSpell, costStr) {
    const L = window.SpellDetailsLookup;
    const casterClassTypes = ['cleric', 'mage', 'sorcerer', 'bard', 'druid', 'paladin', 'ranger', 'anti-paladin'];

    // Gather character's classes with ranks
    const charClasses = [
      { field: 'class-primary', rankField: 'rank-primary' },
      { field: 'class-secondary', rankField: 'rank-secondary' },
      { field: 'class-tertiary', rankField: 'rank-tertiary' }
    ].map(c => ({
      name: document.getElementById(c.field)?.value?.trim() || '',
      rank: parseInt(document.getElementById(c.rankField)?.value, 10) || 0
    })).filter(c => c.name);

    // Find which of the character's classes can cast this spell
    m.matchingClasses = [];
    const spellDetails = m.spellDetails;

    for (const cc of charClasses) {
      const ccNorm = cc.name.toLowerCase();
      const isCaster = casterClassTypes.some(ct => ccNorm.includes(ct));
      if (!isCaster) continue;

      let matches = false;

      // Method 1: Check spell-details-data classes array
      if (spellDetails?.classes) {
        matches = spellDetails.classes.some(sc =>
          sc.class.toLowerCase() === ccNorm ||
          ccNorm.includes(sc.class.toLowerCase()) ||
          sc.class.toLowerCase().includes(ccNorm)
        );
      }

      // Method 2: Check class-spells-data
      if (!matches && window.ClassSpellLists) {
        matches = window.ClassSpellLists.hasSpell(cc.name, m.spellName);
      }

      // Method 3: If classSpell dataset matches this class
      if (!matches && classSpell) {
        matches = ccNorm.includes(classSpell.toLowerCase()) || classSpell.toLowerCase().includes(ccNorm);
      }

      if (matches) {
        m.matchingClasses.push({
          name: cc.name,
          rank: cc.rank,
          castingType: L ? L.getCastingType(cc.name) : 'arcane',
          castingSkillId: L ? L.getCastingSkillId(cc.name) : 'arcane-casting-percent',
          castingSkillName: L ? L.getCastingSkillName(cc.name) : 'Casting Skill'
        });
      }
    }

    // If no matches found, fall back to classSpell or first caster class
    if (m.matchingClasses.length === 0) {
      let fallback = null;
      if (classSpell) {
        fallback = charClasses.find(c => c.name.toLowerCase().includes(classSpell.toLowerCase()));
      }
      if (!fallback) {
        fallback = charClasses.find(c => casterClassTypes.some(ct => c.name.toLowerCase().includes(ct)));
      }
      if (fallback) {
        m.matchingClasses.push({
          name: fallback.name,
          rank: fallback.rank,
          castingType: L ? L.getCastingType(fallback.name) : 'arcane',
          castingSkillId: L ? L.getCastingSkillId(fallback.name) : 'arcane-casting-percent',
          castingSkillName: L ? L.getCastingSkillName(fallback.name) : 'Casting Skill'
        });
      }
    }

    // Select the first matching class (or the one from classSpell dataset if present)
    let selectedIndex = 0;
    if (classSpell && m.matchingClasses.length > 1) {
      const prefIdx = m.matchingClasses.findIndex(mc =>
        mc.name.toLowerCase().includes(classSpell.toLowerCase()) ||
        classSpell.toLowerCase().includes(mc.name.toLowerCase())
      );
      if (prefIdx >= 0) selectedIndex = prefIdx;
    }

    m.selectedClassIndex = selectedIndex;
    this._applySelectedClass(m);
  },

  /**
   * Apply the currently selected casting class to the modal state
   */
  _applySelectedClass(m) {
    const L = window.SpellDetailsLookup;
    const sel = m.matchingClasses[m.selectedClassIndex] || m.matchingClasses[0];

    if (!sel) {
      m.classSource = '';
      m.casterRank = 1;
      m.castingType = 'arcane';
      m.castingSkillPercent = 50;
      m.maxIntensity = 1;
      m.armorRestriction = { canCast: true, penalty: null, reason: null };
      m.effectiveSkill = 50;
      return;
    }

    m.classSource = sel.name;
    m.casterRank = sel.rank;
    m.castingType = sel.castingType;
    m.castingSkillId = sel.castingSkillId;

    const skillEl = document.getElementById(m.castingSkillId);
    m.castingSkillPercent = parseInt(skillEl?.value, 10) || 0;

    if (L) {
      m.maxIntensity = L.getMaxIntensity(m.castingSkillPercent, m.spellRank);
      // Fixed-cost spells cannot increase intensity
      const spellCost = m.spellDetails?.cost;
      if (spellCost && spellCost.type === 'fixed') {
        m.maxIntensity = 1;
      }
      const armorCat = this._detectArmorCategory();
      const species = document.getElementById('species')?.value || '';
      m.armorRestriction = L.checkArmorRestriction(sel.name, armorCat, species);
    } else {
      m.maxIntensity = 1;
      m.armorRestriction = { canCast: true, penalty: null, reason: null };
    }

    // Calculate effective skill
    m.effectiveSkill = m.castingSkillPercent;
    if (m.spellRank === 0) {
      m.effectiveSkill += (m.casterRank * 20);
    }
    if (m.armorRestriction?.penalty) {
      m.effectiveSkill -= 20;
    }

    // Non-memorized casting: override skill and apply difficulty
    m.nonMemDifficulty = '';
    m.nonMemPenalty = 0;
    m.nonMemSkillName = '';
    m.nonMemSkillId = '';
    m.nonMemSkillPercent = 0;

    console.log(`%c[CAST] _applySelectedClass: isNonMemorized=${m.isNonMemorized}, classSource="${m.classSource}", sel.name="${sel.name}", effectiveSkill=${m.effectiveSkill}`, 'color: #c87832; font-weight: bold');

    if (m.isNonMemorized) {
      const classNorm = sel.name.toLowerCase();
      console.log(`%c[CAST] NON-MEM branch entered. classNorm="${classNorm}"`, 'color: #e63946; font-weight: bold');
      if (classNorm.includes('mage') || classNorm.includes('magic-user')) {
        // Mage: Hard Arcane Casting — cast directly from spellbook
        m.nonMemDifficulty = 'Hard';
        m.nonMemPenalty = -20;
        m.nonMemSkillName = '';  // uses normal casting skill
      } else if (classNorm.includes('bard')) {
        // Bard: Hard Musicianship — perform directly from instrument
        m.nonMemDifficulty = 'Hard';
        m.nonMemPenalty = -20;
        m.nonMemSkillName = '';  // uses normal casting skill (Musicianship)
      } else if (classNorm.includes('sorcerer')) {
        // Sorcerer: Formidable Arcane Casting — only for spells lost from Weaving
        m.nonMemDifficulty = 'Formidable';
        m.nonMemPenalty = -40;
        m.nonMemSkillName = '';  // uses normal casting skill
      } else {
        // Divine (Cleric/Druid/Paladin/Ranger): Piety roll
        // Formidable if known but not memorized (spell is on sheet)
        // Herculean if not currently known (not on sheet — unlikely in this UI)
        m.nonMemDifficulty = 'Formidable';
        m.nonMemPenalty = -40;
        // Override skill to Piety
        m.nonMemSkillName = 'Piety';
        m.nonMemSkillId = 'piety-percent';
        const pietyEl = document.getElementById('piety-percent');
        m.nonMemSkillPercent = parseInt(pietyEl?.value, 10) || 0;
        // Use Piety instead of Channel for effective skill
        m.effectiveSkill = m.nonMemSkillPercent;
        // Re-apply cantrip bonus to piety if applicable
        if (m.spellRank === 0) {
          m.effectiveSkill += (m.casterRank * 20);
        }
      }
      m.effectiveSkill += m.nonMemPenalty;
      console.log(`%c[CAST] NON-MEM penalty=${m.nonMemPenalty}, difficulty="${m.nonMemDifficulty}", effectiveSkill=${m.effectiveSkill}`, 'color: #e63946; font-weight: bold');
    } else {
      console.log(`[CAST] Memorized casting — no non-mem penalty applied`);
    }

    m.effectiveSkill = Math.max(0, Math.min(m.effectiveSkill, 200));
    console.log(`%c[CAST] _applySelectedClass DONE: effectiveSkill=${m.effectiveSkill}`, 'color: #2a9d8f; font-weight: bold');
  },

  /**
   * Defensive recalculation of effective skill from current state.
   * Called before display and before rolling to guarantee non-mem penalty is applied.
   * This exists as a safety net in case _applySelectedClass is skipped or overridden.
   */
  _ensureEffectiveSkill(m) {
    // Start from the casting skill percent (base value from the skill input)
    const skillEl = document.getElementById(m.castingSkillId);
    let baseSkill = parseInt(skillEl?.value, 10) || 0;

    // For non-memorized divine, use Piety instead
    if (m.isNonMemorized && m.nonMemSkillName === 'Piety') {
      const pietyEl = document.getElementById('piety-percent');
      baseSkill = parseInt(pietyEl?.value, 10) || 0;
    }

    let effective = baseSkill;

    // Cantrip rank bonus
    if (m.spellRank === 0 && m.casterRank >= 1) {
      effective += (m.casterRank * 20);
    }

    // Armor penalty
    if (m.armorRestriction?.penalty) {
      effective -= 20;
    }

    // Non-memorized penalty — THIS IS THE CRITICAL PART
    if (m.isNonMemorized && m.nonMemPenalty) {
      effective += m.nonMemPenalty;
    }

    effective = Math.max(0, Math.min(effective, 200));

    // Only update if our recalculation differs (log for debugging)
    if (effective !== m.effectiveSkill) {
      console.warn(`%c[CAST] _ensureEffectiveSkill CORRECTED: was ${m.effectiveSkill}, recalculated to ${effective} (base=${baseSkill}, nonMem=${m.isNonMemorized}, penalty=${m.nonMemPenalty})`, 'color: #e63946; font-weight: bold');
      m.effectiveSkill = effective;
    }
    return effective;
  },

  /**
   * Switch casting class in the modal (multiclass support)
   * Recalculates skill, armor, theme, and refreshes the modal display
   */
  _switchCastingClass(classIndex, costStr) {
    const m = this._castModal;
    if (classIndex === m.selectedClassIndex) return;
    if (classIndex < 0 || classIndex >= m.matchingClasses.length) return;

    m.selectedClassIndex = classIndex;
    m.intensity = 1;
    this._applySelectedClass(m);
    this._populateCastModal(m, costStr || m.costStr || '');
  },

  /**
   * Step casting time up one level for non-memorized casting
   * Instant → 1 Round; Rounds → Minutes; Minutes → Hours
   */
  _stepCastingTime(timeStr) {
    if (!timeStr) return '1 Round';
    const lower = timeStr.toLowerCase().trim();
    if (lower.includes('instant') || lower === '1 action' || lower === 'action') {
      return '1 Round';
    } else if (lower.includes('round')) {
      // Extract number if present: "2 Rounds" → "2 Minutes"
      const match = lower.match(/(\d+)/);
      const n = match ? match[1] : '1';
      return `${n} Minute${n !== '1' ? 's' : ''}`;
    } else if (lower.includes('minute')) {
      const match = lower.match(/(\d+)/);
      const n = match ? match[1] : '1';
      return `${n} Hour${n !== '1' ? 's' : ''}`;
    } else if (lower.includes('hour')) {
      return 'Too slow — memorize and cast normally';
    }
    return '1 Round';
  },

  /**
   * Detect what armor the character is wearing from hit location fields
   */
  _detectArmorCategory() {
    const L = window.SpellDetailsLookup;
    if (!L) return 'none';

    // Scan armor inputs on the combat page
    const armorInputs = document.querySelectorAll('.armor-input');
    let heaviestCategory = 'none';
    const categoryWeight = { 'none': 0, 'light': 1, 'elven-chain': 2, 'heavy': 3, 'unknown': 3 };

    armorInputs.forEach(input => {
      const val = input.value?.trim();
      if (!val) return;
      const cat = L.classifyArmor(val);
      if ((categoryWeight[cat] || 0) > (categoryWeight[heaviestCategory] || 0)) {
        heaviestCategory = cat;
      }
    });

    return heaviestCategory;
  },

  /**
   * Populate all modal fields from state
   */
  _populateCastModal(m, costStr) {
    const L = window.SpellDetailsLookup;
    const d = m.spellDetails;

    // Theme
    const dialog = document.getElementById('cast-modal-dialog');
    dialog.className = 'modal-content cast-modal-content theme-' + m.castingType;

    // Header
    document.getElementById('cast-modal-school').textContent = d?.school || '';
    document.getElementById('cast-modal-spell-name').textContent = d?.name || m.spellName;

    const rankLabels = { 0: 'Cantrip', 1: 'Rank 1', 2: 'Rank 2', 3: 'Rank 3', 4: 'Rank 4', 5: 'Rank 5' };

    // Multiclass selector
    const classSelectRow = document.getElementById('cast-class-select-row');
    const classOptionsDiv = document.getElementById('cast-class-options');
    if (m.matchingClasses && m.matchingClasses.length > 1) {
      // Show selector, put class name in the selector instead of the badge
      classSelectRow.classList.remove('hidden');
      classOptionsDiv.innerHTML = '';
      m.matchingClasses.forEach((mc, idx) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'cast-class-btn' + (idx === m.selectedClassIndex ? ' active' : '');
        btn.textContent = mc.name + ' (' + mc.castingSkillName + ')';
        btn.dataset.classIndex = idx;
        btn.addEventListener('click', () => this._switchCastingClass(idx, costStr));
        classOptionsDiv.appendChild(btn);
      });
      document.getElementById('cast-modal-rank-badge').textContent = rankLabels[m.spellRank] || `Rank ${m.spellRank}`;
    } else {
      // Single class — hide selector, show class in badge
      classSelectRow.classList.add('hidden');
      const classLabel = m.classSource ? ` \u2022 ${m.classSource}` : '';
      document.getElementById('cast-modal-rank-badge').textContent = (rankLabels[m.spellRank] || `Rank ${m.spellRank}`) + classLabel;
    }

    // Stat block
    if (d) {
      document.getElementById('cast-stat-cost').textContent = d.costDisplay || costStr || '1';
      document.getElementById('cast-stat-area').textContent = d.area || '—';
      // Show stepped casting time for non-memorized spells
      const timeEl = document.getElementById('cast-stat-time');
      if (m.isNonMemorized) {
        const baseTime = d.castingTime || '1 Action';
        const steppedTime = this._stepCastingTime(baseTime);
        timeEl.innerHTML = `<span class="stat-time-stepped">${steppedTime}</span>`;
        timeEl.classList.add('stat-time-increased');
      } else {
        timeEl.textContent = d.castingTime || '—';
        timeEl.classList.remove('stat-time-increased');
      }
      document.getElementById('cast-stat-duration').textContent = d.duration || '—';
      document.getElementById('cast-stat-range').textContent = d.range || '—';
      document.getElementById('cast-stat-resist').textContent = d.resist || 'None';
    } else {
      // No detail data — show basic info from the spell row cost field
      document.getElementById('cast-stat-cost').textContent = costStr || '1';
      ['area', 'time', 'duration', 'range', 'resist'].forEach(f => {
        document.getElementById(`cast-stat-${f}`).textContent = '—';
      });
    }

    // Intensity section
    const intensitySection = document.getElementById('cast-modal-intensity-section');
    if (m.spellRank === 0) {
      intensitySection.style.display = 'none';
      m.intensity = 1;
    } else {
      intensitySection.style.display = '';
      m.intensity = 1;
      this._updateIntensityDisplay(m, costStr);
    }

    // Armor warning
    const armorWarn = document.getElementById('cast-armor-warning');
    if (m.armorRestriction && !m.armorRestriction.canCast) {
      armorWarn.classList.remove('hidden');
      armorWarn.classList.add('blocked');
      document.getElementById('cast-armor-warning-text').textContent = m.armorRestriction.reason;
    } else if (m.armorRestriction?.penalty) {
      armorWarn.classList.remove('hidden', 'blocked');
      document.getElementById('cast-armor-warning-text').textContent = m.armorRestriction.reason;
    } else {
      armorWarn.classList.add('hidden');
    }

    // Non-memorized casting info
    const nonmemSection = document.getElementById('cast-nonmem-section');
    if (m.isNonMemorized) {
      nonmemSection.classList.remove('hidden');
      const skillLabel = m.nonMemSkillName || (L ? L.getCastingSkillName(m.classSource) : 'Casting');
      document.getElementById('cast-nonmem-difficulty').textContent =
        `${m.nonMemDifficulty} ${skillLabel} roll (${m.nonMemPenalty >= 0 ? '+' : ''}${m.nonMemPenalty}%)`;

      // Casting time step increase — make it stand out
      const baseTime = d?.castingTime || '1 Action';
      const steppedTime = this._stepCastingTime(baseTime);
      const timeEl = document.getElementById('cast-nonmem-time');
      timeEl.innerHTML = `<span class="cast-nonmem-time-label">Casting Time:</span> <span class="cast-nonmem-time-base">${baseTime}</span> <span class="cast-nonmem-time-arrow">\u27A1</span> <span class="cast-nonmem-time-stepped">${steppedTime}</span>`;

      // Class-specific rules summary
      const classNorm = m.classSource.toLowerCase();
      let rules = '';
      if (classNorm.includes('mage') || classNorm.includes('magic-user')) {
        rules = 'Cast from spellbook · Crit: no MP cost · Failure: no MP spent · Fumble: spell lost from spellbook pages';
      } else if (classNorm.includes('bard')) {
        rules = 'Performed directly · Crit: no MP cost · Failure: no MP spent · Fumble: spell lost from known spells';
      } else if (classNorm.includes('sorcerer')) {
        rules = 'Lost from Weaving · Crit: no MP cost · Failure: no MP spent · Fumble: Arcane Casting reduced 1d4+1% · No Weaving allowed · 3 Long Rests to recover spell';
      } else {
        rules = 'Praying for spell · Crit: no MP cost · Failure: no MP spent · Fumble: Piety reduced 1d4+1%';
      }
      document.getElementById('cast-nonmem-rules').textContent = rules;
    } else {
      nonmemSection.classList.add('hidden');
    }

    // Description
    if (d) {
      document.getElementById('cast-flavor-text').textContent = d.flavorText || '';
      // Build full description — include reverse if available
      let fullDesc = d.description || '';
      if (d.reverse && d.reverse.description && !d.isReverse) {
        // Primary spell with a reverse: show both
        fullDesc += `\n\n— ${d.reverse.name} (Reversed) —\n${d.reverse.description}`;
      } else if (d.isReverse && d._originalDescription) {
        // Viewing the reverse: also show the primary
        fullDesc += `\n\n— ${d._originalName || 'Primary'} —\n${d._originalDescription}`;
      }
      document.getElementById('cast-full-desc').innerHTML = this._formatSpellDescription(fullDesc);
      document.getElementById('cast-flavor-text').style.display = d.flavorText ? '' : 'none';
    } else {
      // Fallback: use tooltip from SpellData
      const fallbackDesc = window.SpellData?.getSpellDescription(m.spellName) || '';
      document.getElementById('cast-flavor-text').textContent = fallbackDesc;
      document.getElementById('cast-full-desc').textContent = '';
      document.getElementById('cast-flavor-text').style.display = fallbackDesc ? '' : 'none';
    }
    document.getElementById('cast-full-desc').classList.add('hidden');
    document.getElementById('cast-toggle-desc').textContent = 'Show Full Description \u25BC';

    // Casting skill — show override for non-memorized divine
    // Defensive recalculation to guarantee non-mem penalty is applied
    this._ensureEffectiveSkill(m);
    let displaySkillName;
    if (m.isNonMemorized && m.nonMemSkillName) {
      displaySkillName = m.nonMemSkillName;
    } else {
      displaySkillName = L ? L.getCastingSkillName(m.classSource) : 'Casting Skill';
    }
    document.getElementById('cast-skill-name').textContent = displaySkillName;
    document.getElementById('cast-skill-percent').textContent = m.effectiveSkill + '%';

    // Difficulty note
    const diffNote = document.getElementById('cast-difficulty-note');
    if (m.isNonMemorized) {
      diffNote.textContent = `(${m.nonMemDifficulty})`;
      diffNote.classList.add('penalty');
    } else if (m.spellRank === 0 && m.casterRank >= 1) {
      const bonus = L ? L.getCantripDifficultyAdjustment(m.casterRank) : '';
      diffNote.textContent = `(${bonus})`;
      diffNote.classList.remove('penalty');
    } else if (m.armorRestriction?.penalty) {
      diffNote.textContent = `(${m.armorRestriction.penalty})`;
      diffNote.classList.add('penalty');
    } else {
      diffNote.textContent = '';
    }

    // MP display
    this._updateCostDisplay(m, costStr);

    // Cast button state
    const castBtn = document.getElementById('cast-modal-cast-btn');
    const canCast = m.armorRestriction?.canCast !== false;
    const currentMPForBtn = parseInt(document.getElementById('magic-points-current')?.value, 10) || 0;
    const mpDeficit = m.cost - currentMPForBtn;
    const willOvercast = mpDeficit > 0;
    const currentExp = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    const canAffordEXP = (m.expCost || 0) <= 0 || currentExp >= (m.expCost || 0);
    castBtn.disabled = !canCast || !canAffordEXP;

    // Show/hide MP overcasting warning
    const mpWarning = document.getElementById('cast-mp-warning');
    if (mpWarning) {
      if (willOvercast && canCast && canAffordEXP) {
        mpWarning.classList.remove('hidden');
        const fatigueOrder = ['fresh', 'winded', 'tired', 'wearied', 'exhausted', 'debilitated', 'incapacitated', 'semiconscious', 'coma'];
        const currentState = this.character.fatigueState || 'fresh';
        const currentIdx = fatigueOrder.indexOf(currentState);
        const levelsToGain = mpDeficit;
        const targetIdx = Math.min(currentIdx + levelsToGain, fatigueOrder.length - 1);
        const targetState = fatigueOrder[targetIdx];
        document.getElementById('cast-mp-warning-text').textContent =
          `Insufficient MP \u2014 ${mpDeficit} MP overdrawn = ${levelsToGain} Fatigue level${levelsToGain > 1 ? 's' : ''} (${currentState} \u2192 ${targetState})`;
      } else {
        mpWarning.classList.add('hidden');
      }
    }

    if (!canCast) {
      document.getElementById('cast-btn-text').textContent = 'Cannot Cast (Armor)';
    } else if (!canAffordEXP) {
      document.getElementById('cast-btn-text').textContent = 'Insufficient EXP';
    } else if (m.isNonMemorized) {
      const classNorm = m.classSource.toLowerCase();
      if (classNorm.includes('cleric') || classNorm.includes('druid') || classNorm.includes('paladin') || classNorm.includes('ranger')) {
        document.getElementById('cast-btn-text').textContent = 'Pray for ' + (d?.name || m.spellName);
      } else if (classNorm.includes('mage') || classNorm.includes('magic-user')) {
        document.getElementById('cast-btn-text').textContent = 'Cast from Spellbook';
      } else if (classNorm.includes('bard')) {
        document.getElementById('cast-btn-text').textContent = 'Perform ' + (d?.name || m.spellName);
      } else if (classNorm.includes('sorcerer')) {
        document.getElementById('cast-btn-text').textContent = 'Channel ' + (d?.name || m.spellName);
      } else {
        document.getElementById('cast-btn-text').textContent = 'Attempt ' + (d?.name || m.spellName);
      }
    } else {
      document.getElementById('cast-btn-text').textContent = 'Cast ' + (d?.name || m.spellName);
    }

    // Hide result section, show casting section
    document.getElementById('cast-modal-result').classList.add('hidden');
    document.getElementById('cast-modal-casting').style.display = '';

    // Reset animation overlay
    const animOverlay = document.getElementById('cast-animation-overlay');
    animOverlay.className = 'cast-animation-overlay hidden';
    // Clear any lingering dialog-level animations
    dialog.classList.forEach(c => {
      if (c.startsWith('casting-anim-')) dialog.classList.remove(c);
    });
  },

  /**
   * Update intensity display and dependent stat values
   */
  _updateIntensityDisplay(m, costStr) {
    document.getElementById('cast-intensity-value').textContent = m.intensity;
    document.getElementById('cast-intensity-max').textContent = '/' + m.maxIntensity;

    document.getElementById('cast-intensity-down').disabled = m.intensity <= 1;
    document.getElementById('cast-intensity-up').disabled = m.intensity >= m.maxIntensity;

    // Update cost
    this._updateCostDisplay(m, costStr);

    // Update intensity-scaling stat values
    const d = m.spellDetails;
    if (d?.intensityScaling) {
      d.intensityScaling.forEach(s => {
        const el = document.getElementById(`cast-stat-${s.field}`);
        if (!el) return;
        if (m.intensity > 1) {
          const val = s.base + s.per * (m.intensity - 1);
          el.textContent = val + (s.unit || '');
          el.classList.add('scaled');
        } else {
          // Reset to base value at intensity 1
          el.textContent = s.base + (s.unit || '');
          el.classList.remove('scaled');
        }
      });
    }

    // Magnitude display
    const mag = Math.max(1, Math.floor(m.castingSkillPercent / 10));
    document.getElementById('cast-intensity-magnitude').textContent = `Magnitude: ${mag}`;

    // Cost info in intensity row
    document.getElementById('cast-intensity-cost').textContent = `Total Cost: ${m.cost} MP`;
  },

  /**
   * Format spell description text into HTML with proper tables
   * Converts inline **Table:** patterns into HTML <table> elements
   */
  _formatSpellDescription(text) {
    if (!text) return '';
    // Escape HTML entities
    const esc = t => t.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

    // Table-header keywords that signal tabular data
    const tableKW = /(?:Table|Effects|Modifiers|Expenditure|Examples?\s+and\s+Costs?|Summoning\s+Table|Color\s+Effects|Gem\s+Cost|Cost\s+Table)\s*(?:\([^)]*\))?\s*:/i;

    // Split on **bold** markers while keeping them
    // Strategy: process the text in segments
    const result = [];
    // Split into paragraphs on double-newline
    const paragraphs = text.split(/\n\n+/);

    for (const para of paragraphs) {
      // Check if this paragraph contains a table header
      const tableHeaderRe = /\*\*([^*]+?)\*\*:?\s*/g;
      let remaining = para;
      let hasTable = false;

      // Find bold headers that match table keywords
      const tableMatches = [];
      let tm;
      const testStr = para;
      const boldRe = /\*\*([^*]+?)\*\*:?\s*/g;
      while ((tm = boldRe.exec(testStr)) !== null) {
        if (tableKW.test(tm[1] + ':')) {
          tableMatches.push({ index: tm.index, fullMatch: tm[0], title: tm[1].replace(/:$/, '').trim() });
        }
      }

      if (tableMatches.length > 0) {
        for (let ti = 0; ti < tableMatches.length; ti++) {
          const tmatch = tableMatches[ti];
          // Text before this table
          const beforeText = ti === 0 ? para.substring(0, tmatch.index) :
            para.substring(tableMatches[ti-1].index + tableMatches[ti-1].fullMatch.length, tmatch.index);
          // Get the data range for this table
          const dataStart = tmatch.index + tmatch.fullMatch.length;
          let dataEnd;
          if (ti + 1 < tableMatches.length) {
            // Data ends where the pre-text of the next table starts
            // Look backwards from the next table match for paragraph text
            dataEnd = tableMatches[ti + 1].index;
          } else {
            dataEnd = para.length;
          }
          let dataText = para.substring(dataStart, dataEnd).trim();

          // Strip a trailing **...** that's just the closing bold of a wrapper
          dataText = dataText.replace(/\*\*\s*$/, '').trim();

          // Add preceding text as paragraph
          if (ti === 0 && beforeText.trim()) {
            result.push('<p>' + this._formatBoldText(esc(beforeText.trim())) + '</p>');
          }

          // Parse the table data
          const tableHtml = this._buildTable(tmatch.title, dataText, esc);
          if (tableHtml) {
            result.push(tableHtml);
            hasTable = true;
          } else {
            // Fallback: just show as bold header + text
            result.push('<p>' + this._formatBoldText(esc('**' + tmatch.title + ':** ' + dataText)) + '</p>');
          }

          // If this is the last table match and there's trailing text after the table data
          // (The table data extraction already accounts for this)
        }
      } else {
        // No table in this paragraph - format as regular text
        const formatted = this._formatBoldText(esc(para.trim()));
        if (formatted) result.push('<p>' + formatted + '</p>');
      }
    }

    return result.join('');
  },

  /**
   * Convert **bold** markers in already-escaped text to <strong> tags
   */
  _formatBoldText(text) {
    return text.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
  },

  /**
   * Build an HTML table from a table title and data string
   */
  _buildTable(title, data, esc) {
    if (!data || data.length < 5) return null;

    // Strip dice notation prefix (e.g., "1d10: 01-40: 10'..." → "01-40: 10'...")
    let dicePrefix = '';
    const dicePfx = data.match(/^(\d+d\d+):\s*/i);
    if (dicePfx) {
      dicePrefix = dicePfx[1];
      data = data.substring(dicePfx[0].length);
    }

    // Detect row pattern and split
    let rows = [];

    // Pattern 1: Rank/SIZ rows — "Rank X / SIZ Y: Effect" (also handles SIZ-only and "Each" rows)
    if (/^Rank\s/i.test(data)) {
      rows = this._splitTableRows(data, /(?<=\.)\s+(?=(?:Rank|SIZ|Each)\s)/i);
    }
    // Pattern 2: Intensity rows — "Intensity N: data"
    else if (/^Intensity\s/i.test(data)) {
      rows = this._splitTableRows(data, /(?<=\.)\s+(?=Intensity\s)/i);
    }
    // Pattern 3: d100 roll table — "01 – Item. 02 – Item"
    else if (/^\d{1,2}\s*[–-]\s/.test(data)) {
      rows = this._splitTableRows(data, /(?<=\.)\s+(?=\d{1,3}\s*[–-])/);
    }
    // Pattern 4: d100 range roll — "01-10: Effect. 11-20: Effect"
    else if (/^\d{2}-\d{2}:/.test(data)) {
      rows = this._splitTableRows(data, /(?<=\.)\s+(?=\d{2}-\d{2}:)/);
    }
    // Pattern 5: Numbered list — "1 Red: Effect. 2 Orange: Effect"
    else if (/^\d+\s+[A-Z]/.test(data)) {
      rows = this._splitTableRows(data, /(?<=\.)\s+(?=\d+\s+[A-Z])/);
    }
    // Pattern 6: Color/label — "Red (Outer): stuff. Orange: stuff"
    else if (/^[A-Z][a-z]+(?:\s*\([^)]*\))?:/.test(data)) {
      rows = this._splitTableRows(data, /(?<=\.)\s+(?=[A-Z][a-z]+(?:\s*\([^)]*\))?:)/);
    }
    // Pattern 7: Generic "Label: Value." separated by periods
    else {
      rows = this._splitTableRows(data, /(?<=\.)\s+(?=[A-Z])/);
    }

    if (rows.length < 2) return null; // Need at least 2 rows for a table

    // Clean trailing periods and empty rows
    rows = rows.map(r => r.replace(/\.\s*$/, '').trim()).filter(r => r.length > 0);
    if (rows.length < 2) return null;

    // Detect if first row has Rank/SIZ columns (table may also contain SIZ-only trailing rows)
    const isRankSiz = rows[0] && /Rank\s/i.test(rows[0]) && /SIZ\s/i.test(rows[0]);

    // Build table HTML
    const captionText = dicePrefix ? title + ' (' + dicePrefix + ')' : title;
    let html = '<table><caption>' + esc(captionText) + '</caption>';

    if (isRankSiz) {
      html += '<thead><tr><th>Rank</th><th>SIZ</th><th>Effect</th></tr></thead><tbody>';
      for (const row of rows) {
        const m = row.match(/Rank\s+([\d+-]+)\s*\/\s*SIZ\s+([\d+,\-]+)\s*:\s*(.*)/i);
        if (m) {
          html += '<tr><td>' + esc(m[1]) + '</td><td>' + esc(m[2]) + '</td><td>' + esc(m[3]) + '</td></tr>';
        } else {
          // SIZ-only rows (e.g., "SIZ 61-70: 25,000 GP") or "Each +20 SIZ: ..."
          const sizOnly = row.match(/(?:SIZ|Each[^:]*)\s*([\d+,\-]+)?\s*:\s*(.*)/i);
          if (sizOnly) {
            const label = row.substring(0, row.indexOf(':')).trim();
            html += '<tr><td colspan="2">' + esc(label) + '</td><td>' + esc(sizOnly[2]) + '</td></tr>';
          } else {
            html += '<tr><td colspan="3">' + esc(row) + '</td></tr>';
          }
        }
      }
    }
    // Intensity rows with comma-separated columns
    else if (rows[0] && /^Intensity\s/i.test(rows[0])) {
      // Parse first row to detect columns
      const firstMatch = rows[0].match(/Intensity\s+\d+:\s*(.*)/i);
      if (firstMatch) {
        const firstCols = firstMatch[1].split(/,\s*/);
        // Build headers from column pattern
        const headers = ['Intensity'];
        for (const col of firstCols) {
          // Extract header from value pattern
          const hm = col.match(/^([\d']+(?:d\d+)?)\s*(.*)/);
          if (hm && hm[2]) headers.push(hm[2].replace(/^\s*/, '') || col);
          else headers.push(col);
        }
        // Actually, for intensity tables just use 2 columns: Intensity and Details
        html += '<thead><tr><th>Intensity</th><th>Details</th></tr></thead><tbody>';
        for (const row of rows) {
          const rm = row.match(/Intensity\s+(\d+):\s*(.*)/i);
          if (rm) {
            html += '<tr><td>' + esc(rm[1]) + '</td><td>' + esc(rm[2]) + '</td></tr>';
          } else {
            // "Continue progression" or similar
            html += '<tr><td colspan="2" class="desc-continue">' + esc(row) + '</td></tr>';
          }
        }
      }
    }
    // d100 table "NN – Monster"
    else if (/^\d{1,3}\s*[–-]/.test(rows[0])) {
      html += '<thead><tr><th>Roll</th><th>Result</th></tr></thead><tbody>';
      for (const row of rows) {
        const rm = row.match(/^(\d{1,3}(?:\s*[-–]\s*\d{1,3})?)\s*[–-]\s*(.*)/);
        if (rm) {
          html += '<tr><td>' + esc(rm[1]) + '</td><td>' + esc(rm[2]) + '</td></tr>';
        } else {
          html += '<tr><td colspan="2">' + esc(row) + '</td></tr>';
        }
      }
    }
    // Roll range "01-10: Effect"
    else if (/^\d{2}-\d{2}:/.test(rows[0])) {
      html += '<thead><tr><th>Roll</th><th>Effect</th></tr></thead><tbody>';
      for (const row of rows) {
        const rm = row.match(/^(\d{2}-\d{2}):\s*(.*)/);
        if (rm) {
          html += '<tr><td>' + esc(rm[1]) + '</td><td>' + esc(rm[2]) + '</td></tr>';
        } else {
          html += '<tr><td colspan="2">' + esc(row) + '</td></tr>';
        }
      }
    }
    // Numbered color table "1 Red: effect"
    else if (/^\d+\s+[A-Z]/.test(rows[0])) {
      html += '<thead><tr><th>#</th><th>Color</th><th>Effect</th></tr></thead><tbody>';
      for (const row of rows) {
        const rm = row.match(/^(\d+)\s+([^:]+):\s*(.*)/);
        if (rm) {
          html += '<tr><td>' + esc(rm[1]) + '</td><td>' + esc(rm[2]) + '</td><td>' + esc(rm[3]) + '</td></tr>';
        } else {
          html += '<tr><td colspan="3">' + esc(row) + '</td></tr>';
        }
      }
    }
    // Generic "Label: Value" two-column
    else {
      html += '<tbody>';
      for (const row of rows) {
        const colonIdx = row.indexOf(':');
        if (colonIdx > 0 && colonIdx < row.length - 1) {
          html += '<tr><td><strong>' + esc(row.substring(0, colonIdx).trim()) + '</strong></td><td>' + esc(row.substring(colonIdx + 1).trim()) + '</td></tr>';
        } else {
          html += '<tr><td colspan="2">' + esc(row) + '</td></tr>';
        }
      }
    }

    html += '</tbody></table>';
    return html;
  },

  /**
   * Split table data into rows using the given separator pattern
   */
  _splitTableRows(data, separator) {
    // First strip any trailing text that isn't part of the table
    // Table data ends at double-newline or when we hit non-table prose
    const endMatch = data.match(/\n\n/);
    let tableData = endMatch ? data.substring(0, endMatch.index) : data;

    return tableData.split(separator).map(r => r.trim()).filter(r => r.length > 0);
  },

  /**
   * Parse EXP cost from a spell's costDisplay string
   * Returns { exp: number, variable: boolean }
   */
  _parseExpCost(costDisplay) {
    if (!costDisplay || !costDisplay.includes('EXP')) return { exp: 0, variable: false };
    // Variable: "+1 or more EXP"
    let m = costDisplay.match(/\+?(\d+)\s+or\s+more\s+EXP/i);
    if (m) return { exp: parseInt(m[1]), variable: true };
    // Conditional in parens: "(+1 EXP)" or "(Death +2 EXP)"
    m = costDisplay.match(/\([^)]*?(\d+)\s*EXP\)/i);
    if (m) return { exp: parseInt(m[1]), variable: true };
    // Fixed: "+N EXP"
    m = costDisplay.match(/\+?(\d+)\s*EXP/i);
    if (m) return { exp: parseInt(m[1]), variable: false };
    return { exp: 0, variable: false };
  },

  /**
   * Calculate and display the MP cost at current intensity
   */
  _updateCostDisplay(m, costStr) {
    const L = window.SpellDetailsLookup;
    const d = m.spellDetails;

    // Calculate MP cost
    if (d?.cost && L) {
      m.cost = L.calculateCost(d.cost, m.intensity, m.spellRank, m.casterRank);
    } else {
      // Parse from cost string as fallback
      const costMatch = (costStr || '').match(/^(\d+)/);
      m.cost = costMatch ? parseInt(costMatch[1], 10) : 1;
    }

    // Calculate EXP cost
    const expInfo = this._parseExpCost(d?.costDisplay || costStr || '');
    m.expCost = expInfo.exp;
    m.expVariable = expInfo.variable;

    const currentMP = parseInt(document.getElementById('magic-points-current')?.value, 10) || 0;
    const mpAfter = currentMP - m.cost;

    document.getElementById('cast-mp-current').textContent = currentMP;

    if (m.isNonMemorized) {
      // Non-memorized: show conditional cost
      document.getElementById('cast-mp-after').textContent = mpAfter >= 0 ? `${mpAfter} (if success)` : mpAfter;
    } else {
      document.getElementById('cast-mp-after').textContent = mpAfter >= 0 ? mpAfter : mpAfter;
    }

    const mpAfterEl = document.getElementById('cast-mp-after');
    if (mpAfter < 0) {
      mpAfterEl.classList.add('insufficient');
    } else {
      mpAfterEl.classList.remove('insufficient');
    }

    // EXP display
    const expRow = document.getElementById('cast-exp-row');
    if (expRow) {
      if (m.expCost > 0) {
        expRow.classList.remove('hidden');
        const currentExp = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
        const expAfter = currentExp - m.expCost;
        document.getElementById('cast-exp-current').textContent = currentExp;
        document.getElementById('cast-exp-after').textContent = expAfter;
        const expAfterEl = document.getElementById('cast-exp-after');
        if (expAfter < 0) {
          expAfterEl.classList.add('insufficient');
        } else {
          expAfterEl.classList.remove('insufficient');
        }
        // Note for variable costs
        const noteEl = document.getElementById('cast-exp-note');
        if (m.expVariable) {
          noteEl.textContent = `(${m.expCost}+ EXP — see description)`;
        } else {
          noteEl.textContent = '';
        }
      } else {
        expRow.classList.add('hidden');
      }
    }

    // Update cast button — check EXP (MP overcasting is allowed with fatigue)
    const castBtn = document.getElementById('cast-modal-cast-btn');
    if (castBtn && m.armorRestriction?.canCast !== false) {
      const currentExp = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
      const canAffordEXP = m.expCost <= 0 || currentExp >= m.expCost;
      castBtn.disabled = !canAffordEXP;
      if (!canAffordEXP) {
        document.getElementById('cast-btn-text').textContent = 'Insufficient EXP';
      }

      // Show/hide MP overcasting warning
      const mpWarn = document.getElementById('cast-mp-warning');
      if (mpWarn) {
        if (mpAfter < 0 && canAffordEXP) {
          mpWarn.classList.remove('hidden');
          const deficit = Math.abs(mpAfter);
          const fatigueOrder = ['fresh', 'winded', 'tired', 'wearied', 'exhausted', 'debilitated', 'incapacitated', 'semiconscious', 'coma'];
          const curState = this.character.fatigueState || 'fresh';
          const curIdx = fatigueOrder.indexOf(curState);
          const tgtIdx = Math.min(curIdx + deficit, fatigueOrder.length - 1);
          document.getElementById('cast-mp-warning-text').textContent =
            `Insufficient MP \u2014 ${deficit} MP overdrawn = ${deficit} Fatigue level${deficit > 1 ? 's' : ''} (${curState} \u2192 ${fatigueOrder[tgtIdx]})`;
        } else {
          mpWarn.classList.add('hidden');
        }
      }
      // Don't override button text here — _populateCastModal handles normal state
    }
  },

  /**
   * Show the modal and bind event listeners
   */
  _showCastModal() {
    const modal = document.getElementById('cast-modal');
    modal.classList.remove('hidden');

    // Close button
    document.getElementById('cast-modal-close').onclick = () => this._closeCastModal();

    // Click overlay to close
    modal.onclick = (e) => {
      if (e.target === modal) this._closeCastModal();
    };

    // Toggle description
    document.getElementById('cast-toggle-desc').onclick = () => {
      const desc = document.getElementById('cast-full-desc');
      const btn = document.getElementById('cast-toggle-desc');
      if (desc.classList.contains('hidden')) {
        desc.classList.remove('hidden');
        btn.textContent = 'Hide Description \u25B2';
      } else {
        desc.classList.add('hidden');
        btn.textContent = 'Show Full Description \u25BC';
      }
    };

    // Intensity buttons
    document.getElementById('cast-intensity-down').onclick = () => {
      const m = this._castModal;
      if (m.intensity > 1) {
        m.intensity--;
        this._updateIntensityDisplay(m);
      }
    };
    document.getElementById('cast-intensity-up').onclick = () => {
      const m = this._castModal;
      if (m.intensity < m.maxIntensity) {
        m.intensity++;
        this._updateIntensityDisplay(m);
      }
    };

    // Cast button
    document.getElementById('cast-modal-cast-btn').onclick = () => this._executeCast();

    // Done button — play fullscreen success animation then close
    document.getElementById('cast-done-btn').onclick = () => {
      const m = this._castModal;
      const rc = m.rollResult?.resultClass;
      if (rc === 'success' || rc === 'critical' || rc === 'forced') {
        this._playFullscreenCastAnimation(m.castingType, rc, () => this._closeCastModal());
      } else {
        this._closeCastModal();
      }
    };

    // Force spell button
    document.getElementById('cast-force-btn').onclick = () => this._forceSpell();

    // Luck point button
    document.getElementById('cast-luck-btn').onclick = () => this._useLuckPoint();
  },

  /**
   * Close the casting modal
   */
  _closeCastModal() {
    document.getElementById('cast-modal').classList.add('hidden');
    // Reset animation overlay
    document.getElementById('cast-animation-overlay').className = 'cast-animation-overlay hidden';
    // Remove dialog-level animation classes
    const dialog = document.getElementById('cast-modal-dialog');
    dialog.classList.forEach(c => {
      if (c.startsWith('casting-anim-')) dialog.classList.remove(c);
    });
  },

  /**
   * Execute the spell casting — roll d100 with animation
   */
  _executeCast() {
    const m = this._castModal;
    if (m.hasRolled) return;

    // Check MP — allow overcasting with fatigue penalty
    const mpField = document.getElementById('magic-points-current');
    const currentMP = parseInt(mpField?.value, 10) || 0;
    const mpDeficit = Math.max(0, m.cost - currentMP);
    // Store for result display
    m._overcastFatigue = mpDeficit;

    // Check EXP availability
    const expField = document.getElementById('exp-rolls');
    const currentExp = parseInt(expField?.value, 10) || 0;
    if ((m.expCost || 0) > 0 && currentExp < m.expCost) return;

    // For NORMAL casting: deduct MP and EXP upfront (Mythras RAW)
    // For NON-MEMORIZED: don't deduct yet (depends on result)
    if (!m.isNonMemorized) {
      // MP goes to 0 minimum (deficit becomes fatigue)
      mpField.value = Math.max(0, currentMP - m.cost);
      this.character.derived = this.character.derived || {};
      this.character.derived.magicPointsCurrent = mpField.value;
      this.updateMagicMPDisplay();

      // Apply fatigue for overcast deficit
      if (mpDeficit > 0) {
        this._applyOvercastFatigue(mpDeficit);
      }

      // Deduct EXP
      if ((m.expCost || 0) > 0 && expField) {
        expField.value = currentExp - m.expCost;
        if (this.character.expRolls !== undefined) {
          this.character.expRolls = parseInt(expField.value, 10);
        }
      }
    }

    // Hide casting controls, show result area
    document.getElementById('cast-modal-casting').style.display = 'none';
    const resultSection = document.getElementById('cast-modal-result');
    resultSection.classList.remove('hidden');

    // Defensive recalculation before rolling
    this._ensureEffectiveSkill(m);

    // Hide sub-sections initially
    document.getElementById('cast-force-section').classList.add('hidden');
    document.getElementById('cast-result-banner').style.visibility = 'hidden';
    document.getElementById('cast-result-details').textContent = '';
    document.getElementById('cast-roll-target').textContent = `vs ${m.effectiveSkill}%`;

    // Animate d100 roll
    const rollEl = document.getElementById('cast-roll-number');
    rollEl.classList.add('rolling');
    rollEl.textContent = '00';

    const finalRoll = Math.floor(Math.random() * 100) + 1;
    let ticks = 0;
    const maxTicks = 18;
    const rollInterval = setInterval(() => {
      ticks++;
      rollEl.textContent = String(Math.floor(Math.random() * 100) + 1).padStart(2, '0');
      if (ticks >= maxTicks) {
        clearInterval(rollInterval);
        rollEl.classList.remove('rolling');
        rollEl.textContent = String(finalRoll).padStart(2, '0');
        this._resolveRoll(m, finalRoll);
      }
    }, 60);

    m.hasRolled = true;
    this.scheduleAutoSave();
  },

  /**
   * Resolve the d100 roll result
   */
  _resolveRoll(m, roll) {
    const skill = m.effectiveSkill;

    // Critical: 10% of skill value, always rounded UP
    const critThreshold = Math.max(1, Math.ceil(skill / 10));
    
    // Fumble: 99 or 00 (100). Skills over 100% only fumble on 00
    const isFumble = skill >= 100 ? (roll === 100) : (roll >= 99);
    
    // 96-00 is ALWAYS a Failure, no matter how high the skill
    const isAutoFail = roll >= 96;
    
    // 01-05 is ALWAYS a Success, even if skill is very low
    const isAutoSuccess = roll <= 5;

    let result, resultClass;
    if (isFumble) {
      result = 'FUMBLE';
      resultClass = 'fumble';
    } else if (isAutoFail) {
      result = 'FAILURE';
      resultClass = 'failure';
    } else if (roll <= critThreshold && (roll <= skill || isAutoSuccess)) {
      result = 'CRITICAL SUCCESS';
      resultClass = 'critical';
    } else if (roll <= skill || isAutoSuccess) {
      result = 'SUCCESS';
      resultClass = 'success';
    } else {
      result = 'FAILURE';
      resultClass = 'failure';
    }

    m.rollResult = { roll, result, resultClass, critThreshold };

    // Update display
    const banner = document.getElementById('cast-result-banner');
    banner.style.visibility = 'visible';
    banner.className = 'cast-result-banner ' + resultClass;
    document.getElementById('cast-result-text').textContent = result;

    // Color the roll number
    const rollEl = document.getElementById('cast-roll-number');
    rollEl.style.color = resultClass === 'critical' ? '#b8860b' :
                         resultClass === 'success' ? '#155724' :
                         resultClass === 'fumble' ? '#721c24' : '#856404';

    // Result details
    const details = document.getElementById('cast-result-details');
    const mpField = document.getElementById('magic-points-current');

    if (m.isNonMemorized) {
      // === NON-MEMORIZED CASTING RESULTS ===
      const currentMP = parseInt(mpField?.value, 10) || 0;
      const classNorm = m.classSource.toLowerCase();
      const expField = document.getElementById('exp-rolls');

      // Helper: deduct EXP on spell success (critical or normal)
      const deductExp = () => {
        if ((m.expCost || 0) > 0 && expField) {
          const curExp = parseInt(expField.value, 10) || 0;
          expField.value = curExp - m.expCost;
          if (this.character.expRolls !== undefined) {
            this.character.expRolls = parseInt(expField.value, 10);
          }
        }
      };
      const expStr = (m.expCost || 0) > 0 ? ` ${m.expCost} EXP spent.` : '';

      if (resultClass === 'critical') {
        // Critical: spell succeeds, NO MP cost, but EXP still spent
        deductExp();
        details.textContent = `Critical! The spell takes effect with exceptional potency \u2014 no Magic Points expended.${expStr}`;
      } else if (resultClass === 'success') {
        // Success: deduct MP and EXP now (MP floors at 0, deficit becomes fatigue)
        const nonMemDeficit = Math.max(0, m.cost - currentMP);
        mpField.value = Math.max(0, currentMP - m.cost);
        this.character.derived = this.character.derived || {};
        this.character.derived.magicPointsCurrent = mpField.value;
        this.updateMagicMPDisplay();
        if (nonMemDeficit > 0) {
          this._applyOvercastFatigue(nonMemDeficit);
        }
        deductExp();
        const newMP = parseInt(mpField.value, 10) || 0;
        const fatigueNote = nonMemDeficit > 0 ? ` \u26A0 ${nonMemDeficit} Fatigue level${nonMemDeficit > 1 ? 's' : ''} gained from MP overdraft!` : '';
        if (classNorm.includes('sorcerer')) {
          details.textContent = `${m.cost} MP spent.${expStr} Remaining: ${newMP} MP.${fatigueNote} The spell takes effect. No Weaving allowed. Requires 3 Long Rests to return to memory.`;
        } else {
          details.textContent = `${m.cost} MP spent.${expStr} Remaining: ${newMP} MP.${fatigueNote} The spell takes effect normally.`;
        }
      } else if (resultClass === 'fumble') {
        // Fumble: class-specific consequences, no MP spent
        if (classNorm.includes('mage') || classNorm.includes('magic-user')) {
          details.textContent = `Fumble! No MP spent. The spell fades from the spellbook\u2019s pages and is permanently lost.`;
          // Remove spell from the spell list
          this._removeSpellFromList(m);
        } else if (classNorm.includes('bard')) {
          details.textContent = `Fumble! No MP spent. The spell fades from the bard\u2019s known spells and is lost.`;
          // Remove spell from the spell list
          this._removeSpellFromList(m);
        } else if (classNorm.includes('sorcerer')) {
          // Sorcerer: reduce Arcane Casting by 1d4+1%
          this._showFumbleSkillLossOverlay(m, 'arcane-casting-percent', 'Arcane Casting',
            'The weave unravels violently. Your connection to the arcane frays.');
        } else {
          // Divine: reduce Piety by 1d4+1%
          this._showFumbleSkillLossOverlay(m, 'piety-percent', 'Piety',
            'Your deity is disappointed in you and your Piety decreases.');
        }
      } else {
        // Failure: no MP spent — class-flavored messages
        if (classNorm.includes('mage') || classNorm.includes('magic-user')) {
          details.textContent = `The words on the page blur and resist reading. No Magic Points are expended.`;
        } else if (classNorm.includes('bard')) {
          details.textContent = `The melody falls flat and the magic doesn\u2019t take hold. No Magic Points are expended.`;
        } else if (classNorm.includes('sorcerer')) {
          details.textContent = `The spell cannot be summoned from the sorcerer\u2019s mind. No Magic Points are expended.`;
        } else {
          details.textContent = `The spell is not granted. No Magic Points are expended.`;
        }
      }

      // Non-memorized: NO force spell option
      // But still allow Luck Point reroll on failure
      if (resultClass === 'failure') {
        const forceSection = document.getElementById('cast-force-section');
        forceSection.classList.remove('hidden');
        // Hide the Force Spell button — not available for non-memorized
        document.getElementById('cast-force-btn').style.display = 'none';
        const forceExplain = forceSection.querySelector('.cast-force-explain');
        if (classNorm.includes('cleric') || classNorm.includes('druid') || classNorm.includes('paladin') || classNorm.includes('ranger')) {
          forceExplain.textContent = 'Your prayer was not answered. You may spend a Luck Point to beseech again.';
        } else {
          forceExplain.textContent = 'The casting attempt failed. You may spend a Luck Point to try again.';
        }
        const luckEl = document.getElementById('luck-current');
        const luckCount = parseInt(luckEl?.value, 10) || 0;
        document.getElementById('cast-luck-count').textContent = luckCount;
        document.getElementById('cast-luck-btn').disabled = luckCount <= 0;
      }

    } else {
      // === NORMAL (MEMORIZED) CASTING RESULTS ===
      const newMP = parseInt(mpField?.value, 10) || 0;
      const expStr = (m.expCost || 0) > 0 ? ` ${m.expCost} EXP spent.` : '';
      const fatigueNote = (m._overcastFatigue || 0) > 0 ? ` \u26A0 ${m._overcastFatigue} Fatigue level${m._overcastFatigue > 1 ? 's' : ''} gained from MP overdraft!` : '';

      if (resultClass === 'critical') {
        details.textContent = `Critical! ${m.cost} MP spent.${expStr} Remaining: ${newMP} MP.${fatigueNote} The spell takes effect with exceptional potency.`;
      } else if (resultClass === 'success') {
        details.textContent = `${m.cost} MP spent.${expStr} Remaining: ${newMP} MP.${fatigueNote} The spell takes effect normally.`;
      } else if (resultClass === 'fumble') {
        details.textContent = `${m.cost} MP spent.${expStr} Remaining: ${newMP} MP.${fatigueNote} The spell fails catastrophically \u2014 consult your GM for fumble effects.`;
      } else {
        details.textContent = `${m.cost} MP spent.${expStr} Remaining: ${newMP} MP.${fatigueNote} The spell fizzles and fails.`;
      }

      // Show force section on failure
      if (resultClass === 'failure') {
        const forceSection = document.getElementById('cast-force-section');
        forceSection.classList.remove('hidden');
        document.getElementById('cast-force-btn').style.display = '';  // Show Force button for normal casting

        const luckEl = document.getElementById('luck-current');
        const luckCount = parseInt(luckEl?.value, 10) || 0;
        document.getElementById('cast-luck-count').textContent = luckCount;
        document.getElementById('cast-luck-btn').disabled = luckCount <= 0;

        const forceExplain = forceSection.querySelector('.cast-force-explain');
        forceExplain.textContent = 'The spell fizzled. You may force it to succeed, but it will be expunged from memory and must be re-memorized.';
      }
    }

    // Play animation
    this._playCastAnimation(m.castingType, resultClass);

    // Flash the original cast button
    const castBtn = document.getElementById(`${m.rankKey}-${m.slotIndex}-cast`);
    this._showCastButtonFeedback(castBtn, resultClass === 'critical' || resultClass === 'success' ? 'success' : 'fail');
  },

  /**
   * Force a failed spell to succeed
   */
  _forceSpell() {
    const m = this._castModal;
    if (!m.rollResult || m.rollResult.resultClass !== 'failure') return;
    if (m.isNonMemorized) return; // Force not available for non-memorized casting

    // Update result display
    const banner = document.getElementById('cast-result-banner');
    banner.className = 'cast-result-banner success';
    document.getElementById('cast-result-text').textContent = 'FORCED SUCCESS';

    const mpField = document.getElementById('magic-points-current');
    const newMP = parseInt(mpField?.value, 10) || 0;

    const details = document.getElementById('cast-result-details');
    const expStr = (m.expCost || 0) > 0 ? ` ${m.expCost} EXP spent.` : '';
    details.textContent = `Spell forced! ${m.cost} MP spent.${expStr} Remaining: ${newMP} MP. Spell is expunged from memory \u2014 must be re-memorized before casting again.`;
    // Uncheck the memorized checkbox for this spell
    const memCheck = document.getElementById(`${m.rankKey}-${m.slotIndex}-mem`);
    if (memCheck) memCheck.checked = false;

    // Hide force section
    document.getElementById('cast-force-section').classList.add('hidden');

    // Play success animation
    this._playCastAnimation(m.castingType, 'success');

    // Update result state
    m.rollResult.resultClass = 'forced';

    // Flash original button
    const castBtn = document.getElementById(`${m.rankKey}-${m.slotIndex}-cast`);
    this._showCastButtonFeedback(castBtn, 'success');

    this.scheduleAutoSave();
  },

  /**
   * Spend a Luck Point to reroll the casting attempt
   */
  _useLuckPoint() {
    const m = this._castModal;
    if (!m.rollResult || m.rollResult.resultClass !== 'failure') return;

    // Deduct luck point
    const luckEl = document.getElementById('luck-current');
    const luckCount = parseInt(luckEl?.value, 10) || 0;
    if (luckCount <= 0) return;

    luckEl.value = luckCount - 1;
    this.character.derived = this.character.derived || {};
    this.character.derived.luckCurrent = luckEl.value;

    // Reset and reroll
    m.hasRolled = false;
    m.rollResult = null;

    // Hide force section
    document.getElementById('cast-force-section').classList.add('hidden');

    // Animate new roll
    const rollEl = document.getElementById('cast-roll-number');
    rollEl.classList.add('rolling');
    rollEl.style.color = '#2a2520';

    document.getElementById('cast-result-banner').style.visibility = 'hidden';
    document.getElementById('cast-result-details').textContent = 'Luck Point spent \u2014 rerolling...';

    const finalRoll = Math.floor(Math.random() * 100) + 1;
    let ticks = 0;
    const rollInterval = setInterval(() => {
      ticks++;
      rollEl.textContent = String(Math.floor(Math.random() * 100) + 1).padStart(2, '0');
      if (ticks >= 18) {
        clearInterval(rollInterval);
        rollEl.classList.remove('rolling');
        rollEl.textContent = String(finalRoll).padStart(2, '0');
        m.hasRolled = true;
        this._resolveRoll(m, finalRoll);
      }
    }, 60);

    this.scheduleAutoSave();
  },

  /**
   * Remove a spell from the spell list after a fumble (mage/bard non-memorized)
   */
  _removeSpellFromList(m) {
    const tbody = document.getElementById(`${m.rankKey}-body`);
    if (!tbody) return;
    const row = tbody.rows[m.slotIndex];
    if (!row) return;

    // Brief delay so the user sees the fumble result first
    setTimeout(() => {
      row.style.transition = 'opacity 0.6s ease, background-color 0.3s ease';
      row.style.backgroundColor = 'rgba(114, 28, 36, 0.15)';
      setTimeout(() => {
        row.style.opacity = '0';
        setTimeout(() => {
          this.removeSpellRow(m.rankKey, row);
          console.log(`[CAST] Spell "${m.spellName}" removed from ${m.rankKey} after fumble`);
        }, 600);
      }, 400);
    }, 800);
  },

  /**
   * Show animated fumble overlay for skill loss (divine Piety / sorcerer Arcane Casting)
   * Rolls 1d4+1, reduces the skill, and shows a dramatic overlay
   */
  _showFumbleSkillLossOverlay(m, skillFieldId, skillLabel, message) {
    // Create or get the fumble overlay
    let overlay = document.getElementById('fumble-skill-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'fumble-skill-overlay';
      overlay.className = 'fumble-skill-overlay';
      overlay.innerHTML = `
        <div class="fumble-skill-content">
          <div class="fumble-skill-icon">\u26A1</div>
          <div class="fumble-skill-message" id="fumble-skill-message"></div>
          <div class="fumble-skill-roll-section">
            <span class="fumble-skill-roll-label">1d4+1 \u2192</span>
            <span class="fumble-skill-roll-number" id="fumble-skill-roll-number">?</span>
          </div>
          <div class="fumble-skill-result" id="fumble-skill-result"></div>
          <button class="fumble-skill-close" id="fumble-skill-close">OK</button>
        </div>
      `;
      document.body.appendChild(overlay);
      document.getElementById('fumble-skill-close').addEventListener('click', () => {
        overlay.classList.remove('visible');
      });
    }

    // Set message
    document.getElementById('fumble-skill-message').textContent = message;
    document.getElementById('fumble-skill-result').textContent = '';
    const rollEl = document.getElementById('fumble-skill-roll-number');
    rollEl.textContent = '?';
    rollEl.classList.add('rolling');

    // Show overlay after brief delay
    setTimeout(() => {
      overlay.classList.add('visible');

      // Animate the 1d4+1 roll
      const finalRoll = Math.floor(Math.random() * 4) + 2; // 1d4+1 = 2-5
      let ticks = 0;
      const maxTicks = 12;
      const rollInterval = setInterval(() => {
        ticks++;
        rollEl.textContent = String(Math.floor(Math.random() * 4) + 2);
        if (ticks >= maxTicks) {
          clearInterval(rollInterval);
          rollEl.classList.remove('rolling');
          rollEl.textContent = String(finalRoll);

          // Apply skill reduction
          const skillEl = document.getElementById(skillFieldId);
          if (skillEl) {
            const current = parseInt(skillEl.value, 10) || 0;
            const reduced = Math.max(0, current - finalRoll);
            skillEl.value = reduced;
            // Save to character
            this.scheduleAutoSave();
          }

          // Show result text
          const resultEl = document.getElementById('fumble-skill-result');
          resultEl.textContent = `${skillLabel} reduced by ${finalRoll}%`;
          resultEl.classList.add('visible');

          // Also update the fumble details text in the cast modal
          const details = document.getElementById('cast-result-details');
          if (details) {
            details.textContent = `Fumble! No MP spent. ${skillLabel} reduced by ${finalRoll}%.`;
          }
        }
      }, 80);
    }, 600);
  },

  /**
   * Play casting type animation on the modal
   */
  _playCastAnimation(castingType, resultClass) {
    const dialog = document.getElementById('cast-modal-dialog');
    const overlay = document.getElementById('cast-animation-overlay');

    // Determine animation class
    let animClass;
    if (resultClass === 'critical') {
      animClass = 'casting-anim-critical';
    } else if (resultClass === 'success' || resultClass === 'forced') {
      animClass = `casting-anim-${castingType}-success`;
    } else if (resultClass === 'fumble') {
      animClass = 'casting-anim-fumble';
    } else {
      animClass = 'casting-anim-fizzle';
    }

    // Remove any previous animation class from dialog
    dialog.classList.forEach(c => {
      if (c.startsWith('casting-anim-')) dialog.classList.remove(c);
    });

    // Apply animation to dialog (box-shadow based — cannot be clipped)
    void dialog.offsetWidth; // force reflow
    dialog.classList.add(animClass);

    // Also show the overlay for the gradient effect
    overlay.className = 'cast-animation-overlay';
    void overlay.offsetWidth;
    overlay.classList.add(animClass.replace('casting-anim-', 'anim-'));

    // Remove animation class after it completes
    setTimeout(() => {
      dialog.classList.remove(animClass);
      overlay.className = 'cast-animation-overlay hidden';
    }, 2500);
  },

  /**
   * Play a fullscreen success animation when Done is pressed (like Turn Undead)
   * @param {string} castingType - divine, arcane, sorcery, bardic
   * @param {string} resultClass - success, critical, forced
   * @param {Function} callback - called after animation completes
   */
  _playFullscreenCastAnimation(castingType, resultClass, callback) {
    const isCrit = (resultClass === 'critical');

    // Build animation content per casting type
    const configs = {
      divine: {
        icon: '✦',
        particles: Array.from({length: 8}, (_, i) => `<div class="spell-particle sp-divine" style="--i:${i}"></div>`).join(''),
        text: isCrit ? 'Divine Power Surges!' : 'The Gods Answer!',
        cssClass: 'spell-anim-divine'
      },
      arcane: {
        icon: '◆',
        particles: Array.from({length: 12}, (_, i) => `<div class="spell-particle sp-arcane" style="--i:${i}"></div>`).join(''),
        text: isCrit ? 'Arcane Mastery!' : 'Spell Woven!',
        cssClass: 'spell-anim-arcane'
      },
      sorcery: {
        icon: '🔥',
        particles: Array.from({length: 10}, (_, i) => `<div class="spell-particle sp-sorcery" style="--i:${i}"></div>`).join(''),
        text: isCrit ? 'Raw Power Unleashed!' : 'Sorcery Unleashed!',
        cssClass: 'spell-anim-sorcery'
      },
      bardic: {
        icon: '♪',
        particles: Array.from({length: 8}, (_, i) => `<div class="spell-particle sp-bardic" style="--i:${i}"></div>`).join(''),
        text: isCrit ? 'A Masterwork Performance!' : 'The Song Takes Hold!',
        cssClass: 'spell-anim-bardic'
      }
    };

    const cfg = configs[castingType] || configs.arcane;
    const critClass = isCrit ? ' spell-anim-critical' : '';

    const overlay = document.createElement('div');
    overlay.className = `spell-success-overlay ${cfg.cssClass}${critClass}`;
    overlay.innerHTML = `
      <div class="spell-success-content">
        <div class="spell-burst"></div>
        <div class="spell-ring"></div>
        <div class="spell-particles-container">${cfg.particles}</div>
        <div class="spell-success-icon">${cfg.icon}</div>
        <div class="spell-success-text">${cfg.text}</div>
      </div>
    `;
    document.body.appendChild(overlay);

    // Trigger entrance
    requestAnimationFrame(() => {
      overlay.classList.add('active');
    });

    // Fade out and remove
    const duration = isCrit ? 1800 : 1400;
    setTimeout(() => {
      overlay.classList.add('fade-out');
      setTimeout(() => {
        overlay.remove();
        if (callback) callback();
      }, 350);
    }, duration);
  },

  /**
   * Flash the spell row cast button (brief visual feedback)
   */
  _showCastButtonFeedback(btn, type) {
    if (!btn) return;
    btn.classList.remove('cast-success', 'cast-fail', 'cast-no-cost');
    btn.classList.add(type === 'success' ? 'cast-success' : 'cast-fail');
    setTimeout(() => {
      btn.classList.remove('cast-success', 'cast-fail');
    }, 1500);
  },

  // Keep legacy method name for compatibility
  showCastFeedback(btn, type) {
    this._showCastButtonFeedback(btn, type === 'success' ? 'success' : type === 'insufficient' ? 'fail' : 'fail');
  },
  
  /**
   * Populate spells for a specific class up to the given rank
   * @deprecated Use fillClassSpellsForRank() instead - this is kept for backwards compatibility
   */
  populateClassSpells(className, maxRank) {
    // No longer auto-populates - buttons handle this now
    this.updateSpellFillButtons();
  },
  
  /**
   * Remove all spells granted by a specific class
   * @deprecated Class spell removal is now manual via Clear All buttons
   */
  removeClassSpells(className) {
    // No longer auto-removes - user controls this via Clear All buttons
    this.updateSpellFillButtons();
  },
  
  /**
   * Get list of existing spells in a rank
   */
  getExistingSpellsInRank(rankKey) {
    const spells = [];
    const tbody = document.getElementById(`${rankKey}-body`);
    if (tbody) {
      Array.from(tbody.rows).forEach(tr => {
        const nameInput = tr.querySelector('.spell-name');
        if (nameInput && nameInput.value.trim()) {
          spells.push(nameInput.value.trim());
        }
      });
    }
    return spells;
  },
  
  /**
   * Alphabetize all spells across all ranks
   */
  alphabetizeAllSpells() {
    const rankKeys = ['cantrips', 'rank1', 'rank2', 'rank3', 'rank4', 'rank5'];
    
    rankKeys.forEach(rankKey => {
      this.alphabetizeSpellsInRank(rankKey);
    });
    
    this.scheduleAutoSave();
  },
  
  /**
   * Alphabetize spells within a single rank
   */
  alphabetizeSpellsInRank(rankKey) {
    const tbody = document.getElementById(`${rankKey}-body`);
    if (!tbody) return;
    
    // Collect all spell data from actual rows
    const spells = [];
    Array.from(tbody.rows).forEach(tr => {
      const nameInput = tr.querySelector('.spell-name');
      const costInput = tr.querySelector('.spell-cost');
      const memCheck = tr.querySelector('.spell-memorized');
      
      if (nameInput && nameInput.value.trim()) {
        spells.push({
          name: nameInput.value.trim(),
          cost: costInput ? costInput.value : '',
          memorized: memCheck ? memCheck.checked : false,
          classSpell: nameInput.dataset.classSpell || null
        });
      }
    });
    
    if (spells.length === 0) return;
    
    // Sort alphabetically
    spells.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
    
    // Clear all rows
    tbody.innerHTML = '';
    
    // Re-add in sorted order
    spells.forEach(spell => {
      this.addSpellRow(rankKey, spell);
    });
  },
  
  // ==================== CLASS ABILITIES AUTO-POPULATION ====================
  
  /**
   * Update class abilities when class or rank changes
   * Auto-populates special abilities based on class and rank
   */
  updateClassAbilities(previousClasses = null) {
    if (!window.ClassAbilities) return;
    
    // Check if ALL class fields are empty - if so, clear all class abilities
    // Check both DOM and saved character data (DOM may not be populated yet during init)
    const primaryClass = document.getElementById('class-primary')?.value?.trim() || '';
    const secondaryClass = document.getElementById('class-secondary')?.value?.trim() || '';
    const tertiaryClass = document.getElementById('class-tertiary')?.value?.trim() || '';
    
    // Also check saved character data
    const savedPrimary = this.character.info?.classPrimary || '';
    const savedSecondary = this.character.info?.classSecondary || '';
    const savedTertiary = this.character.info?.classTertiary || '';
    
    const hasClassInDOM = primaryClass || secondaryClass || tertiaryClass;
    const hasClassInSaved = savedPrimary || savedSecondary || savedTertiary;
    
    if (!hasClassInDOM && !hasClassInSaved) {
      // All class fields are empty in both DOM and saved data - clear all class abilities
      const container = document.getElementById('class-abilities-list');
      if (container) {
        container.innerHTML = '';
      }
      // Also clear from character data
      if (this.character.combat) {
        this.character.combat.specialAbilities = [];
      }
      this.scheduleAutoSave();
      return;
    }
    
    // If DOM is empty but saved data has classes, don't process further
    // (abilities will be loaded when populateForm runs)
    if (!hasClassInDOM && hasClassInSaved) {
      return;
    }
    
    // Get current classes and ranks
    const currentClasses = [
      {
        name: primaryClass.toLowerCase(),
        rank: parseInt(document.getElementById('rank-primary')?.value, 10) || 0
      },
      {
        name: secondaryClass.toLowerCase(),
        rank: parseInt(document.getElementById('rank-secondary')?.value, 10) || 0
      },
      {
        name: tertiaryClass.toLowerCase(),
        rank: parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0
      }
    ].filter(c => c.name && c.rank > 0);
    
    // Get classes that grant abilities
    const activeAbilityClasses = currentClasses.filter(c => 
      window.ClassAbilities.isAbilityGrantingClass(c.name)
    );
    
    // Check previous classes
    const previousAbilityClasses = previousClasses ? 
      previousClasses.filter(c => window.ClassAbilities.isAbilityGrantingClass(c.name)) : [];
    
    // Classes that were removed
    const removedClasses = previousAbilityClasses.filter(prev => 
      !activeAbilityClasses.some(curr => curr.name === prev.name)
    );
    
    // Remove abilities for classes that are no longer present
    removedClasses.forEach(removedClass => {
      this.removeClassAbilities(removedClass.name);
    });
    
    // Add/update abilities for active classes
    activeAbilityClasses.forEach(activeClass => {
      this.populateClassAbilities(activeClass.name, activeClass.rank);
    });
    
    // After updating abilities, check visibility of ability-related UI sections
    this.checkTurnUndeadVisibility();
    this.checkCommandingVisibility();
    this.checkHolyStrikeVisibility();
    this.checkLayOnHandsVisibility();
    this.checkDetectEvilVisibility();
    this.checkCureDiseaseVisibility();
    this.checkDivineProtectionVisibility();
    this.checkCircleOfPowerVisibility();
    this.checkImprovedAimVisibility();
    this.checkSpeciesEnemyVisibility();
    this.checkMentalStrengthVisibility();
    this.checkBerserkRageVisibility();
    this.checkJustAScratchVisibility();
    this.checkMysticHealingVisibility();
    this.checkPainControlVisibility();
    this.checkNertherWalkVisibility();
    this.checkQuiveringPalmVisibility();
    this.checkPerfectionVisibility();
    this.checkHolySmiteVisibility();
    this.checkPowerfulConcentrationVisibility();
    this.checkAnimalCompanionVisibility();
    this.checkShapeChangeVisibility();
    this.checkWeaponSpecVisibility();
    this.checkMonkAbilitiesVisibility();
    
    // Update weapon master tier (rank may have changed)
    if (this.character.weaponMaster) {
      const newTier = this.getWeaponMasterTier();
      if (newTier) {
        if (newTier !== this.character.weaponMaster.tier) {
          this.character.weaponMaster.tier = newTier;
          // If spec was active, recalculate to apply new tier effects
          if ((this.character.activeWeaponSpecs || []).length > 0) {
            this.captureBaselineIfNeeded();
            this.recalculateCombatBuffs();
            this.releaseBaselineIfClean();
          }
        }
      } else {
        // No longer qualifies — deactivate if active
        if ((this.character.activeWeaponSpecs || []).length > 0) {
          this.deactivateWeaponSpec();
        }
      }
      this.updateWeaponSpecDisplay();
      this.scheduleAutoSave();
    }
  },
  
  /**
   * Populate abilities for a specific class up to the given rank
   */
  populateClassAbilities(className, rank) {
    if (!window.ClassAbilities) return;
    
    const abilities = window.ClassAbilities.getAbilitiesForClassAndRank(className, rank);
    if (!abilities || abilities.length === 0) return;
    
    // Get existing abilities
    const existingAbilities = this.getAllSpecialAbilities();
    
    // Add each ability if not already present
    abilities.forEach(ability => {
      const normalizedAbility = ability.toLowerCase().trim();
      const alreadyExists = existingAbilities.some(existing => {
        const normalizedExisting = existing.toLowerCase().trim();
        // Exact match
        if (normalizedExisting === normalizedAbility) return true;
        // Handle "Weapon Specialization" matching "Weapon Specialization (Longsword)" etc.
        if (normalizedAbility === 'weapon specialization' && 
            normalizedExisting.startsWith('weapon specialization (')) return true;
        return false;
      });
      
      if (!alreadyExists) {
        this.addSpecialAbility(ability, className);
      }
    });
    
    // Handle special actions
    this.handleClassSpecialActions(className, rank);
    
    this.updateAllAbilityTooltips();
    this.scheduleAutoSave();
  },
  
  /**
   * Handle special class actions (Druid language, Monk unarmed, Sorcerer familiar)
   * Only triggers special actions if the corresponding class abilities have been acquired
   */
  handleClassSpecialActions(className, rank) {
    if (!window.ClassAbilities) return;
    
    const classKey = className.toLowerCase().trim();
    
    // Get current abilities on the sheet
    const existingAbilities = this.getAllSpecialAbilities().map(a => a.toLowerCase().trim());
    
    // Check all ranks up to current for special actions
    for (let r = 1; r <= rank; r++) {
      const actions = window.ClassAbilities.getSpecialActions(className, r);
      if (!actions) continue;
      
      // Add language (Druid/Rogue) - only if user has at least one rank 1 ability from that class
      if (actions.addLanguage) {
        const classRank1Abilities = window.ClassAbilities.getAbilitiesForClassAndRank(className, 1) || [];
        const hasAnyRank1Ability = classRank1Abilities.some(ability => 
          existingAbilities.includes(ability.toLowerCase().trim())
        );
        
        if (hasAnyRank1Ability) {
          this.addLanguageIfNotExists(actions.addLanguage);
        }
      }
      
      // Add/update Unarmed weapon (Monk) - only if user has Unarmed Proficiency
      if (actions.addUnarmed) {
        if (existingAbilities.includes('unarmed proficiency')) {
          this.addOrUpdateUnarmedWeapon(actions.addUnarmed);
        }
      }
      if (actions.changeUnarmedDamage) {
        if (existingAbilities.includes('unarmed proficiency')) {
          this.updateUnarmedDamage(actions.changeUnarmedDamage);
        }
      }
      
      // Add spell (Sorcerer Familiar) - always add if class is Sorcerer at rank 1+
      if (actions.addSpell) {
        this.addSpellIfNotExists(actions.addSpell.rank, actions.addSpell.spell);
      }
      
      // Add professional skills (Monk: Mysticism, Meditation)
      if (actions.addProfessionalSkills) {
        for (const skillName of actions.addProfessionalSkills) {
          this.addProfessionalSkillIfNotExists(skillName);
        }
      }
      
      // Auto-add class ability (e.g., Monk Rank 2: Immune to Disease)
      if (actions.addAbility) {
        this.addAbilityDirectly(actions.addAbility);
      }
    }
    
    // Cavalier Rank 2: Exotic Mounts I (Unicorn) - conditional on species, gender, and skills
    if (classKey === 'cavalier' && rank >= 2) {
      this.checkCavalierExoticMountsI();
    }
    
    // Cavalier Rank 3: Exotic Mounts II (Pegasus) - conditional on skills only
    if (classKey === 'cavalier' && rank >= 3) {
      this.checkCavalierExoticMountsII();
    }
    
    // Cavalier Rank 4: Exotic Mounts III (Hippogriff) - conditional on skills only
    if (classKey === 'cavalier' && rank >= 4) {
      this.checkCavalierExoticMountsIII();
    }
    
    // Cavalier Rank 5: Exotic Mounts IV (Griffon) - conditional on skills only
    if (classKey === 'cavalier' && rank >= 5) {
      this.checkCavalierExoticMountsIV();
    }
  },
  
  /**
   * Check and potentially add Exotic Mounts I for Cavalier at Rank 2+
   * Requirements:
   * - Species is NOT Half-orc (unicorns never trust half-orcs)
   * - Ride 60% or higher
   * - Female: Oath 60% or higher
   * - Male: Oath 80% or higher
   */
  checkCavalierExoticMountsI() {
    // Check if already has Exotic Mounts I (with or without Unicorn suffix)
    const existingAbilities = this.getAllSpecialAbilities().map(a => a.toLowerCase().trim());
    const hasExoticMountsI = existingAbilities.some(a => 
      a === 'exotic mounts i' || 
      a === 'exotic mounts 1' || 
      a.startsWith('exotic mounts i (') ||
      a.startsWith('exotic mounts 1 (')
    );
    
    if (hasExoticMountsI) {
      return; // Already has it
    }
    
    // Check species - half-orcs are never trusted by unicorns
    const species = (document.getElementById('species')?.value || '').toLowerCase().trim();
    if (species === 'half-orc' || species === 'halforc' || species === 'half orc') {
      console.log('Exotic Mounts I: Half-orcs are never trusted by unicorns');
      return;
    }
    
    // Check Ride skill >= 60%
    const rideValue = this.getSkillValueByName('ride');
    if (rideValue < 60) {
      console.log(`Exotic Mounts I: Ride ${rideValue}% is below required 60%`);
      return;
    }
    
    // Check Oath based on gender
    const gender = (document.getElementById('gender')?.value || '').toLowerCase().trim();
    const oathValue = this.getSkillValueByName('oath');
    
    // Determine required Oath threshold
    let requiredOath = 80; // Default to male requirement
    if (gender === 'female' || gender === 'f') {
      requiredOath = 60;
    }
    
    if (oathValue < requiredOath) {
      console.log(`Exotic Mounts I: Oath ${oathValue}% is below required ${requiredOath}% for ${gender || 'unknown'} gender`);
      return;
    }
    
    // All prerequisites met - add the ability
    console.log('Exotic Mounts I: All prerequisites met, adding ability');
    this.addSpecialAbility('Exotic Mounts I (Unicorn)', 'cavalier');
    this.scheduleAutoSave();
  },
  
  /**
   * Check and potentially add Exotic Mounts II for Cavalier at Rank 3+
   * Requirements:
   * - Ride 90% or higher
   * - Oath 90% or higher
   * - No species or gender restrictions (unlike unicorns)
   */
  checkCavalierExoticMountsII() {
    // Check if already has Exotic Mounts II (with or without Pegasus suffix)
    const existingAbilities = this.getAllSpecialAbilities().map(a => a.toLowerCase().trim());
    const hasExoticMountsII = existingAbilities.some(a => 
      a === 'exotic mounts ii' || 
      a === 'exotic mounts 2' || 
      a.startsWith('exotic mounts ii (') ||
      a.startsWith('exotic mounts 2 (')
    );
    
    if (hasExoticMountsII) {
      return; // Already has it
    }
    
    // Check Ride skill >= 90%
    const rideValue = this.getSkillValueByName('ride');
    if (rideValue < 90) {
      console.log(`Exotic Mounts II: Ride ${rideValue}% is below required 90%`);
      return;
    }
    
    // Check Oath >= 90%
    const oathValue = this.getSkillValueByName('oath');
    if (oathValue < 90) {
      console.log(`Exotic Mounts II: Oath ${oathValue}% is below required 90%`);
      return;
    }
    
    // All prerequisites met - add the ability
    console.log('Exotic Mounts II: All prerequisites met, adding ability');
    this.addSpecialAbility('Exotic Mounts II (Pegasus)', 'cavalier');
    this.scheduleAutoSave();
  },
  
  /**
   * Check and potentially add Exotic Mounts III for Cavalier at Rank 4+
   * Requirements:
   * - Ride 110% or higher
   * - Oath 110% or higher
   */
  checkCavalierExoticMountsIII() {
    // Check if already has Exotic Mounts III (with or without Hippogriff suffix)
    const existingAbilities = this.getAllSpecialAbilities().map(a => a.toLowerCase().trim());
    const hasExoticMountsIII = existingAbilities.some(a => 
      a === 'exotic mounts iii' || 
      a === 'exotic mounts 3' || 
      a.startsWith('exotic mounts iii (') ||
      a.startsWith('exotic mounts 3 (')
    );
    
    if (hasExoticMountsIII) {
      return; // Already has it
    }
    
    // Check Ride skill >= 110%
    const rideValue = this.getSkillValueByName('ride');
    if (rideValue < 110) {
      console.log(`Exotic Mounts III: Ride ${rideValue}% is below required 110%`);
      return;
    }
    
    // Check Oath >= 110%
    const oathValue = this.getSkillValueByName('oath');
    if (oathValue < 110) {
      console.log(`Exotic Mounts III: Oath ${oathValue}% is below required 110%`);
      return;
    }
    
    // All prerequisites met - add the ability
    console.log('Exotic Mounts III: All prerequisites met, adding ability');
    this.addSpecialAbility('Exotic Mounts III (Hippogriff)', 'cavalier');
    this.scheduleAutoSave();
  },
  
  /**
   * Check and potentially add Exotic Mounts IV for Cavalier at Rank 5
   * Requirements:
   * - Ride 130% or higher
   * - Oath 130% or higher
   */
  checkCavalierExoticMountsIV() {
    // Check if already has Exotic Mounts IV (with or without Griffon suffix)
    const existingAbilities = this.getAllSpecialAbilities().map(a => a.toLowerCase().trim());
    const hasExoticMountsIV = existingAbilities.some(a => 
      a === 'exotic mounts iv' || 
      a === 'exotic mounts 4' || 
      a.startsWith('exotic mounts iv (') ||
      a.startsWith('exotic mounts 4 (')
    );
    
    if (hasExoticMountsIV) {
      return; // Already has it
    }
    
    // Check Ride skill >= 130%
    const rideValue = this.getSkillValueByName('ride');
    if (rideValue < 130) {
      console.log(`Exotic Mounts IV: Ride ${rideValue}% is below required 130%`);
      return;
    }
    
    // Check Oath >= 130%
    const oathValue = this.getSkillValueByName('oath');
    if (oathValue < 130) {
      console.log(`Exotic Mounts IV: Oath ${oathValue}% is below required 130%`);
      return;
    }
    
    // All prerequisites met - add the ability
    console.log('Exotic Mounts IV: All prerequisites met, adding ability');
    this.addSpecialAbility('Exotic Mounts IV (Griffon)', 'cavalier');
    this.scheduleAutoSave();
  },
  
  /**
   * Add a language to the first empty language slot
   * Also adds "Language (X)" to Special Abilities for class-granted languages (unless skipAbility is true)
   */
  /**
   * Add a professional skill if it doesn't already exist
   * Sets it to base % (formula-calculated) if empty
   */
  addProfessionalSkillIfNotExists(skillName) {
    const normalized = skillName.toLowerCase().trim();
    
    // Check if it already exists in professional skills
    for (let i = 0; i < PROFESSIONAL_SKILL_SLOTS; i++) {
      const nameEl = document.getElementById(`prof-skill-${i}-name`);
      if (nameEl && nameEl.value.trim().toLowerCase() === normalized) {
        return; // Already exists
      }
    }
    
    // Find first empty slot
    for (let i = 0; i < PROFESSIONAL_SKILL_SLOTS; i++) {
      const nameEl = document.getElementById(`prof-skill-${i}-name`);
      if (nameEl && !nameEl.value.trim()) {
        nameEl.value = skillName;
        
        // Calculate base % from skill formula
        const profDefs = (typeof SKILL_DEFINITIONS !== 'undefined') ? SKILL_DEFINITIONS.professional : {};
        const def = profDefs[normalized];
        if (def && def.attrs) {
          let base = 0;
          for (const attr of def.attrs) {
            base += parseInt(this.character.attributes[attr]) || 0;
          }
          const currentEl = document.getElementById(`prof-skill-${i}-current`);
          if (currentEl && !currentEl.value) {
            currentEl.value = base;
          }
        }
        
        // Trigger blur to populate prereq keys and save
        nameEl.dispatchEvent(new Event('blur', { bubbles: true }));
        nameEl.dispatchEvent(new Event('change', { bubbles: true }));
        this.scheduleAutoSave();
        return;
      }
    }
  },

  addLanguageIfNotExists(languageName, sourceClass = null, skipAbility = false) {
    // Normalize apostrophes for comparison
    const normalizeApostrophes = (str) => str.replace(/[']/g, "'");
    const normalizedLangName = normalizeApostrophes(languageName.toLowerCase().trim());
    
    // Check native tongue first
    const nativeName = document.getElementById('native-tongue-name');
    if (nativeName) {
      const normalizedNative = normalizeApostrophes(nativeName.value.toLowerCase().trim());
      if (normalizedNative === normalizedLangName) {
        return; // Already exists as native tongue
      }
    }
    
    // Check if language already exists in additional languages
    const container = document.getElementById('language-container');
    if (container) {
      const rows = container.querySelectorAll('.language-row:not(.native)');
      for (const row of rows) {
        const nameInput = row.querySelector('.language-name');
        if (nameInput) {
          const normalizedExisting = normalizeApostrophes(nameInput.value.toLowerCase().trim());
          if (normalizedExisting === normalizedLangName) {
            return; // Already exists
          }
        }
      }
    }
    
    // Calculate base value (INT+CHA+40 for class-granted languages)
    const intVal = parseInt(document.getElementById('int-value')?.value, 10) || 0;
    const chaVal = parseInt(document.getElementById('cha-value')?.value, 10) || 0;
    const baseValue = intVal + chaVal + 40;
    
    // Determine source class for tracking
    let classSource = sourceClass;
    if (!classSource) {
      // Infer from language name
      if (languageName.toLowerCase().includes('druid')) {
        classSource = 'druid';
      } else if (languageName.toLowerCase().includes('thie')) {
        classSource = 'rogue';
      }
    }
    
    // Find first empty slot
    let foundEmptySlot = false;
    if (container) {
      const rows = container.querySelectorAll('.language-row:not(.native)');
      for (const row of rows) {
        const nameInput = row.querySelector('.language-name');
        if (nameInput && !nameInput.value.trim()) {
          // Found empty slot - populate it
          nameInput.value = languageName;
          if (classSource) {
            nameInput.dataset.classLanguage = classSource.toLowerCase();
          }
          
          // Set the base value to INT+CHA+40
          const baseSpan = row.querySelector('.language-base');
          if (baseSpan) {
            baseSpan.textContent = baseValue;
          }
          
          // Update formula display to show +40
          const formulaSpan = row.querySelector('.language-formula');
          if (formulaSpan) {
            formulaSpan.textContent = 'INT+CHA+40';
          }
          
          // Set the current value to base value
          const currentInput = row.querySelector('.language-input');
          if (currentInput) {
            currentInput.value = baseValue;
          }
          
          // Mark row as class-granted for styling/tracking
          row.dataset.classGranted = 'true';
          
          foundEmptySlot = true;
          break;
        }
      }
    }
    
    // No empty slots - add a new row
    if (!foundEmptySlot && container) {
      const rows = container.querySelectorAll('.language-row:not(.native)');
      const newIndex = rows.length + 2; // +2 because native is 1, first additional is 2
      
      const row = document.createElement('div');
      row.className = 'language-row';
      row.dataset.classGranted = 'true';
      row.innerHTML = `
        <input type="text" class="language-name" id="language-${newIndex}-name" placeholder="" value="${languageName}"${classSource ? ` data-class-language="${classSource.toLowerCase()}"` : ''}>
        <span class="language-formula">INT+CHA+40</span>
        <span class="language-base" id="language-${newIndex}-base">${baseValue}</span>
        <input type="number" class="language-input" id="language-${newIndex}-current" placeholder="" value="${baseValue}">
      `;
      container.appendChild(row);
      
      // Add event listeners with auto-remove on empty
      const nameInput = row.querySelector('.language-name');
      const currentInput = row.querySelector('.language-input');
      nameInput.addEventListener('blur', (e) => {
        if (e.target.value.trim()) {
          e.target.value = this.toTitleCase(e.target.value.trim());
        } else {
          row.remove();
          this.reindexLanguages();
        }
        this.scheduleAutoSave();
      });
      nameInput.addEventListener('input', () => this.scheduleAutoSave());
      currentInput.addEventListener('input', () => this.scheduleAutoSave());
    }
    
    // Also add to Special Abilities as "Language (X)" unless skipAbility is true
    if (!skipAbility) {
      const abilityName = `Language (${languageName})`;
      this.addAbilityToSheet(abilityName);
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Show modal for selecting Woodland Language
   */
  showWoodlandLanguagesModal() {
    const woodlandLanguages = [
      'Centaur', 'Dryad', 'Elvish', 'Faun', 'Gnome', 'Green Dragon',
      'Hill Giant', 'Lizardman', 'Manticore', 'Nixie', 'Pixie', 'Sprite', "Tree'nt"
    ];
    
    // Check which languages character already has
    const existingLanguages = this.getExistingLanguages();
    
    // Create modal overlay
    let overlay = document.getElementById('woodland-languages-modal');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'woodland-languages-modal';
      overlay.className = 'modal-overlay woodland-languages-modal';
      document.body.appendChild(overlay);
    }
    
    // Build language options
    const languageOptions = woodlandLanguages.map(lang => {
      const normalizedLang = lang.toLowerCase().replace(/[']/g, "'");
      const alreadyHas = existingLanguages.some(el => el.toLowerCase().replace(/[']/g, "'") === normalizedLang);
      return `
        <button type="button" class="woodland-lang-btn${alreadyHas ? ' disabled' : ''}" 
                data-language="${lang}" ${alreadyHas ? 'disabled' : ''}>
          ${lang}${alreadyHas ? ' ✓' : ''}
        </button>
      `;
    }).join('');
    
    overlay.innerHTML = `
      <div class="woodland-languages-modal-content">
        <h3>🌳 Woodland Languages</h3>
        <p class="woodland-modal-description">
          You are divinely granted the ability to fully comprehend the language of a specific woodland species at <strong>Base Level +40%</strong>.
          <br><br>Select a language to learn:
        </p>
        <div class="woodland-lang-grid">
          ${languageOptions}
        </div>
        <div class="woodland-modal-footer">
          <button type="button" class="btn btn-cancel" id="woodland-lang-cancel">Cancel</button>
        </div>
      </div>
    `;
    
    overlay.classList.remove('hidden');
    overlay.style.display = 'flex';
    
    // Add event listeners for language buttons
    const langButtons = overlay.querySelectorAll('.woodland-lang-btn:not(.disabled)');
    langButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const selectedLang = btn.dataset.language;
        this.addWoodlandLanguage(selectedLang);
        this.closeWoodlandLanguagesModal();
      });
    });
    
    const cancelBtn = overlay.querySelector('#woodland-lang-cancel');
    cancelBtn.addEventListener('click', () => this.closeWoodlandLanguagesModal());
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        this.closeWoodlandLanguagesModal();
      }
    });
  },
  
  /**
   * Close Woodland Languages modal
   */
  closeWoodlandLanguagesModal() {
    const overlay = document.getElementById('woodland-languages-modal');
    if (overlay) {
      overlay.style.display = 'none';
      overlay.classList.add('hidden');
    }
    // Clear stored input reference
    this._woodlandLanguagesInput = null;
  },
  
  /**
   * Get list of existing languages (names only)
   */
  getExistingLanguages() {
    const languages = [];
    
    // Check native tongue
    const nativeName = document.getElementById('native-tongue-name');
    if (nativeName && nativeName.value.trim()) {
      languages.push(nativeName.value.trim());
    }
    
    // Check additional languages
    const container = document.getElementById('language-container');
    if (container) {
      const rows = container.querySelectorAll('.language-row:not(.native)');
      for (const row of rows) {
        const nameInput = row.querySelector('.language-name');
        if (nameInput && nameInput.value.trim()) {
          languages.push(nameInput.value.trim());
        }
      }
    }
    
    return languages;
  },
  
  /**
   * Add a woodland language to the Languages section
   */
  addWoodlandLanguage(languageName) {
    console.log('addWoodlandLanguage called with:', languageName);
    
    // Add the language to Languages section with INT+CHA+40
    // Pass true for skipAbility - we only want "Woodland Languages" ability, not "Language (X)"
    this.addLanguageIfNotExists(languageName, 'druid', true);
    
    // Always try to add "Woodland Languages" ability
    // addAbilityDirectly will check if it's already in the DOM
    console.log('Adding Woodland Languages ability');
    this.addAbilityDirectly('Woodland Languages');
    
    // Clear the stored input reference
    this._woodlandLanguagesInput = null;
  },
  
  /**
   * Add ability directly without special handling (for Woodland Languages, Animal Companion)
   * This only checks DOM elements, not acquiredAbilities array
   */
  addAbilityDirectly(abilityName) {
    const container = document.getElementById('class-abilities-list');
    if (!container) {
      console.error('addAbilityDirectly: class-abilities-list not found');
      return false;
    }
    
    const normalizeApostrophes = (str) => str.replace(/[']/g, "'");
    const normalizedName = normalizeApostrophes(abilityName.toLowerCase().trim());
    
    // Check if ability already exists IN THE DOM ONLY (not acquiredAbilities)
    const existingInputs = container.querySelectorAll('.class-ability-input');
    for (const input of existingInputs) {
      if (input.value.trim()) {
        const normalizedExisting = normalizeApostrophes(input.value.trim().toLowerCase());
        if (normalizedExisting === normalizedName) {
          console.log('addAbilityDirectly: ability already in DOM:', abilityName);
          return true; // Already exists in DOM
        }
      }
    }
    
    // Find first empty slot
    let added = false;
    for (const input of existingInputs) {
      if (!input.value.trim()) {
        input.value = this.toTitleCase(abilityName);
        input.dataset.previousValue = input.value;
        this.updateAbilityTooltip(input);
        
        const infoBtn = input.parentElement?.querySelector('.class-ability-info-btn');
        if (infoBtn) {
          infoBtn.style.display = '';
        }
        
        console.log('addAbilityDirectly: added to empty slot:', abilityName);
        added = true;
        break;
      }
    }
    
    // No empty slot found - create new row
    if (!added) {
      console.log('addAbilityDirectly: creating new row for:', abilityName);
      this.addClassAbilityRow(abilityName);
    }
    
    // Sync to character data
    this.syncClassAbilitiesToCharacter();
    this.scheduleAutoSave();
    return true;
  },
  
  /**
   * Add or update Unarmed weapon for Monk
   */
  addOrUpdateUnarmedWeapon(damage) {
    // Find first melee weapon slot or existing Unarmed
    for (let i = 1; i <= 5; i++) {
      const nameInput = document.getElementById(`melee-${i}-name`);
      if (!nameInput) continue;
      
      if (nameInput.value.toLowerCase().trim() === 'unarmed') {
        // Update existing damage using baseDamage system
        const damageInput = document.getElementById(`melee-${i}-damage`);
        if (damageInput) {
          damageInput.dataset.baseDamage = damage;
          damageInput.dataset.weaponName = 'unarmed';
          damageInput.dataset.monkDamage = 'true';
          // Use composeDamage to get proper damage with best DM
          damageInput.value = window.WeaponData.composeDamage(damage, 'unarmed');
        }
        this.updateUnarmedAPHP();
        return;
      }
    }
    
    // Not found, add to first empty slot
    for (let i = 1; i <= 5; i++) {
      const nameInput = document.getElementById(`melee-${i}-name`);
      if (!nameInput) continue;
      
      if (!nameInput.value.trim()) {
        nameInput.value = 'Unarmed';
        nameInput.dataset.classWeapon = 'monk';
        
        const damageInput = document.getElementById(`melee-${i}-damage`);
        if (damageInput) {
          damageInput.dataset.baseDamage = damage;
          damageInput.dataset.weaponName = 'unarmed';
          damageInput.dataset.monkDamage = 'true';
          damageInput.value = window.WeaponData.composeDamage(damage, 'unarmed');
        }
        
        // Set size to S
        const sizeInput = document.getElementById(`melee-${i}-size`);
        if (sizeInput) sizeInput.value = 'S';
        
        // Set reach to T (touch)
        const reachInput = document.getElementById(`melee-${i}-reach`);
        if (reachInput) reachInput.value = 'T';
        
        this.updateUnarmedAPHP();
        return;
      }
    }
  },
  
  /**
   * Update Unarmed weapon damage (Monk rank progression)
   */
  updateUnarmedDamage(damage) {
    for (let i = 1; i <= 5; i++) {
      const nameInput = document.getElementById(`melee-${i}-name`);
      if (!nameInput) continue;
      
      if (nameInput.value.toLowerCase().trim() === 'unarmed') {
        const damageInput = document.getElementById(`melee-${i}-damage`);
        if (damageInput) {
          damageInput.dataset.baseDamage = damage;
          damageInput.dataset.weaponName = 'unarmed';
          damageInput.value = window.WeaponData.composeDamage(damage, 'unarmed');
        }
        return;
      }
    }
  },
  
  /**
   * Update Unarmed weapon AP/HP based on arm hit locations
   * AP = higher of R Arm AP or L Arm AP
   * HP = lower of R Arm current HP or L Arm current HP
   */
  updateUnarmedAPHP() {
    // Find arm location indices based on sheet type
    const locations = HIT_LOCATIONS[this.sheetType] || HIT_LOCATIONS.human;
    let rArmIdx = -1, lArmIdx = -1;
    locations.forEach((loc, i) => {
      if (loc.location === 'R Arm') rArmIdx = i;
      if (loc.location === 'L Arm') lArmIdx = i;
    });
    if (rArmIdx === -1 || lArmIdx === -1) return;
    
    // Read AP values (from armor AP inputs)
    const rArmAP = parseInt(document.getElementById(`loc-${rArmIdx}-ap`)?.value, 10) || 0;
    const lArmAP = parseInt(document.getElementById(`loc-${lArmIdx}-ap`)?.value, 10) || 0;
    const higherAP = Math.max(rArmAP, lArmAP);
    
    // Read current HP values
    const rArmHP = parseInt(document.getElementById(`loc-${rArmIdx}-current`)?.value, 10) || 0;
    const lArmHP = parseInt(document.getElementById(`loc-${lArmIdx}-current`)?.value, 10) || 0;
    const lowerHP = Math.min(rArmHP, lArmHP);
    
    // Find unarmed weapon and set AP/HP
    for (let i = 1; i <= 5; i++) {
      const nameInput = document.getElementById(`melee-${i}-name`);
      if (!nameInput || nameInput.value.toLowerCase().trim() !== 'unarmed') continue;
      
      const aphpInput = document.getElementById(`melee-${i}-aphp`);
      if (aphpInput) {
        aphpInput.value = `${higherAP}/${lowerHP}`;
        aphpInput.title = `AP: higher arm (R:${rArmAP}/L:${lArmAP}), HP: lower arm (R:${rArmHP}/L:${lArmHP})`;
      }
      break;
    }
  },
  
  /**
   * Add a spell if it doesn't already exist
   */
  addSpellIfNotExists(rankKey, spellName) {
    // Check if spell already exists in this rank
    const existingSpells = this.getExistingSpellsInRank(rankKey);
    const normalizedSpell = spellName.toLowerCase().trim();
    
    if (existingSpells.some(s => s.toLowerCase().trim() === normalizedSpell)) {
      return; // Already exists
    }
    
    const cost = window.SpellData ? window.SpellData.getSpellCost(spellName) : '';
    
    this.addSpellRow(rankKey, {
      name: spellName,
      cost: cost || '',
      memorized: false,
      classSpell: 'sorcerer'
    });
  },
  
  /**
   * Remove abilities granted by a class (both auto-granted and purchased ranked abilities)
   */
  removeClassAbilities(className) {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    // Get auto-granted class abilities
    const classAbilities = window.ClassAbilities ? 
      (window.ClassAbilities.getAllAbilitiesForClass(className) || []) : [];
    
    // Get ranked purchasable abilities for this class
    const rankedAbilities = window.RANKED_CLASS_ABILITIES && window.RANKED_CLASS_ABILITIES[className.toLowerCase()] ?
      window.RANKED_CLASS_ABILITIES[className.toLowerCase()].map(a => a.name) : [];
    
    // Combine both lists
    const allClassAbilities = [...classAbilities, ...rankedAbilities];
    if (allClassAbilities.length === 0) return;
    
    // Normalize for comparison
    const normalizedClassAbilities = allClassAbilities.map(a => a.toLowerCase().trim());
    
    // Track abilities that were actually removed
    const removedAbilities = [];
    
    // Check each ability input in the dynamic list
    const inputs = container.querySelectorAll('.class-ability-input');
    inputs.forEach(input => {
      if (!input.value.trim()) return;
      
      const ability = input.value.toLowerCase().trim();
      // Also check without parenthetical suffixes (e.g., "Language (Thieves' Cant)" -> "language (thieves' cant)")
      const abilityBase = ability;
      
      // Check if this ability belongs to the removed class
      if (normalizedClassAbilities.some(ca => abilityBase.startsWith(ca.toLowerCase()) || ca.toLowerCase() === abilityBase)) {
        // Check if another class also grants this ability
        const otherClassesGrant = this.abilityGrantedByOtherClass(ability, className) || 
                                  this.rankedAbilityGrantedByOtherClass(ability, className);
        
        if (!otherClassesGrant) {
          removedAbilities.push(input.value.trim()); // Store original case
          input.value = '';
          input.title = 'Enter a Special Ability name';
          input.classList.remove('duplicate-warning');
          delete input.dataset.classAbility;
          
          // Hide info button
          const infoBtn = input.parentElement?.querySelector('.class-ability-info-btn');
          if (infoBtn) infoBtn.style.display = 'none';
        }
      }
    });
    
    // Also remove from acquiredAbilities tracking
    if (this.character.acquiredAbilities && removedAbilities.length > 0) {
      this.character.acquiredAbilities = this.character.acquiredAbilities.filter(a => {
        const normalizedAcquired = a.toLowerCase().trim();
        return !removedAbilities.some(r => r.toLowerCase().trim() === normalizedAcquired);
      });
    }
    
    // Also remove any ranked abilities from acquiredAbilities that belong to this class
    // (even if they weren't on the sheet)
    if (this.character.acquiredAbilities) {
      const rankedAbilitiesLower = rankedAbilities.map(a => a.toLowerCase().trim());
      this.character.acquiredAbilities = this.character.acquiredAbilities.filter(a => {
        const normalizedAcquired = a.toLowerCase().trim();
        // Check if this is a ranked ability for the removed class
        const isRankedForClass = rankedAbilitiesLower.some(ra => 
          normalizedAcquired === ra || normalizedAcquired.startsWith(ra.split('(')[0].trim())
        );
        if (isRankedForClass) {
          // Check if another class also has this ranked ability
          return this.rankedAbilityGrantedByOtherClass(a, className);
        }
        return true;
      });
    }
    
    // Handle removal of special class features
    this.removeClassSpecialFeatures(className);
    
    this.scheduleAutoSave();
  },
  
  /**
   * Check if a ranked ability is available from another active class
   */
  rankedAbilityGrantedByOtherClass(abilityName, excludeClass) {
    if (!window.RANKED_CLASS_ABILITIES) return false;
    
    const currentClasses = [
      document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || ''
    ].filter(c => c && c !== excludeClass.toLowerCase());
    
    const normalizedAbility = abilityName.toLowerCase().trim();
    
    for (const cls of currentClasses) {
      const rankedAbilities = window.RANKED_CLASS_ABILITIES[cls];
      if (rankedAbilities) {
        if (rankedAbilities.some(a => {
          const abilityLower = a.name.toLowerCase().trim();
          return normalizedAbility === abilityLower || 
                 normalizedAbility.startsWith(abilityLower.split('(')[0].trim());
        })) {
          return true;
        }
      }
    }
    
    return false;
  },
  
  /**
   * Check if an ability is granted by another active class
   */
  abilityGrantedByOtherClass(abilityName, excludeClass) {
    if (!window.ClassAbilities) return false;
    
    const currentClasses = [
      { name: document.getElementById('class-primary')?.value?.trim().toLowerCase() || '', 
        rank: parseInt(document.getElementById('rank-primary')?.value, 10) || 0 },
      { name: document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '', 
        rank: parseInt(document.getElementById('rank-secondary')?.value, 10) || 0 },
      { name: document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || '', 
        rank: parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0 }
    ].filter(c => c.name && c.rank > 0 && c.name !== excludeClass.toLowerCase());
    
    const normalizedAbility = abilityName.toLowerCase().trim();
    
    for (const cls of currentClasses) {
      const abilities = window.ClassAbilities.getAbilitiesForClassAndRank(cls.name, cls.rank);
      if (abilities.some(a => a.toLowerCase().trim() === normalizedAbility)) {
        return true;
      }
    }
    
    return false;
  },
  
  /**
   * Remove special class features when class is dropped
   */
  removeClassSpecialFeatures(className) {
    const classKey = className.toLowerCase().trim();
    
    // Track removed language abilities for acquiredAbilities cleanup
    const removedLanguageAbilities = [];
    
    // Remove Druid's Cant language
    if (classKey === 'druid') {
      for (let i = 2; i <= 7; i++) {
        const nameInput = document.getElementById(`language-${i}-name`);
        const currentInput = document.getElementById(`language-${i}-current`);
        if (nameInput) {
          // Normalize apostrophes for comparison
          const langName = nameInput.value.toLowerCase().trim().replace(/[']/g, "'");
          // Check by dataset OR by language name
          if (nameInput.dataset.classLanguage === 'druid' || 
              langName === "druids' cant" || langName === "druid's cant") {
            removedLanguageAbilities.push("Language (Druids' Cant)");
            removedLanguageAbilities.push("Language (Druids' Cant)");
            nameInput.value = '';
            if (currentInput) currentInput.value = '';
            delete nameInput.dataset.classLanguage;
          }
        }
      }
    }
    
    // Remove Thieves' Cant language
    if (classKey === 'rogue') {
      for (let i = 2; i <= 7; i++) {
        const nameInput = document.getElementById(`language-${i}-name`);
        const currentInput = document.getElementById(`language-${i}-current`);
        if (nameInput) {
          // Normalize apostrophes for comparison
          const langName = nameInput.value.toLowerCase().trim().replace(/[']/g, "'");
          // Check by dataset OR by language name
          if (nameInput.dataset.classLanguage === 'rogue' || 
              langName === "thieves' cant" || langName === "thief's cant") {
            removedLanguageAbilities.push("Language (Thieves' Cant)");
            removedLanguageAbilities.push("Language (Thieves' Cant)");
            nameInput.value = '';
            if (currentInput) currentInput.value = '';
            delete nameInput.dataset.classLanguage;
          }
        }
      }
    }
    
    // Bards can also have Druids' Cant or Thieves' Cant from ranked abilities
    if (classKey === 'bard') {
      // Always remove these from acquiredAbilities for Bards, regardless of Languages section state
      removedLanguageAbilities.push("Language (Druids' Cant)");
      removedLanguageAbilities.push("Language (Thieves' Cant)");
      // Also add variants with straight apostrophes
      removedLanguageAbilities.push("Language (Druids' Cant)");
      removedLanguageAbilities.push("Language (Thieves' Cant)");
      
      for (let i = 2; i <= 7; i++) {
        const nameInput = document.getElementById(`language-${i}-name`);
        const currentInput = document.getElementById(`language-${i}-current`);
        if (nameInput) {
          // Normalize apostrophes for comparison (both curly ' and straight ')
          const langName = nameInput.value.toLowerCase().trim().replace(/[']/g, "'");
          // Check by dataset OR by language name for bard languages
          const isBardLanguage = nameInput.dataset.classLanguage === 'bard' ||
            langName === "druids' cant" || langName === "druid's cant" ||
            langName === "thieves' cant" || langName === "thief's cant";
          
          if (isBardLanguage) {
            nameInput.value = '';
            if (currentInput) currentInput.value = '';
            delete nameInput.dataset.classLanguage;
          }
        }
      }
    }
    
    // Remove from acquiredAbilities tracking
    if (this.character.acquiredAbilities && removedLanguageAbilities.length > 0) {
      this.character.acquiredAbilities = this.character.acquiredAbilities.filter(a => {
        // Normalize apostrophes for comparison
        const normalizedA = a.toLowerCase().trim().replace(/[']/g, "'");
        return !removedLanguageAbilities.some(r => {
          const normalizedR = r.toLowerCase().trim().replace(/[']/g, "'");
          return normalizedR === normalizedA;
        });
      });
    }
    
    // Also remove Language abilities from Special Abilities section
    if (removedLanguageAbilities.length > 0) {
      this.removeLanguageAbilitiesFromSheet(removedLanguageAbilities);
    }
    
    // Remove Monk's Unarmed weapon
    if (classKey === 'monk') {
      for (let i = 1; i <= 5; i++) {
        const nameInput = document.getElementById(`melee-${i}-name`);
        if (nameInput && nameInput.dataset.classWeapon === 'monk') {
          nameInput.value = '';
          delete nameInput.dataset.classWeapon;
          
          const damageInput = document.getElementById(`melee-${i}-damage`);
          if (damageInput) {
            damageInput.value = '';
            delete damageInput.dataset.monkDamage;
          }
          
          const sizeInput = document.getElementById(`melee-${i}-size`);
          if (sizeInput) sizeInput.value = '';
          
          const reachInput = document.getElementById(`melee-${i}-reach`);
          if (reachInput) reachInput.value = '';
        }
      }
    }
    
    // Remove Sorcerer's Familiar spell
    if (classKey === 'sorcerer') {
      const tbody = document.getElementById('rank1-body');
      if (tbody) {
        Array.from(tbody.rows).forEach(tr => {
          const nameInput = tr.querySelector('.spell-name');
          if (nameInput && nameInput.value.toLowerCase().trim() === 'familiar' && 
              nameInput.dataset.classSpell === 'sorcerer') {
            tr.remove();
          }
        });
        this.reindexSpellRows('rank1');
      }
    }
    
    // Remove Fighter's Weapon Master data
    if (classKey === 'fighter') {
      if (this.character.weaponMaster) {
        // Deactivate spec if it was the mastered weapon
        if ((this.character.activeWeaponSpecs || []).length > 0) {
          this.deactivateWeaponSpec();
        }
        delete this.character.weaponMaster;
      }
    }
  },
  
  /**
   * Clean up orphaned class features (Cants without abilities, etc.)
   * Called on init to fix corrupted data
   */
  cleanupOrphanedClassFeatures() {
    if (!window.ClassAbilities) return;
    
    const existingAbilities = this.getAllSpecialAbilities().map(a => a.toLowerCase().trim());
    
    // Check for Druids' Cant without Druid abilities
    const druidRank1 = (window.ClassAbilities.getAbilitiesForClassAndRank('druid', 1) || [])
      .map(a => a.toLowerCase().trim());
    const hasDruidAbilities = druidRank1.some(ability => existingAbilities.includes(ability));
    
    if (!hasDruidAbilities) {
      // Remove orphaned Druids' Cant
      for (let i = 2; i <= 7; i++) {
        const nameInput = document.getElementById(`language-${i}-name`);
        const currentInput = document.getElementById(`language-${i}-current`);
        if (nameInput) {
          // Normalize apostrophes for comparison
          const langName = nameInput.value.toLowerCase().trim().replace(/[']/g, "'");
          if (langName === "druids' cant" || langName === "druid's cant") {
            nameInput.value = '';
            if (currentInput) currentInput.value = '';
            delete nameInput.dataset.classLanguage;
          }
        }
      }
    }
    
    // Check for Thieves' Cant without Rogue abilities
    const rogueRank1 = (window.ClassAbilities.getAbilitiesForClassAndRank('rogue', 1) || [])
      .map(a => a.toLowerCase().trim());
    const hasRogueAbilities = rogueRank1.some(ability => existingAbilities.includes(ability));
    
    if (!hasRogueAbilities) {
      // Remove orphaned Thieves' Cant
      for (let i = 2; i <= 7; i++) {
        const nameInput = document.getElementById(`language-${i}-name`);
        const currentInput = document.getElementById(`language-${i}-current`);
        if (nameInput) {
          // Normalize apostrophes for comparison
          const langName = nameInput.value.toLowerCase().trim().replace(/[']/g, "'");
          if (langName === "thieves' cant" || langName === "thief's cant") {
            nameInput.value = '';
            if (currentInput) currentInput.value = '';
            delete nameInput.dataset.classLanguage;
          }
        }
      }
    }
    
    // Clean up orphaned acquiredAbilities - remove entries that aren't on the sheet or in languages
    this.cleanupOrphanedAcquiredAbilities();
  },
  
  /**
   * Remove acquiredAbilities entries that don't correspond to actual abilities on the sheet
   */
  cleanupOrphanedAcquiredAbilities() {
    if (!this.character.acquiredAbilities || this.character.acquiredAbilities.length === 0) return;
    
    // Get all abilities currently on the sheet
    const sheetAbilities = new Set();
    const container = document.getElementById('class-abilities-list');
    if (container) {
      const inputs = container.querySelectorAll('.class-ability-input');
      inputs.forEach(input => {
        if (input.value.trim()) {
          sheetAbilities.add(input.value.trim().toLowerCase());
        }
      });
    }
    
    // Get all languages on the sheet (for Language abilities)
    const languages = new Set();
    const nativeName = document.getElementById('native-tongue-name')?.value?.trim();
    if (nativeName) {
      languages.add(`language (${nativeName.toLowerCase()})`);
    }
    for (let i = 2; i <= 7; i++) {
      const langName = document.getElementById(`language-${i}-name`)?.value?.trim();
      if (langName) {
        languages.add(`language (${langName.toLowerCase()})`);
      }
    }
    
    // Filter acquiredAbilities to only include those actually present
    this.character.acquiredAbilities = this.character.acquiredAbilities.filter(ability => {
      const normalized = ability.toLowerCase().trim();
      
      // Check if it's on the abilities sheet
      if (sheetAbilities.has(normalized)) return true;
      
      // Check if it's a language ability that exists
      if (normalized.startsWith('language (') && languages.has(normalized)) return true;
      
      // Also keep Characteristic Increase entries (they're tracked differently)
      if (normalized.startsWith('characteristic increase')) return true;
      
      // Not found - remove from tracking
      return false;
    });
  },
  
  /**
   * Get all current special abilities (class abilities)
   */
  getAllSpecialAbilities() {
    const abilities = [];
    const container = document.getElementById('class-abilities-list');
    if (container) {
      const inputs = container.querySelectorAll('.class-ability-input');
      inputs.forEach(input => {
        if (input.value.trim()) {
          abilities.push(input.value.trim());
        }
      });
    }
    return abilities;
  },
  
  /**
   * Remove Language abilities from Class Abilities section
   */
  removeLanguageAbilitiesFromSheet(languageAbilities) {
    const normalizeApostrophes = (str) => str.replace(/[']/g, "'");
    const normalizedTargets = languageAbilities.map(a => normalizeApostrophes(a.toLowerCase().trim()));
    
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    const rows = Array.from(container.querySelectorAll('.class-ability-row'));
    rows.forEach(row => {
      const input = row.querySelector('.class-ability-input');
      if (input && input.value.trim()) {
        const normalizedValue = normalizeApostrophes(input.value.toLowerCase().trim());
        if (normalizedTargets.includes(normalizedValue)) {
          row.remove();
        }
      }
    });
    
    this.reindexClassAbilityRows();
  },
  
  /**
   * Add a special ability (alias for addClassAbilityRow for compatibility)
   */
  addSpecialAbility(abilityName, sourceClass = null) {
    return this.addClassAbilityRow(abilityName, sourceClass);
  },
  
  /**
   * Set up syncing between magic skill inputs on page 1 and page 2
   */
  setupMagicSkillSync() {
    const syncInputs = document.querySelectorAll('.sync-magic');
    
    syncInputs.forEach(input => {
      const syncTargetId = input.dataset.sync;
      const syncTarget = document.getElementById(syncTargetId);
      
      if (syncTarget) {
        // Sync from page 2 to page 1
        input.addEventListener('input', () => {
          syncTarget.value = input.value;
          // Also save to character data
          const key = this.camelCase(syncTargetId);
          if (this.character.magic) {
            this.character.magic[key] = input.value;
          }
          this.scheduleAutoSave();
        });
        
        // Sync from page 1 to page 2
        syncTarget.addEventListener('input', () => {
          input.value = syncTarget.value;
        });
      }
    });
    
    // Add special sync for Musicianship (magic page -> professional skills)
    const musicianshipMagic = document.getElementById('musicianship-percent');
    if (musicianshipMagic) {
      musicianshipMagic.addEventListener('input', () => {
        this.syncMusicianshipToProfSkills(musicianshipMagic.value);
      });
    }
  },

  /**
   * Sync Musicianship from magic page to Professional Skills (if user is a Bard)
   */
  syncMusicianshipToProfSkills(value) {
    // Check if user is a Bard
    const classes = [
      document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || ''
    ].filter(c => c);
    
    if (!classes.includes('bard')) return;
    
    // Find Musicianship in professional skills
    const container = document.getElementById('professional-skills-container');
    if (!container) return;
    
    const rows = container.querySelectorAll('.professional-skill-row');
    rows.forEach(row => {
      const nameInput = row.querySelector('.prof-skill-name');
      const currentInput = row.querySelector('.prof-skill-current');
      if (nameInput && currentInput) {
        const skillName = nameInput.value.trim().toLowerCase();
        if (skillName.startsWith('musicianship')) {
          if (currentInput.value !== value) {
            currentInput.value = value;
          }
        }
      }
    });
  },
  
  /**
   * Sync magic skill values from page 1 to page 2 (call after populateForm)
   */
  syncMagicSkillValues() {
    const syncInputs = document.querySelectorAll('.sync-magic');
    
    syncInputs.forEach(input => {
      const syncTargetId = input.dataset.sync;
      const syncTarget = document.getElementById(syncTargetId);
      
      if (syncTarget) {
        input.value = syncTarget.value;
      }
    });
    
    // Also sync from Professional Skills to Magic page
    this.syncProfessionalSkillsToMagicPage();
  },
  
  /**
   * Sync magic skill values from Professional Skills to Magic page
   * Called on load to ensure Magic page reflects Professional Skills values
   */
  syncProfessionalSkillsToMagicPage() {
    // Iterate through all professional skill slots
    for (let i = 0, _n = this._profSkillRowCount(); i < _n; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      const currentInput = document.getElementById(`prof-skill-${i}-current`);
      
      if (!nameInput || !currentInput) continue;
      
      const skillName = nameInput.value.toLowerCase().replace(/\s*\(.*\)/, '').trim();
      if (!skillName) continue;
      
      // Check if this is a magic skill
      const config = this.MAGIC_SKILL_CONFIG[skillName];
      if (!config) continue;
      
      // Sync to magic page if professional skill has a value
      // Don't check class relevance - if the skill exists in Prof Skills, sync it
      const profValue = currentInput.value;
      if (profValue !== '' && profValue !== null && profValue !== undefined) {
        const magicInput = document.getElementById(config.magicId);
        if (magicInput) {
          magicInput.value = profValue;
          // Dispatch events so any listeners update
          magicInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
      }
    }
  },
  
  /**
   * Magic skills configuration - maps skill names to magic page field IDs and class requirements
   */
  _profSkillRowCount() {
    const container = document.getElementById('professional-skills-container');
    return container ? container.querySelectorAll('.professional-skill-row').length : 0;
  },

  MAGIC_SKILL_CONFIG: {
    'channel': { magicId: 'channel-percent', classes: ['cleric', 'ranger', 'paladin', 'anti-paladin', 'druid'] },
    'piety': { magicId: 'piety-percent', classes: ['cleric', 'ranger', 'paladin', 'anti-paladin', 'druid'] },
    'arcane casting': { magicId: 'arcane-casting-percent', classes: ['mage'] },
    'arcane knowledge': { magicId: 'arcane-knowledge-percent', classes: ['mage'] },
    'arcane sorcery': { magicId: 'arcane-sorcery-percent', classes: ['sorcerer'] },
    'sorcerous wisdom': { magicId: 'sorcerous-wisdom-percent', classes: ['sorcerer'] },
    'musicianship': { magicId: 'musicianship-percent', classes: ['bard'] },
    'lyrical magic': { magicId: 'lyrical-magic-percent', classes: ['bard'] }
  },
  
  /**
   * Get current character classes (lowercase)
   */
  getCurrentClasses() {
    return [
      document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || ''
    ].filter(c => c);
  },
  
  /**
   * Check if a magic skill is relevant to current classes
   */
  isMagicSkillRelevant(skillName) {
    const normalizedName = skillName.toLowerCase().replace(/\s*\(.*\)/, '').trim();
    const config = this.MAGIC_SKILL_CONFIG[normalizedName];
    if (!config) return false;
    
    const currentClasses = this.getCurrentClasses();
    return config.classes.some(cls => currentClasses.includes(cls));
  },
  
  /**
   * Sync a professional skill to the magic page (when pro skill value changes)
   */
  syncProfSkillToMagic(profSkillIndex) {
    const nameInput = document.getElementById(`prof-skill-${profSkillIndex}-name`);
    const currentInput = document.getElementById(`prof-skill-${profSkillIndex}-current`);
    
    if (!nameInput || !currentInput) return;
    
    const skillName = nameInput.value.toLowerCase().replace(/\s*\(.*\)/, '').trim();
    const config = this.MAGIC_SKILL_CONFIG[skillName];
    
    if (!config) return;
    if (!this.isMagicSkillRelevant(skillName)) return;
    
    const magicInput = document.getElementById(config.magicId);
    if (magicInput && magicInput.value !== currentInput.value) {
      magicInput.value = currentInput.value;
      magicInput.dispatchEvent(new Event('input', { bubbles: true }));
      magicInput.dispatchEvent(new Event('change', { bubbles: true }));
    }
  },
  
  /**
   * Sync a magic skill to professional skills (when magic page value changes)
   */
  syncMagicToProfSkill(magicFieldId, value) {
    // Find which skill this magic field represents
    let targetSkillName = null;
    let targetConfig = null;
    for (const [skillName, config] of Object.entries(this.MAGIC_SKILL_CONFIG)) {
      if (config.magicId === magicFieldId) {
        targetSkillName = skillName;
        targetConfig = config;
        break;
      }
    }
    
    if (!targetSkillName) return;
    if (!this.isMagicSkillRelevant(targetSkillName)) return;
    
    // Find this skill in professional skills
    for (let i = 0, _n = this._profSkillRowCount(); i < _n; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      const currentInput = document.getElementById(`prof-skill-${i}-current`);
      
      if (nameInput && currentInput) {
        const profSkillName = nameInput.value.toLowerCase().replace(/\s*\(.*\)/, '').trim();
        if (profSkillName === targetSkillName) {
          if (currentInput.value !== value) {
            currentInput.value = value;
            // Update original value for penalty tracking
            if (currentInput.dataset.originalValue !== undefined) {
              currentInput.dataset.originalValue = value;
            }
            this.updateProfessionalSkillData(i);
          }
          return; // Found and updated
        }
      }
    }
    
    // Skill not found in professional skills — auto-add it
    if (value && value.trim()) {
      this._addMagicSkillToProfessional(targetSkillName, targetConfig, value);
    }
  },
  
  /**
   * Add a magic skill to professional skills (creates a new row if needed)
   */
  _addMagicSkillToProfessional(skillName, config, value) {
    const titleName = this.toTitleCase(skillName);
    
    // First try to find an existing empty slot
    const container = document.getElementById('professional-skills-container');
    if (!container) return;
    const existingRows = container.querySelectorAll('.professional-skill-row');
    
    for (let i = 0; i < existingRows.length; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      if (nameInput && !nameInput.value.trim()) {
        // Found empty slot
        nameInput.value = titleName;
        nameInput.dataset.previousName = titleName;
        const baseInput = document.getElementById(`prof-skill-${i}-base`);
        const currentInput = document.getElementById(`prof-skill-${i}-current`);
        if (baseInput) this.autoFillProfessionalSkillFormula(nameInput, baseInput);
        if (currentInput) currentInput.value = value;
        this.updateProfessionalSkillData(i);
        this.calculateProfessionalSkillBase(i);
        this.updateProfSkillEncIndicator(i);
        return;
      }
    }
    
    // No empty slot — add a new row (without stealing focus)
    this.addProfessionalSkillRow(false);
    
    // The new row is now the last row
    const rows = container.querySelectorAll('.professional-skill-row');
    const newIndex = rows.length - 1;
    const nameInput = document.getElementById(`prof-skill-${newIndex}-name`);
    const baseInput = document.getElementById(`prof-skill-${newIndex}-base`);
    const currentInput = document.getElementById(`prof-skill-${newIndex}-current`);
    
    if (nameInput) {
      nameInput.value = titleName;
      nameInput.dataset.previousName = titleName;
    }
    if (baseInput) this.autoFillProfessionalSkillFormula(nameInput, baseInput);
    if (currentInput) currentInput.value = value;
    this.updateProfessionalSkillData(newIndex);
    this.calculateProfessionalSkillBase(newIndex);
    this.updateProfSkillEncIndicator(newIndex);
  },
  
  /**
   * Handle professional skill deletion - also clear magic skill if applicable
   */
  handleProfSkillDeletion(profSkillIndex, previousSkillName) {
    if (!previousSkillName) return;
    
    const normalizedName = previousSkillName.toLowerCase().replace(/\s*\(.*\)/, '').trim();
    const config = this.MAGIC_SKILL_CONFIG[normalizedName];
    
    if (!config) return;
    
    // Clear the magic page field
    const magicInput = document.getElementById(config.magicId);
    if (magicInput && magicInput.value) {
      magicInput.value = '';
      magicInput.dispatchEvent(new Event('input', { bubbles: true }));
      magicInput.dispatchEvent(new Event('change', { bubbles: true }));
    }
  },
  
  /**
   * Check for duplicate magic skills in professional skills
   */
  checkForDuplicateMagicSkill(skillName, excludeIndex) {
    const normalizedName = skillName.toLowerCase().replace(/\s*\(.*\)/, '').trim();
    
    // Check if it's a magic skill
    if (!this.MAGIC_SKILL_CONFIG[normalizedName]) return false;
    
    // Check other professional skill slots
    for (let i = 0, _n = this._profSkillRowCount(); i < _n; i++) {
      if (i === excludeIndex) continue;
      
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      if (nameInput) {
        const existingName = nameInput.value.toLowerCase().replace(/\s*\(.*\)/, '').trim();
        if (existingName === normalizedName) {
          return true; // Duplicate found
        }
      }
    }
    return false;
  },
  
  /**
   * Setup magic skill sync listeners on magic page inputs
   */
  setupMagicSkillSyncListeners() {
    Object.values(this.MAGIC_SKILL_CONFIG).forEach(config => {
      const magicInput = document.getElementById(config.magicId);
      if (magicInput) {
        magicInput.addEventListener('input', (e) => {
          this.syncMagicToProfSkill(config.magicId, e.target.value);
        });
      }
    });

    // Also setup originalValue tracking for all magic skill inputs
    // so ENC/Fatigue penalty system works correctly on user edits
    const magicSkillIds = [
      'channel-percent', 'piety-percent',
      'arcane-casting-percent', 'arcane-knowledge-percent',
      'arcane-sorcery-percent', 'sorcerous-wisdom-percent',
      'musicianship-percent', 'lyrical-magic-percent'
    ];
    magicSkillIds.forEach(id => {
      const input = document.getElementById(id);
      if (!input) return;
      input.addEventListener('input', (e) => {
        if (e.target.classList.contains('enc-penalized-value') || e.target.classList.contains('fatigue-penalized')) {
          // User editing a penalized field — treat as new original
          e.target.dataset.originalValue = e.target.value;
          setTimeout(() => this.applyAllPenalties(), 10);
        } else {
          if (e.target.dataset.originalValue !== undefined) {
            e.target.dataset.originalValue = e.target.value;
          }
        }
      });
    });
  },
  
  /**
   * Remove magic skills from Professional Skills when their class is no longer present
   */
  removeObsoleteMagicSkills() {
    const currentClasses = this.getCurrentClasses();
    
    // Check each professional skill slot
    for (let i = 0, _n = this._profSkillRowCount(); i < _n; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      const baseInput = document.getElementById(`prof-skill-${i}-base`);
      const currentInput = document.getElementById(`prof-skill-${i}-current`);
      
      if (!nameInput || !nameInput.value.trim()) continue;
      
      const skillName = nameInput.value.toLowerCase().replace(/\s*\(.*\)/, '').trim();
      const config = this.MAGIC_SKILL_CONFIG[skillName];
      
      // If this is a magic skill, check if its class is still present
      if (config) {
        const hasRequiredClass = config.classes.some(cls => currentClasses.includes(cls));
        
        if (!hasRequiredClass) {
          // Class removed - clear this skill from professional skills
          nameInput.value = '';
          nameInput.dataset.previousName = '';
          if (baseInput) baseInput.value = '';
          if (currentInput) currentInput.value = '';
          
          // Also clear from magic page
          const magicInput = document.getElementById(config.magicId);
          if (magicInput) {
            magicInput.value = '';
            magicInput.dispatchEvent(new Event('input', { bubbles: true }));
          }
          
          // Update data
          this.updateProfessionalSkillData(i);
        }
      }
    }
  },
  
  /**
   * Auto-add magic skills to Professional Skills based on class
   * Called when class changes or during initialization
   */
  autoAddMagicSkillsToProfessional() {
    const currentClasses = this.getCurrentClasses();
    if (currentClasses.length === 0) return;
    
    // Determine which magic skills should be present
    const requiredSkills = [];
    for (const [skillName, config] of Object.entries(this.MAGIC_SKILL_CONFIG)) {
      if (config.classes.some(cls => currentClasses.includes(cls))) {
        requiredSkills.push({
          name: skillName,
          titleName: this.toTitleCase(skillName),
          config: config
        });
      }
    }
    
    if (requiredSkills.length === 0) return;
    
    // Check which skills are already in professional skills
    const existingSkills = new Map(); // normalizedName -> { index, nameInput, currentInput }
    const container = document.getElementById('professional-skills-container');
    if (!container) return;
    const rows = container.querySelectorAll('.professional-skill-row');
    
    for (let i = 0; i < rows.length; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      if (nameInput && nameInput.value.trim()) {
        const normalized = nameInput.value.toLowerCase().replace(/\s*\(.*\)/, '').trim();
        existingSkills.set(normalized, {
          index: i,
          nameInput: nameInput,
          currentInput: document.getElementById(`prof-skill-${i}-current`)
        });
      }
    }
    
    // Add missing skills or sync existing ones
    for (const skill of requiredSkills) {
      const existing = existingSkills.get(skill.name);
      
      if (!existing) {
        // Skill not found — add it
        const magicInput = document.getElementById(skill.config.magicId);
        const magicValue = magicInput?.value || '';
        this._addMagicSkillToProfessional(skill.name, skill.config, magicValue);
      } else {
        // Skill exists — sync values from magic page
        const magicInput = document.getElementById(skill.config.magicId);
        if (existing.currentInput && magicInput && magicInput.value) {
          if (existing.currentInput.value !== magicInput.value) {
            existing.currentInput.value = magicInput.value;
          }
        }
      }
    }
  },
  
  /**
   * Get SVG for a prereq key icon
   */
  getPrereqKeySvg(color, tooltip = '') {
    const colors = {
      gold: { gradient: ['#F5D98A', '#D4A84B', '#B8860B'], stroke: '#8B6914' },
      silver: { gradient: ['#E8E8E8', '#B8B8B8', '#888888'], stroke: '#666666' },
      blue: { gradient: ['#6A9FD4', '#3A6EA5', '#1E4D78'], stroke: '#1A3A5C' }
    };
    
    const c = colors[color] || colors.gold;
    const uniqueId = `key-${color}-${Math.random().toString(36).substr(2, 9)}`;
    // Store tooltip data in data attributes for click popup instead of hover
    const dataAttrs = tooltip ? `data-key-info="${tooltip.replace(/"/g, '&quot;')}" data-key-color="${color}"` : '';
    
    return `<svg class="prereq-key" viewBox="0 0 32 32" ${dataAttrs}>
      <defs>
        <linearGradient id="${uniqueId}" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" style="stop-color:${c.gradient[0]}"/>
          <stop offset="50%" style="stop-color:${c.gradient[1]}"/>
          <stop offset="100%" style="stop-color:${c.gradient[2]}"/>
        </linearGradient>
      </defs>
      <path d="M20 4a8 8 0 00-7.2 11.5L4 24.3V28h3.7l8.8-8.8A8 8 0 1020 4zm0 12a4 4 0 110-8 4 4 0 010 8z" fill="url(#${uniqueId})" stroke="${c.stroke}" stroke-width="1"/>
      <rect x="17" y="6" width="6" height="6" rx="1" transform="rotate(45 20 9)" fill="none" stroke="${c.stroke}" stroke-width="1.5"/>
    </svg>`;
  },
  
  /**
   * Update multiclass field states on load (without showing warnings)
   */
  updateMulticlassFieldStates() {
    if (!window.ClassRankData) return;
    
    const primary = document.getElementById('class-primary')?.value?.trim() || '';
    
    if (primary) {
      const canMulti = window.ClassRankData.canClassMulticlass(primary);
      this.setMulticlassFieldsEnabled(canMulti);
    } else {
      this.setMulticlassFieldsEnabled(true);
    }
  },
  
  /**
   * Show a warning popup for multiclass restriction violations
   */
  showMulticlassWarning(message) {
    // Remove any existing warning
    const existingWarning = document.getElementById('multiclass-warning');
    if (existingWarning) existingWarning.remove();
    
    // Create warning popup
    const warning = document.createElement('div');
    warning.id = 'multiclass-warning';
    warning.className = 'multiclass-warning';
    warning.innerHTML = `
      <div class="multiclass-warning-icon">⚠️</div>
      <div class="multiclass-warning-title">Illegal Multiclass</div>
      <div class="multiclass-warning-message">${message}</div>
      <button class="multiclass-warning-close">OK</button>
    `;
    
    document.body.appendChild(warning);
    
    // Close handler
    const closeBtn = warning.querySelector('.multiclass-warning-close');
    closeBtn.addEventListener('click', () => {
      warning.remove();
    });
    
    // Auto-close after 5 seconds
    setTimeout(() => {
      if (warning.parentNode) {
        warning.remove();
      }
    }, 5000);
  },

  /**
   * Prompt user to enter a rank for a newly entered class
   */
  promptForRank(className, rankFieldId) {
    console.log(`%c[RANK PROMPT] Showing rank prompt for "${className}" (field: ${rankFieldId})`, 'color: #b8860b; font-weight: bold');
    // Remove any existing prompt
    const existingPrompt = document.getElementById('rank-prompt');
    if (existingPrompt) existingPrompt.remove();
    
    // Create prompt popup
    const prompt = document.createElement('div');
    prompt.id = 'rank-prompt';
    prompt.className = 'rank-prompt-overlay';
    prompt.innerHTML = `
      <div class="rank-prompt-dialog">
        <div class="rank-prompt-title">Enter Rank</div>
        <div class="rank-prompt-message">What Rank do you have for ${className}?</div>
        <input type="number" id="rank-prompt-input" class="rank-prompt-input" min="0" max="5" value="0" autofocus>
        <div class="rank-prompt-buttons">
          <button class="rank-prompt-cancel">Cancel</button>
          <button class="rank-prompt-ok">OK</button>
        </div>
      </div>
    `;
    
    document.body.appendChild(prompt);
    
    const input = prompt.querySelector('#rank-prompt-input');
    const okBtn = prompt.querySelector('.rank-prompt-ok');
    const cancelBtn = prompt.querySelector('.rank-prompt-cancel');
    
    // Focus the input
    setTimeout(() => input.focus(), 50);
    
    // OK handler
    const handleOk = () => {
      let val = parseInt(input.value, 10);
      if (isNaN(val)) val = 0;
      val = Math.max(0, Math.min(5, val));
      
      const rankField = document.getElementById(rankFieldId);
      if (rankField) {
        rankField.value = val;
        const rankKey = this.camelCase(rankFieldId);
        this.character.info[rankKey] = val;
        this.updateRankName();
        this.updatePrereqKeys();
        this.updateSpellMemorization();
        this.updateClassSpells();
        this.updateClassAbilities();
        this.scheduleAutoSave();
      }
      prompt.remove();
    };
    
    okBtn.addEventListener('click', handleOk);
    
    // Cancel handler
    cancelBtn.addEventListener('click', () => {
      prompt.remove();
    });
    
    // Enter key handler
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        handleOk();
      } else if (e.key === 'Escape') {
        prompt.remove();
      }
    });
    
    // Select all text when focused so user can just type
    input.addEventListener('focus', () => {
      input.select();
    });
  },

  /**
   * Update rank name based on class and rank
   * For single class: uses standard rank titles
   * For multiclass: offers evocative name choices
   */
  updateRankName() {
    if (!window.ClassRankData) return;
    
    const primaryClass = document.getElementById('class-primary')?.value?.trim() || '';
    const secondaryClass = document.getElementById('class-secondary')?.value?.trim() || '';
    const rankPrimary = document.getElementById('rank-primary')?.value || '';
    const rankNameField = document.getElementById('rank-name');
    
    if (!rankNameField) return;
    
    // If no classes, clear rank name (if it's a standard title or evocative name)
    if (!primaryClass) {
      const currentValue = rankNameField.value.trim();
      if (this.isStandardRankTitle(currentValue) || this.isEvocativeName(currentValue)) {
        rankNameField.value = '';
        this.character.info.rankName = '';
      }
      return;
    }
    
    // Check if we have a multiclass combo with evocative names
    if (primaryClass && secondaryClass) {
      const evocativeOptions = window.ClassRankData.getEvocativeNames(primaryClass, secondaryClass);
      
      if (evocativeOptions && evocativeOptions.length > 0) {
        // Check if current value is already one of the evocative options
        const currentValue = rankNameField.value.trim();
        if (!evocativeOptions.includes(currentValue)) {
          // Show dropdown to select evocative name
          this.showEvocativeNameSelector(evocativeOptions, rankNameField);
        }
        return;
      }
    }
    
    // Single class: use standard rank title
    if (primaryClass && rankPrimary !== '') {
      const rankIndex = parseInt(rankPrimary, 10);
      const title = window.ClassRankData.getRankTitle(primaryClass, rankIndex);
      
      // Only auto-fill if empty or matches a standard title
      const currentValue = rankNameField.value.trim();
      const isStandardTitle = this.isStandardRankTitle(currentValue);
      
      if (!currentValue || isStandardTitle) {
        rankNameField.value = title;
      }
    }
  },
  
  /**
   * Check if a value is a standard rank title (not a custom name)
   */
  isStandardRankTitle(value) {
    if (!value || !window.ClassRankData) return false;
    
    for (const titles of Object.values(window.ClassRankData.CLASS_RANK_TITLES)) {
      if (titles.includes(value)) return true;
    }
    return false;
  },
  
  /**
   * Check if a value is an evocative name from multiclass combos
   */
  isEvocativeName(value) {
    if (!value || !window.ClassRankData) return false;
    
    for (const names of Object.values(window.ClassRankData.EVOCATIVE_NAMES)) {
      if (names.includes(value)) return true;
    }
    return false;
  },
  
  /**
   * Show evocative name selector dropdown
   */
  showEvocativeNameSelector(options, targetField) {
    // Remove any existing selector
    const existingSelector = document.getElementById('evocative-name-selector');
    if (existingSelector) existingSelector.remove();
    
    // Create dropdown
    const selector = document.createElement('div');
    selector.id = 'evocative-name-selector';
    selector.className = 'evocative-selector';
    selector.innerHTML = `
      <div class="evocative-header">Choose an Evocative Name:</div>
      <div class="evocative-options">
        ${options.map(opt => `<div class="evocative-option" data-value="${opt}">${opt}</div>`).join('')}
      </div>
      <div class="evocative-cancel">Cancel</div>
    `;
    
    // Position near the rank name field
    const rect = targetField.getBoundingClientRect();
    selector.style.position = 'fixed';
    selector.style.top = `${rect.bottom + 5}px`;
    selector.style.left = `${rect.left}px`;
    selector.style.zIndex = '10000';
    
    document.body.appendChild(selector);
    
    // Add click handlers
    selector.querySelectorAll('.evocative-option').forEach(opt => {
      opt.addEventListener('click', () => {
        targetField.value = opt.dataset.value;
        this.character.info.rankName = opt.dataset.value;
        this.scheduleAutoSave();
        selector.remove();
      });
    });
    
    selector.querySelector('.evocative-cancel').addEventListener('click', () => {
      selector.remove();
    });
    
    // Close on click outside
    setTimeout(() => {
      document.addEventListener('click', function closeSelector(e) {
        if (!selector.contains(e.target) && e.target !== targetField) {
          selector.remove();
          document.removeEventListener('click', closeSelector);
        }
      });
    }, 100);
  },

  /**
   * Update movement display
   */
  updateMovementDisplay() {
    // Use current movement value, fall back to original if current is empty
    const movementCurrent = document.getElementById('movement-current');
    const movementOriginal = document.getElementById('movement-original');
    const baseMovement = parseInt(movementCurrent?.value) || parseInt(movementOriginal?.value) || parseInt(this.character.derived.movementCurrent) || parseInt(this.character.derived.movementBase) || 0;
    const speeds = Calculator.calculateMovement(baseMovement);
    
    const walkEl = document.getElementById('walk-speed');
    const runEl = document.getElementById('run-speed');
    const sprintEl = document.getElementById('sprint-speed');
    const swimEl = document.getElementById('swim-speed');
    const climbEl = document.getElementById('climb-speed');
    
    // Remove any penalty styling
    [walkEl, runEl, sprintEl, swimEl, climbEl].forEach(el => {
      if (el) {
        el.classList.remove('enc-penalty-init-move', 'burdened', 'overburdened');
      }
    });
    
    if (walkEl) walkEl.textContent = `${speeds.walk}'`;
    if (runEl) runEl.textContent = `${speeds.run}'`;
    if (sprintEl) sprintEl.textContent = `${speeds.sprint}'`;
    if (swimEl) swimEl.textContent = `${speeds.swim}'`;
    if (climbEl) climbEl.textContent = `${speeds.climb}'`;
  },

  /**
   * Update jump display
   */
  updateJumpDisplay() {
    const height = this.character.info.height || '';
    const jumps = Calculator.calculateJumps(height);
    
    document.getElementById('vertical-jump').textContent = jumps.vertical || "0' 0\"";
    document.getElementById('horizontal-jump').textContent = jumps.horizontal || "0' 0\"";
  },

  /**
   * Update total encumbrance
   */
  updateTotalEnc() {
    let total = 0;
    
    // Only auto-calculate total if automation is enabled
    if (this.character.encAutomation) {
      // Equipment ENC
      for (let i = 0; i < EQUIPMENT_SLOTS; i++) {
        const encInput = document.getElementById(`equip-${i}-enc`);
        if (encInput && encInput.value) {
          total += parseFloat(encInput.value) || 0;
        }
      }
      
      // Money ENC (every 100 coins = 1 Thing)
      const moneyEnc = this.updateMoneyEnc();
      total += moneyEnc;
      
      const totalDisplay = document.getElementById('total-enc');
      if (totalDisplay) {
        totalDisplay.textContent = total.toFixed(1);
      }
    } else {
      // Automation is off - read the manually entered total
      const totalDisplay = document.getElementById('total-enc');
      total = parseFloat(totalDisplay?.textContent) || 0;
    }
    
    // Always calculate and display ENC status (needed for abilities like Artful Dodger)
    const STR = parseInt(this.character.attributes.STR) || 0;
    const status = Calculator.getEncStatus(total, STR);
    
    const statusDisplay = document.getElementById('enc-status');
    if (statusDisplay) {
      statusDisplay.textContent = status.name;
      
      // Add visual styling based on burden level
      statusDisplay.classList.remove('enc-extremely-unburdened', 'enc-unburdened', 'enc-burdened', 'enc-overburdened');
      if (status.name === 'Extremely Unburdened') {
        statusDisplay.classList.add('enc-extremely-unburdened');
      } else if (status.name === 'Unburdened') {
        statusDisplay.classList.add('enc-unburdened');
      } else if (status.name === 'Burdened') {
        statusDisplay.classList.add('enc-burdened');
      } else if (status.name === 'Overburdened') {
        statusDisplay.classList.add('enc-overburdened');
      }
    }
    
    // Update ENC penalty display
    this.updateEncPenaltyDisplay(status);
    
    // Check ability bonuses (skip during initialization to avoid conflicts)
    if (!this.isInitializing) {
      // Check Artful Dodger display (depends on encumbrance status)
      this.updateArtfulDodgerDisplay();
      
      // Check Lightning Reflexes display (depends on Extremely Unburdened + no armor)
      this.updateLightningReflexesDisplay();
      
      // Check Agile display (depends on encumbrance status)
      this.updateAgileDisplay();
      
      // Check Very Agile display (depends on Extremely Unburdened + no armor)
      this.updateVeryAgileDisplay();
      
      // Check Monk abilities display (depends on encumbrance status)
      this.checkMonkAbilitiesVisibility();
    }
  },
  
  /**
   * Update ENC penalty display and affected skills visual feedback
   */
  updateEncPenaltyDisplay(status) {
    const isBurdened = status.name === 'Burdened';
    const isOverburdened = status.name === 'Overburdened';
    const hasPenalty = isBurdened || isOverburdened;
    
    // Update the ENC penalty note text
    const penaltyNote = document.querySelector('.enc-penalty-note span:last-child');
    if (penaltyNote) {
      if (hasPenalty) {
        penaltyNote.textContent = `= ENC Penalty: ${status.penaltyText}`;
        penaltyNote.classList.add('enc-penalty-active');
      } else {
        penaltyNote.textContent = '= ENC Penalty';
        penaltyNote.classList.remove('enc-penalty-active');
      }
    }
    
    // Update tooltip on all enc-indicators
    const indicators = document.querySelectorAll('.enc-indicator');
    indicators.forEach(indicator => {
      indicator.classList.remove('enc-penalty-active', 'enc-burdened');
      if (hasPenalty) {
        indicator.title = `Affected by ENC: ${status.penaltyText}`;
        if (isBurdened) {
          indicator.classList.add('enc-burdened');
        } else {
          indicator.classList.add('enc-penalty-active');
        }
      } else {
        indicator.title = 'Affected by ENC';
      }
    });
    
    // Apply all penalties (ENC + Fatigue combined)
    this.applyAllPenalties();
  },
  
  /**
   * Update Initiative and Movement current values based on ENC status
   */
  updateEncInitiativeAndMovement(status) {
    const isBurdened = status.name === 'Burdened';
    const isOverburdened = status.name === 'Overburdened';
    const hasPenalty = isBurdened || isOverburdened;
    const penaltyClass = isBurdened ? 'burdened' : 'overburdened';
    
    // Initiative Current
    const initCurrent = document.getElementById('initiative-current');
    if (initCurrent) {
      // Store original if not already stored
      if (initCurrent.dataset.originalValue === undefined && initCurrent.value) {
        initCurrent.dataset.originalValue = initCurrent.value;
      }
      
      const originalInit = parseInt(initCurrent.dataset.originalValue) || parseInt(initCurrent.value) || 0;
      
      initCurrent.classList.remove('enc-penalty-init-move', 'burdened', 'overburdened');
      
      if (hasPenalty && status.initiativePenalty > 0) {
        const penalizedInit = originalInit - status.initiativePenalty;
        initCurrent.value = penalizedInit;
        initCurrent.classList.add('enc-penalty-init-move', penaltyClass);
        initCurrent.title = `Original: ${originalInit}, ENC Penalty: -${status.initiativePenalty}`;
      } else if (initCurrent.dataset.originalValue !== undefined) {
        initCurrent.value = initCurrent.dataset.originalValue;
        initCurrent.title = '';
      }
      
      // Update combat quick ref
      this.updateCombatQuickRef();
    }
    
    // Movement Current
    const moveCurrent = document.getElementById('movement-current');
    if (moveCurrent) {
      // Store original if not already stored
      if (moveCurrent.dataset.originalValue === undefined && moveCurrent.value) {
        moveCurrent.dataset.originalValue = moveCurrent.value;
      }
      
      const originalMove = parseInt(moveCurrent.dataset.originalValue) || parseInt(moveCurrent.value) || 0;
      
      moveCurrent.classList.remove('enc-penalty-init-move', 'burdened', 'overburdened');
      
      if (hasPenalty && status.movementPenalty > 0) {
        const penalizedMove = Math.max(0, originalMove - status.movementPenalty);
        moveCurrent.value = penalizedMove;
        moveCurrent.classList.add('enc-penalty-init-move', penaltyClass);
        moveCurrent.title = `Original: ${originalMove}', ENC Penalty: -${status.movementPenalty}'`;
        
        // Update movement display with penalized value
        this.updateMovementDisplayWithPenalty(penalizedMove, penaltyClass);
      } else if (moveCurrent.dataset.originalValue !== undefined) {
        moveCurrent.value = moveCurrent.dataset.originalValue;
        moveCurrent.title = '';
        
        // Restore normal movement display
        this.updateMovementDisplay();
      }
    }
  },
  
  /**
   * Update movement speed display with ENC penalty styling
   */
  updateMovementDisplayWithPenalty(baseMove, penaltyClass) {
    const speeds = Calculator.calculateMovement(baseMove);
    
    const walkEl = document.getElementById('walk-speed');
    const runEl = document.getElementById('run-speed');
    const sprintEl = document.getElementById('sprint-speed');
    const swimEl = document.getElementById('swim-speed');
    const climbEl = document.getElementById('climb-speed');
    
    [walkEl, runEl, sprintEl, swimEl, climbEl].forEach(el => {
      if (el) {
        el.classList.remove('enc-penalty-init-move', 'burdened', 'overburdened');
        el.classList.add('enc-penalty-init-move', penaltyClass);
      }
    });
    
    if (walkEl) walkEl.textContent = `${speeds.walk}'`;
    if (runEl) runEl.textContent = `${speeds.run}'`;
    if (sprintEl) sprintEl.textContent = `${speeds.sprint}'`;
    if (swimEl) swimEl.textContent = `${speeds.swim}'`;
    if (climbEl) climbEl.textContent = `${speeds.climb}'`;
  },
  
  /**
   * Update skill percentage displays for ENC-affected skills
   */
  updateEncAffectedSkillValues(status) {
    const penaltyPercent = status.penaltyPercent || 0;
    const isBurdened = status.name === 'Burdened';
    const isOverburdened = status.name === 'Overburdened';
    const hasPenalty = isBurdened || isOverburdened;
    
    // Find all Standard Skills with enc-indicator (those have STR/DEX in formula)
    document.querySelectorAll('.skill-row').forEach(row => {
      const indicator = row.querySelector('.enc-indicator');
      if (!indicator) return; // Skip skills without indicator
      
      const input = row.querySelector('.skill-input');
      if (!input) return;
      
      // Store original value if not already stored
      if (input.dataset.originalValue === undefined && input.value) {
        input.dataset.originalValue = input.value;
      }
      
      const originalValue = parseInt(input.dataset.originalValue) || parseInt(input.value) || 0;
      
      // Remove previous penalty classes
      input.classList.remove('enc-penalized-value', 'enc-burdened-penalty');
      
      if (hasPenalty && originalValue > 0) {
        // Apply penalty and show penalized value
        const penalizedValue = Math.max(0, originalValue - penaltyPercent);
        input.value = penalizedValue;
        input.classList.add('enc-penalized-value');
        if (isBurdened) {
          input.classList.add('enc-burdened-penalty');
        }
        input.title = `Original: ${originalValue}%, Penalized: ${penalizedValue}%`;
      } else if (input.dataset.originalValue !== undefined) {
        // Restore original value
        input.value = input.dataset.originalValue;
        input.title = '';
      }
    });
    
    // Update Professional Skills with STR/DEX in formula
    for (let i = 0; i < PROFESSIONAL_SKILL_SLOTS; i++) {
      const encIndicator = document.getElementById(`prof-skill-${i}-enc`);
      if (!encIndicator || encIndicator.style.display === 'none') continue;
      
      const input = document.getElementById(`prof-skill-${i}-current`);
      if (!input) continue;
      
      // Store original value if not already stored
      if (input.dataset.originalValue === undefined && input.value) {
        input.dataset.originalValue = input.value;
      }
      
      const originalValue = parseInt(input.dataset.originalValue) || parseInt(input.value) || 0;
      
      // Remove previous penalty classes
      input.classList.remove('enc-penalized-value', 'enc-burdened-penalty');
      
      if (hasPenalty && originalValue > 0) {
        // Apply penalty and show penalized value
        const penalizedValue = Math.max(0, originalValue - penaltyPercent);
        input.value = penalizedValue;
        input.classList.add('enc-penalized-value');
        if (isBurdened) {
          input.classList.add('enc-burdened-penalty');
        }
        input.title = `Original: ${originalValue}%, Penalized: ${penalizedValue}%`;
      } else if (input.dataset.originalValue !== undefined) {
        // Restore original value
        input.value = input.dataset.originalValue;
        input.title = '';
      }
    }
    
    // Update Combat Skill and Unarmed (both are STR+DEX based)
    const combatSkillInputs = document.querySelectorAll('.enc-affected-combat');
    combatSkillInputs.forEach(input => {
      // Store original value if not already stored
      if (input.dataset.originalValue === undefined && input.value) {
        input.dataset.originalValue = input.value;
      }
      
      const originalValue = parseInt(input.dataset.originalValue) || parseInt(input.value) || 0;
      
      // Remove previous penalty classes
      input.classList.remove('enc-penalized-value', 'enc-burdened-penalty');
      
      if (hasPenalty && originalValue > 0) {
        // Apply penalty and show penalized value
        const penalizedValue = Math.max(0, originalValue - penaltyPercent);
        input.value = penalizedValue;
        input.classList.add('enc-penalized-value');
        if (isBurdened) {
          input.classList.add('enc-burdened-penalty');
        }
        input.title = `Original: ${originalValue}%, Penalized: ${penalizedValue}%`;
      } else if (input.dataset.originalValue !== undefined) {
        // Restore original value
        input.value = input.dataset.originalValue;
        input.title = '';
      }
    });
  },

  // ============================================================
  // FATIGUE & UNIFIED PENALTY SYSTEM
  // ============================================================

  /**
   * Setup fatigue radio button listeners
   */
  setupFatigueListeners() {
    const fatigueRadios = document.querySelectorAll('input[name="fatigue-state"]');
    fatigueRadios.forEach(radio => {
      radio.addEventListener('change', (e) => {
        this.setFatigueState(e.target.value, true);
      });
    });
    
    // Allow clicking anywhere on a fatigue row to select it
    const fatigueRows = document.querySelectorAll('.fatigue-table tbody tr');
    fatigueRows.forEach(row => {
      row.addEventListener('click', (e) => {
        // Don't double-trigger if clicking the radio itself
        if (e.target.type === 'radio') return;
        const radio = row.querySelector('input[type="radio"]');
        if (radio) {
          radio.checked = true;
          radio.dispatchEvent(new Event('change', { bubbles: true }));
        }
      });
    });
  },

  /**
   * Apply fatigue levels from overcasting (casting with insufficient MP).
   * Each MP of deficit = 1 fatigue level gained.
   * @param {number} deficit - Number of MP overdrawn beyond 0
   */
  _applyOvercastFatigue(deficit) {
    if (deficit <= 0) return;
    const fatigueOrder = ['fresh', 'winded', 'tired', 'wearied', 'exhausted', 'debilitated', 'incapacitated', 'semiconscious', 'coma'];
    const currentState = this.character.fatigueState || 'fresh';
    const currentIndex = fatigueOrder.indexOf(currentState);
    const targetIndex = Math.min(currentIndex + deficit, fatigueOrder.length - 1);
    const targetState = fatigueOrder[targetIndex];

    if (targetIndex > currentIndex) {
      console.log(`%c[OVERCAST FATIGUE] ${deficit} MP overdrawn: ${currentState} → ${targetState}`, 'color: #e8a0a0; font-weight: bold');
      this.setFatigueState(targetState, true);
    }
  },

  /**
   * Set the fatigue state and apply penalties
   * @param {string} state - fatigue state key (e.g., 'fresh', 'wearied')
   * @param {boolean} save - whether to trigger auto-save
   */
  setFatigueState(state, save = true) {
    if (!FATIGUE_PENALTIES[state]) return;
    
    this.character.fatigueState = state;
    
    // Update radio button
    const radio = document.querySelector(`input[name="fatigue-state"][value="${state}"]`);
    if (radio) radio.checked = true;
    
    // Update active row highlight
    document.querySelectorAll('.fatigue-table tbody tr').forEach(row => {
      row.classList.remove('fatigue-active');
    });
    const activeRow = document.querySelector(`tr[data-fatigue="${state}"]`);
    if (activeRow) activeRow.classList.add('fatigue-active');
    
    // Apply all penalties
    this.applyAllPenalties();
    
    // Update summary page - refresh all widgets that display penalized values
    this.updateCombatQuickRef();
    if (typeof this.refreshSummaryWidget === 'function') {
      this.refreshSummaryWidget('fatigue');
      this.refreshSummaryWidget('combat');
      this.refreshSummaryWidget('attributes');
      this.refreshSummaryWidget('movement');
      this.refreshSummaryWidget('key-skills');
      this.refreshSummaryWidget('professional-skills');
      this.refreshSummaryWidget('magic-skills');
    }
    
    if (save) {
      this.scheduleAutoSave();
    }
  },

  /**
   * Short Rest: Open the Short Rest modal to choose an action
   */
  shortRest() {
    this.openShortRestModal();
  },

  /**
   * Long Rest: 8 hours of rest - restore MP and recover fatigue based on recovery times
   */
  longRest() {
    // Show sleep animation first, then do the actual rest logic
    this.showSleepAnimation(() => {
      this.performLongRestLogic();
    });
  },
  
  /**
   * Show sleep animation overlay
   */
  showSleepAnimation(callback) {
    // Create or get the sleep overlay
    let overlay = document.getElementById('long-rest-sleep-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'long-rest-sleep-overlay';
      overlay.className = 'long-rest-sleep-overlay';
      
      // Generate random stars
      let starsHtml = '<div class="sleep-stars">';
      for (let i = 0; i < 30; i++) {
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        const delay = Math.random() * 2;
        const size = 2 + Math.random() * 3;
        starsHtml += `<div class="sleep-star" style="left:${left}%;top:${top}%;animation-delay:${delay}s;width:${size}px;height:${size}px;"></div>`;
      }
      starsHtml += '</div>';
      
      overlay.innerHTML = `
        ${starsHtml}
        <div class="sleep-content">
          <div class="sleep-icon">🌙</div>
          <div class="sleep-text">Resting...</div>
          <div class="sleep-zzz">
            <span>z</span>
            <span>Z</span>
            <span>Z</span>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);
    }
    
    // Show overlay with fade in
    requestAnimationFrame(() => {
      overlay.classList.add('active');
    });
    
    // After animation, fade out and call callback
    setTimeout(() => {
      overlay.classList.remove('active');
      
      // Wait for fade out transition
      setTimeout(() => {
        if (callback) callback();
      }, 800);
    }, 2500);
  },
  
  /**
   * Perform the actual Long Rest logic (called after animation)
   */
  performLongRestLogic() {
    const currentState = this.character.fatigueState || 'fresh';
    const messages = [];
    
    // Recovery time mapping (hours to reach Fresh from each state)
    const recoveryTimes = {
      fresh: 0,
      winded: 0.25,  // 15 min
      tired: 3,
      wearied: 6,
      exhausted: 12,
      debilitated: 18,
      incapacitated: 24,
      semiconscious: 36,
      coma: 48
    };
    
    // Long Rest outcomes (what state you end up in after 8 hours)
    const longRestOutcome = {
      fresh: 'fresh',
      winded: 'fresh',
      tired: 'fresh',
      wearied: 'fresh',
      exhausted: 'wearied',      // 12-8=4 hrs remaining
      debilitated: 'exhausted',   // 18-8=10 hrs remaining
      incapacitated: 'debilitated', // 24-8=16 hrs remaining
      semiconscious: 'semiconscious', // No change - needs Cure Fatigue
      coma: 'coma'                // No change - needs Cure Fatigue
    };
    
    // Restore all Magic Points
    const mpCurrent = document.getElementById('magic-points-current');
    const mpMax = document.getElementById('magic-points-original');
    if (mpCurrent && mpMax) {
      const maxMP = parseInt(mpMax.dataset.originalValue || mpMax.value) || 0;
      const currentMP = parseInt(mpCurrent.value) || 0;
      if (maxMP > 0) {
        mpCurrent.value = maxMP;
        mpCurrent.dispatchEvent(new Event('input', { bubbles: true }));
        if (currentMP < maxMP) {
          messages.push(`<strong>Magic Points restored:</strong> ${currentMP} → ${maxMP}`);
        } else {
          messages.push(`<strong>Magic Points:</strong> Already at maximum (${maxMP})`);
        }
      }
    }
    
    // Reset Berserk Rage uses if character has the ability
    if (this.hasAbility('Berserk Rage')) {
      const maxUses = this.getMaxRageUses();
      const prevUses = this.character.rageUsesRemaining || 0;
      this.character.rageUsesRemaining = maxUses;
      this.character.rageFatigueWaiversUsed = 0;
      this.updateBerserkRageDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>Berserk Rage uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>Berserk Rage:</strong> Already at maximum (${maxUses} uses)`);
      }
    }
    
    // Reset Commanding uses if character has the ability
    if (this.hasAbility('Commanding')) {
      const maxUses = this.getMaxCommandingUses();
      const prevUses = this.character.commandingUsesRemaining || 0;
      this.character.commandingUsesRemaining = maxUses;
      // End active commanding effect if any
      if (this.character.isCommanding) {
        this.endCommanding();
      }
      this.updateCommandingDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>Commanding uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>Commanding:</strong> Already at maximum (${maxUses} uses)`);
      }
    }
    
    // Reset Mental Strength uses if character has the ability
    
    // Reset Holy Strike uses if character has the ability
    if (this.hasAbility('Holy Strike')) {
      const maxUses = this.getMaxHolyStrikeUses();
      const prevUses = this.character.holyStrikeUsesRemaining || 0;
      this.character.holyStrikeUsesRemaining = maxUses;
      this.updateHolyStrikeDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>Holy Strike uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>Holy Strike:</strong> Already at maximum (${maxUses} uses)`);
      }
    }

    // Reset Lay on Hands uses if character has the ability
    if (this.hasAbility('Lay on Hands')) {
      const maxUses = this.getMaxLayOnHandsUses();
      const prevUses = this.character.layOnHandsUsesRemaining || 0;
      this.character.layOnHandsUsesRemaining = maxUses;
      this.updateLayOnHandsDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>Lay on Hands uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>Lay on Hands:</strong> Already at maximum (${maxUses} uses)`);
      }
    }

    // Reset Mental Strength uses if character has the ability

    // Track Cure Disease weekly cooldown
    if (this.hasAbility('Cure Disease') && this.character.cureDiseaseState === 'cooldown') {
      this.character.cureDiseaseRestCount = (this.character.cureDiseaseRestCount || 0) + 1;
      if (this.character.cureDiseaseRestCount >= 7) {
        this.character.cureDiseaseState = 'ready';
        this.character.cureDiseaseRestCount = 0;
        this.character.cureDiseaseUsesRemaining = this.getMaxCureDiseaseUses();
        messages.push(`<strong>Cure Disease:</strong> Weekly cooldown complete — uses restored!`);
      } else {
        messages.push(`<strong>Cure Disease cooldown:</strong> ${this.character.cureDiseaseRestCount}/7 Long Rests`);
      }
      this.updateCureDiseaseDisplay();
    }

    // Deactivate Divine Protection on Long Rest
    if (this.character.divineProtectionActive) {
      this.deactivateDivineProtection();
      messages.push(`<strong>Divine Protection:</strong> Deactivated`);
    }

    // Deactivate Improved Aim on Long Rest
    if (this.character.improvedAimActive) {
      this.deactivateImprovedAim();
      messages.push(`<strong>Improved Aim:</strong> Deactivated`);
    }

    // Deactivate Species Enemy on Long Rest
    if (this.character.speciesEnemyActive) {
      this.deactivateSpeciesEnemy();
      messages.push(`<strong>Species Enemy:</strong> Deactivated`);
    }

    const mentalStrengthLevel = this.getMentalStrengthLevel();
    if (mentalStrengthLevel > 0) {
      const maxUses = mentalStrengthLevel;
      const prevUses = this.character.mentalStrengthUsesRemaining || 0;
      this.character.mentalStrengthUsesRemaining = maxUses;
      // End active mental strength effect if any
      if (this.character.isMentalStrengthActive) {
        this.endMentalStrength();
      }
      this.updateMentalStrengthDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>Mental Strength uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>Mental Strength:</strong> Already at maximum (${maxUses} uses)`);
      }
    }
    
    // Reset Turn Undead uses if character has the ability
    if (this.hasAbility('Turn Undead')) {
      const maxUses = this.getMaxTurnUndeadUses();
      const prevUses = this.character.turnUndeadUsesRemaining || 0;
      this.character.turnUndeadUsesRemaining = maxUses;
      this.updateTurnUndeadDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>Turn Undead uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>Turn Undead:</strong> Already at maximum (${maxUses} uses)`);
      }
    }
    
    // Reset Holy Smite uses if character has the ability
    const holySmiteTier = this.getHolySmiteTier();
    if (holySmiteTier.tier) {
      const maxUses = this.getMaxHolySmiteUses();
      const prevUses = this.character.holySmiteUsesRemaining || 0;
      this.character.holySmiteUsesRemaining = maxUses;
      // End active holy smite effect if any
      if (this.character.isHolySmiteActive) {
        this.endHolySmite();
      }
      this.updateHolySmiteDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>${holySmiteTier.tier} uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>${holySmiteTier.tier}:</strong> Already at maximum (${maxUses} uses)`);
      }
    }
    
    // Reset Shape Change uses if character has the ability
    if (this.getShapeChangeTier()) {
      const maxUses = this.getMaxShapeChangeUses();
      const prevUses = this.character.shapeChangeUsesRemaining || 0;
      this.character.shapeChangeUsesRemaining = maxUses;
      this.updateShapeChangeDisplay();
      if (prevUses < maxUses) {
        messages.push(`<strong>Shape Change uses restored:</strong> ${prevUses} → ${maxUses}`);
      } else {
        messages.push(`<strong>Shape Change:</strong> Already at maximum (${maxUses} uses)`);
      }
    }
    
    // Reset Just a Scratch uses if character has the ability
    if (this.hasAbility('Just a Scratch')) {
      const prevUses = this.character.scratchUsesRemaining || 0;
      this.character.scratchUsesRemaining = 1;
      this.updateJustAScratchDisplay();
      if (prevUses < 1) {
        messages.push(`<strong>Just a Scratch uses restored:</strong> ${prevUses} → 1`);
      } else {
        messages.push(`<strong>Just a Scratch:</strong> Already at maximum (1 use)`);
      }
    }
    
    // Calculate fatigue recovery
    const newState = longRestOutcome[currentState] || currentState;
    
    if (currentState === 'semiconscious' || currentState === 'coma') {
      messages.push(`<br><strong>Fatigue:</strong> ${this.formatFatigueState(currentState)}`);
      messages.push(`<span style="color:#cc0000;">⚠ No recovery possible from ${this.formatFatigueState(currentState)} with rest alone.</span>`);
      messages.push(`<em>A Cure Fatigue spell is required to recover from this state.</em>`);
    } else if (newState !== currentState) {
      const hoursNeeded = recoveryTimes[currentState];
      const hoursRemaining = Math.max(0, hoursNeeded - 8);
      this.setFatigueState(newState, true);
      messages.push(`<br><strong>Fatigue recovery:</strong> ${this.formatFatigueState(currentState)} → ${this.formatFatigueState(newState)}`);
      if (hoursRemaining > 0) {
        messages.push(`<em>(${hoursRemaining} hours of recovery time remaining)</em>`);
      }
    } else {
      messages.push(`<br><strong>Fatigue:</strong> Already ${this.formatFatigueState(currentState)}`);
    }
    
    // Deactivate Forceful Strike if active
    if (this.character.isForcefulStrikeActive) {
      this.deactivateForcefulStrike();
      messages.push(`<br><strong>Forceful Strike:</strong> Deactivated`);
    }
    
    // Show the Long Rest result modal
    this.showLongRestResult(messages.join('<br>'));
  },

  /**
   * Show Long Rest result in a simple modal/alert
   */
  showLongRestResult(message) {
    // Create or get the long rest result modal
    let overlay = document.getElementById('long-rest-modal-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'long-rest-modal-overlay';
      overlay.className = 'long-rest-modal-overlay';
      overlay.innerHTML = `
        <div class="long-rest-modal">
          <div class="long-rest-modal-header">
            <h3>⛺ Long Rest (8 hours)</h3>
            <button class="long-rest-modal-close">&times;</button>
          </div>
          <div class="long-rest-modal-body" id="long-rest-modal-body">
          </div>
          <div class="long-rest-modal-footer">
            <button class="btn btn-primary" id="btn-close-long-rest">Done</button>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);
      
      // Add event listeners
      overlay.querySelector('.long-rest-modal-close').addEventListener('click', () => {
        this.closeLongRestModal();
      });
      overlay.querySelector('#btn-close-long-rest').addEventListener('click', () => {
        this.closeLongRestModal();
      });
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          this.closeLongRestModal();
        }
      });
    }
    
    // Set content and show
    document.getElementById('long-rest-modal-body').innerHTML = message;
    overlay.classList.add('active');
    
    // Refresh summary widgets
    this.refreshSummaryWidget('fatigue');
    this.refreshSummaryWidget('attributes');
  },

  /**
   * Close the Long Rest modal
   */
  closeLongRestModal() {
    const overlay = document.getElementById('long-rest-modal-overlay');
    if (overlay) {
      overlay.classList.remove('active');
    }
  },

  /**
   * Open the Short Rest modal
   */
  openShortRestModal() {
    const overlay = document.getElementById('short-rest-modal-overlay');
    if (overlay) {
      overlay.classList.add('active');
      // Clear any previous selection and result
      const radios = overlay.querySelectorAll('input[name="short-rest-action"]');
      radios.forEach(r => r.checked = false);
      const result = document.getElementById('short-rest-result');
      if (result) {
        result.classList.remove('active', 'success', 'info', 'warning');
        result.innerHTML = '';
      }
      
      // Show/hide spellcasting options based on character class
      const hasSpells = this.hasSpellcastingAbility();
      const spellOptions = ['pray-study', 'cast-spells', 'prepare-spell'];
      spellOptions.forEach(value => {
        const radio = overlay.querySelector(`input[name="short-rest-action"][value="${value}"]`);
        if (radio) {
          const optionLabel = radio.closest('.short-rest-option');
          if (optionLabel) {
            optionLabel.style.display = hasSpells ? '' : 'none';
          }
        }
      });
      
      // Show/hide Second Wind option based on ability
      const hasSecondWind = this.hasAbility('Second Wind');
      const secondWindOption = document.getElementById('second-wind-option');
      const secondWindDivider = document.getElementById('second-wind-divider');
      if (secondWindOption) secondWindOption.style.display = hasSecondWind ? '' : 'none';
      if (secondWindDivider) secondWindDivider.style.display = hasSecondWind ? '' : 'none';
    }
  },

  /**
   * Close the Short Rest modal
   */
  closeShortRestModal() {
    const overlay = document.getElementById('short-rest-modal-overlay');
    if (overlay) {
      overlay.classList.remove('active');
    }
  },

  /**
   * Short Rest animation data by action type
   */
  SHORT_REST_ANIMATIONS: {
    'eat-ration': {
      theme: 'eat-theme',
      icons: ['🍖', '🍺', '🔥', '🥘', '🍲'],
      texts: ['Enjoying a meal...', 'Refueling...', "A moment's respite...", 'Warming by the fire...', 'Taking nourishment...'],
      particles: 'campfire'
    },
    'pray-study': {
      theme: 'study-theme',
      icons: ['📖', '✨', '🙏', '📜', '🔮'],
      texts: ['Communing with the divine...', 'Studying the arcane...', 'Focusing your mind...', 'Meditating on the mysteries...', 'Channeling inner power...'],
      particles: 'runes'
    },
    'tend-wounds': {
      theme: 'heal-theme',
      icons: ['🩹', '🌿', '💊', '🧴', '🪻'],
      texts: ['Dressing wounds...', 'Applying salve...', 'Patching up...', 'Tending injuries...', 'Binding wounds...'],
      particles: 'healing'
    },
    'cast-spells': {
      theme: 'magic-theme',
      icons: ['✨', '💫', '🌟', '⚡', '🌀'],
      texts: ['Channeling healing energy...', 'Weaving restorative magic...', 'Casting beneficial spells...', 'Invoking magical aid...'],
      particles: 'sparkles'
    },
    'prepare-spell': {
      theme: 'study-theme',
      icons: ['📖', '✨', '📜', '🔮', '🌙'],
      texts: ['Preparing your mind...', 'Memorizing incantations...', 'Attuning to the arcane...', 'Organizing spell components...'],
      particles: 'runes'
    },
    'dither': {
      theme: 'dither-theme',
      icons: ['😴', '🌤️', '🍃', '☁️', '💭'],
      texts: ['Just... sitting here...', 'Relaxing...', 'Taking it easy...', 'Doing absolutely nothing...', 'Wasting time pleasantly...'],
      particles: 'clouds'
    },
    'second-wind': {
      theme: 'heal-theme',
      icons: ['💨', '🌬️', '😤', '💪', '🔄'],
      texts: ['Catching your breath...', 'Finding renewed vigor...', 'Pushing through...', 'Summoning inner strength...'],
      particles: 'healing'
    }
  },

  /**
   * Show Short Rest animation overlay
   */
  showShortRestAnimation(actionType, callback) {
    const animData = this.SHORT_REST_ANIMATIONS[actionType];
    if (!animData) {
      if (callback) callback();
      return;
    }
    
    // Random selection
    const icon = animData.icons[Math.floor(Math.random() * animData.icons.length)];
    const text = animData.texts[Math.floor(Math.random() * animData.texts.length)];
    
    // Create or get the overlay
    let overlay = document.getElementById('short-rest-anim-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'short-rest-anim-overlay';
      document.body.appendChild(overlay);
    }
    
    // Generate particles based on type
    let particlesHtml = '';
    switch (animData.particles) {
      case 'campfire':
        particlesHtml = '<div class="campfire-particles">';
        for (let i = 0; i < 15; i++) {
          const left = 40 + Math.random() * 20;
          const delay = Math.random() * 2;
          particlesHtml += `<div class="ember" style="left:${left}%;bottom:30%;animation-delay:${delay}s;"></div>`;
        }
        particlesHtml += '</div>';
        break;
      case 'runes':
        const runeSymbols = ['ᚠ', 'ᚢ', 'ᚦ', 'ᚨ', 'ᚱ', 'ᚲ', 'ᚷ', 'ᚹ', 'ᚺ', 'ᚾ', 'ᛁ', 'ᛃ', 'ᛇ', 'ᛈ', 'ᛉ', 'ᛊ'];
        particlesHtml = '<div class="magic-runes">';
        for (let i = 0; i < 12; i++) {
          const left = Math.random() * 100;
          const top = Math.random() * 100;
          const delay = Math.random() * 3;
          const rune = runeSymbols[Math.floor(Math.random() * runeSymbols.length)];
          particlesHtml += `<div class="rune" style="left:${left}%;top:${top}%;animation-delay:${delay}s;">${rune}</div>`;
        }
        particlesHtml += '</div>';
        break;
      case 'healing':
        particlesHtml = '<div class="healing-particles">';
        for (let i = 0; i < 10; i++) {
          const left = 30 + Math.random() * 40;
          const delay = Math.random() * 2.5;
          particlesHtml += `<div class="heal-cross" style="left:${left}%;bottom:35%;animation-delay:${delay}s;">✚</div>`;
        }
        particlesHtml += '</div>';
        break;
      case 'sparkles':
        particlesHtml = '<div class="sparkle-particles">';
        for (let i = 0; i < 20; i++) {
          const left = Math.random() * 100;
          const top = Math.random() * 100;
          const delay = Math.random() * 1.5;
          particlesHtml += `<div class="sparkle" style="left:${left}%;top:${top}%;animation-delay:${delay}s;"></div>`;
        }
        particlesHtml += '</div>';
        break;
      case 'clouds':
        particlesHtml = '<div class="cloud-particles">';
        for (let i = 0; i < 5; i++) {
          const top = 20 + Math.random() * 60;
          const delay = i * 1.5;
          particlesHtml += `<div class="cloud" style="top:${top}%;animation-delay:${delay}s;">☁</div>`;
        }
        particlesHtml += '</div>';
        break;
    }
    
    overlay.className = `short-rest-anim-overlay ${animData.theme}`;
    overlay.innerHTML = `
      ${particlesHtml}
      <div class="short-rest-anim-content">
        <div class="short-rest-anim-icon">${icon}</div>
        <div class="short-rest-anim-text">${text}</div>
      </div>
    `;
    
    // Show overlay with fade in
    requestAnimationFrame(() => {
      overlay.classList.add('active');
    });
    
    // After animation, fade out and call callback
    setTimeout(() => {
      overlay.classList.remove('active');
      
      // Wait for fade out transition
      setTimeout(() => {
        if (callback) callback();
      }, 600);
    }, 2000);
  },

  /**
   * Apply the selected Short Rest action
   */
  applyShortRestAction() {
    const selected = document.querySelector('input[name="short-rest-action"]:checked');
    if (!selected) {
      this.showShortRestResult('warning', 'Please select a Rest Action.');
      return;
    }

    const action = selected.value;
    
    // Close the modal first
    this.closeShortRestModal();
    
    // Show animation, then perform the action
    this.showShortRestAnimation(action, () => {
      this.performShortRestAction(action);
    });
  },
  
  /**
   * Perform the actual Short Rest action (called after animation)
   */
  performShortRestAction(action) {
    const stateOrder = ['fresh', 'winded', 'tired', 'wearied', 'exhausted', 'debilitated', 'incapacitated', 'semiconscious', 'coma'];
    const currentState = this.character.fatigueState || 'fresh';
    const currentIndex = stateOrder.indexOf(currentState);
    
    // Deactivate Forceful Strike if active (any rest action turns it off)
    if (this.character.isForcefulStrikeActive) {
      this.deactivateForcefulStrike();
    }
    
    // Index boundaries for fatigue levels
    const WINDED_INDEX = 1;
    const EXHAUSTED_INDEX = 4;
    
    let resultTitle = '';
    let resultMessage = '';
    let resultType = 'success';

    switch (action) {
      case 'eat-ration': {
        let messages = [];
        let newIndex = currentIndex;
        
        if (currentIndex <= EXHAUSTED_INDEX && currentIndex > 0) {
          newIndex = currentIndex - 1;
          messages.push(`Fatigue reduced from ${this.formatFatigueState(currentState)} to ${this.formatFatigueState(stateOrder[newIndex])}.`);
          
          if (newIndex <= WINDED_INDEX && newIndex > 0) {
            newIndex = newIndex - 1;
            messages.push(`Bonus recovery (non-strenuous): now ${this.formatFatigueState(stateOrder[newIndex])}.`);
          }
          
          this.setFatigueState(stateOrder[newIndex], true);
        } else if (currentIndex > EXHAUSTED_INDEX) {
          messages.push(`Cannot eat a ration while ${this.formatFatigueState(currentState)} (must be Exhausted or better).`);
        } else {
          messages.push('Already at Fresh - no fatigue to remove.');
        }
        
        messages.push('Hunger quelled.');
        resultTitle = '🍖 Meal Complete';
        resultMessage = messages.join('<br>');
        break;
      }

      case 'pray-study': {
        const mpCurrent = document.getElementById('magic-points-current');
        const mpMax = document.getElementById('magic-points-original');
        let messages = [];
        
        if (mpCurrent && mpMax) {
          const currentMP = parseInt(mpCurrent.value) || 0;
          const maxMP = parseInt(mpMax.dataset.originalValue || mpMax.value) || 0;
          
          if (currentMP < maxMP) {
            const newMP = currentMP + 1;
            mpCurrent.value = newMP;
            mpCurrent.dispatchEvent(new Event('input', { bubbles: true }));
            messages.push(`Regained 1 Magic Point (now ${newMP}/${maxMP}).`);
          } else {
            messages.push('Magic Points already at maximum.');
          }
        }
        
        if (currentIndex <= WINDED_INDEX && currentIndex > 0) {
          const newIndex = currentIndex - 1;
          this.setFatigueState(stateOrder[newIndex], true);
          messages.push(`Fatigue reduced to ${this.formatFatigueState(stateOrder[newIndex])} (non-strenuous activity).`);
        } else if (currentIndex > WINDED_INDEX) {
          messages.push(`No fatigue recovery (currently ${this.formatFatigueState(currentState)}, must be Winded or better).`);
        }
        
        resultTitle = '📖 Study Complete';
        resultMessage = messages.join('<br>');
        break;
      }

      case 'tend-wounds': {
        resultTitle = '🩹 Tend to Wounds';
        resultMessage = '<strong>Wounds Tended:</strong><br>' +
          '• First Aid skill: 1 Rest Action (15 minutes)<br>' +
          '• Healing skill: 4 Rest Actions (1 hour)<br><br>' +
          '<em>This action does not remove Fatigue.</em>';
        resultType = 'info';
        break;
      }

      case 'cast-spells': {
        resultTitle = '✨ Spellcasting';
        resultMessage = '<strong>Cast Spells:</strong><br>' +
          'You may cast any number of healing or buff spells, limited by available Magic Points.<br><br>' +
          '<em>This action does not remove Fatigue.</em>';
        resultType = 'info';
        setTimeout(() => {
          this.navigateToPage('page-magic1');
        }, 2000);
        break;
      }

      case 'prepare-spell': {
        resultTitle = '📜 Spell Preparation';
        resultMessage = '<strong>Prepare a New Spell:</strong><br>' +
          'Following at least 8 hours of sleep, you may memorize or forget an Arcane or Divine spell.<br><br>' +
          '<em>This action does not remove Fatigue.</em>';
        resultType = 'info';
        setTimeout(() => {
          this.navigateToPage('page-magic1');
        }, 2000);
        break;
      }

      case 'dither': {
        let messages = [];
        
        if (currentIndex <= WINDED_INDEX && currentIndex > 0) {
          const newIndex = currentIndex - 1;
          this.setFatigueState(stateOrder[newIndex], true);
          messages.push(`Fatigue reduced to ${this.formatFatigueState(stateOrder[newIndex])} (non-strenuous activity).`);
        } else if (currentIndex > WINDED_INDEX) {
          messages.push(`No fatigue recovery (currently ${this.formatFatigueState(currentState)}, must be Winded or better).`);
        } else {
          messages.push('Already at Fresh - nothing to do but wait.');
        }
        
        messages.push('You waste 15 minutes doing nothing useful.');
        resultTitle = '💭 Time Wasted';
        resultMessage = messages.join('<br>');
        break;
      }

      case 'second-wind': {
        let messages = [];
        
        if (currentIndex === 0) {
          messages.push('Already at Fresh — no fatigue to recover.');
          resultType = 'info';
        } else {
          const levelsToRemove = Math.min(3, currentIndex);
          const newIndex = currentIndex - levelsToRemove;
          this.setFatigueState(stateOrder[newIndex], true);
          messages.push(`<strong>Second Wind!</strong> After a 1 hour rest, you recover ${levelsToRemove} level${levelsToRemove > 1 ? 's' : ''} of Fatigue.`);
          messages.push(`${this.formatFatigueState(currentState)} → ${this.formatFatigueState(stateOrder[newIndex])}`);
        }
        resultTitle = '💨 Second Wind';
        resultMessage = messages.join('<br>');
        break;
      }
    }

    // Show result in a toast/notification
    this.showShortRestToast(resultTitle, resultMessage, resultType);
  },
  
  /**
   * Show Short Rest result as a toast notification
   */
  showShortRestToast(title, message, type = 'success') {
    // Create or get the toast container
    let toast = document.getElementById('short-rest-toast');
    if (!toast) {
      toast = document.createElement('div');
      toast.id = 'short-rest-toast';
      toast.className = 'short-rest-toast';
      toast.innerHTML = `
        <div class="short-rest-toast-header">
          <span class="short-rest-toast-title"></span>
          <button class="short-rest-toast-close">&times;</button>
        </div>
        <div class="short-rest-toast-body"></div>
      `;
      document.body.appendChild(toast);
      
      toast.querySelector('.short-rest-toast-close').addEventListener('click', () => {
        toast.classList.remove('active');
      });
    }
    
    toast.className = `short-rest-toast ${type}`;
    toast.querySelector('.short-rest-toast-title').textContent = title;
    toast.querySelector('.short-rest-toast-body').innerHTML = message;
    
    // Show toast
    requestAnimationFrame(() => {
      toast.classList.add('active');
    });
    
    // Auto-hide after delay
    setTimeout(() => {
      toast.classList.remove('active');
    }, 4000);
  },

  /**
   * Show a result message in the Short Rest modal
   */
  showShortRestResult(type, message) {
    const result = document.getElementById('short-rest-result');
    if (result) {
      result.className = 'short-rest-result active ' + type;
      result.innerHTML = message;
    }
  },

  /**
   * Format fatigue state for display
   */
  formatFatigueState(state) {
    const labels = {
      fresh: 'Fresh', winded: 'Winded', tired: 'Tired', wearied: 'Wearied',
      exhausted: 'Exhausted', debilitated: 'Debilitated', incapacitated: 'Incapacitated',
      semiconscious: 'Semi-conscious', coma: 'Coma'
    };
    return labels[state] || state;
  },

  // ============================================
  // BERSERK RAGE SYSTEM
  // ============================================
  
  /**
   * Check if character has Berserk Rage ability and show/hide section
   */
  checkBerserkRageVisibility() {
    const section = document.getElementById('berserk-rage-section');
    if (!section) return;
    
    // Check if character has Berserk Rage ability
    const hasBerserkRage = this.hasAbility('Berserk Rage');
    
    if (hasBerserkRage) {
      section.style.display = '';
      this.initBerserkRage();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Initialize Berserk Rage system
   */
  initBerserkRage() {
    this.updateBerserkRageDisplay();
    this.setupBerserkRageListeners();
    
    // Restore rage state if character was raging
    if (this.character.isRaging) {
      this.restoreRageState();
    }
  },
  
  /**
   * Update Berserk Rage display values based on CON
   */
  updateBerserkRageDisplay() {
    const con = parseInt(this.character.attributes?.CON, 10) || 10;
    const maxUses = this.getMaxRageUses();
    const maxRounds = con;
    
    // Initialize uses remaining if not set
    if (this.character.rageUsesRemaining === undefined || this.character.rageUsesRemaining === null) {
      this.character.rageUsesRemaining = maxUses;
    }
    
    const usesAvail = document.getElementById('rage-uses-available');
    const usesMax = document.getElementById('rage-uses-max');
    const roundsMax = document.getElementById('rage-rounds-max');
    const roundsTotal = document.getElementById('rage-rounds-total');
    
    if (usesAvail) usesAvail.textContent = this.character.rageUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;
    if (roundsMax) roundsMax.textContent = maxRounds;
    if (roundsTotal) roundsTotal.textContent = maxRounds;
    
    // Update button state
    const rageBtn = document.getElementById('btn-rage-toggle');
    if (rageBtn) {
      rageBtn.disabled = this.character.rageUsesRemaining <= 0 && !this.character.isRaging;
    }
    
    // Update rage effects text based on Berserker rank
    // While raging: show what was actually applied. While not raging: show what will apply.
    const dmgEffectEl = document.getElementById('rage-effect-dmg');
    if (dmgEffectEl) {
      const stepsToShow = this.character.isRaging 
        ? (this.character.rageDmgStepsApplied || 1)
        : (this.getBerserkerRank() >= 5 ? 3 : (this.getBerserkerRank() >= 3 ? 2 : 1));
      dmgEffectEl.textContent = `Damage Mod: +${stepsToShow} step${stepsToShow > 1 ? 's' : ''}`;
    }
    
    // Update End Rage button text based on whether current rage is waived
    const endRageBtn = document.getElementById('btn-end-rage');
    if (endRageBtn && this.character.isRaging) {
      endRageBtn.textContent = this.character.currentRageIsWaived 
        ? 'End Rage (No Fatigue — Free Use!)' 
        : 'End Rage (1 Fatigue Level)';
    }
  },
  
  /**
   * Setup Berserk Rage button listeners
   */
  setupBerserkRageListeners() {
    const rageBtn = document.getElementById('btn-rage-toggle');
    const endRageBtn = document.getElementById('btn-end-rage');
    const resetBtn = document.getElementById('btn-reset-rage-uses');
    
    if (rageBtn && !rageBtn.dataset.listenerAdded) {
      rageBtn.addEventListener('click', () => {
        if (!this.character.isRaging) {
          this.startBerserkRage();
        }
      });
      rageBtn.dataset.listenerAdded = 'true';
    }
    
    if (endRageBtn && !endRageBtn.dataset.listenerAdded) {
      endRageBtn.addEventListener('click', () => {
        this.endBerserkRage(true);
      });
      endRageBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetBtn && !resetBtn.dataset.listenerAdded) {
      resetBtn.addEventListener('click', () => {
        this.resetRageUses();
      });
      resetBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Start Berserk Rage
   */
  startBerserkRage() {
    if (this.character.isRaging || this.character.rageUsesRemaining <= 0) return;
    
    this.character.isRaging = true;
    this.character.rageUsesRemaining--;
    
    // Track fatigue waiver for this rage (Rank 2: first 1 free, Rank 3+: first 2 free)
    const maxWaivers = this.getRageFatigueWaiverMax();
    const waiversUsed = this.character.rageFatigueWaiversUsed || 0;
    if (maxWaivers > 0 && waiversUsed < maxWaivers) {
      this.character.currentRageIsWaived = true;
      this.character.rageFatigueWaiversUsed = waiversUsed + 1;
    } else {
      this.character.currentRageIsWaived = false;
    }
    
    // Store pre-rage values
    this.character.preRageValues = {
      damageMod: document.getElementById('damage-mod-current')?.value || '+0',
      damageModOrig: document.getElementById('damage-mod-original')?.value || '+0',
      wpDamageMod: document.getElementById('wp-damage-mod-current')?.value || '',
      wpDamageModOrig: document.getElementById('wp-damage-mod-original')?.value || '',
      endurance: document.getElementById('endurance-current')?.value || '0',
      willpower: document.getElementById('willpower-current')?.value || '0',
      brawn: document.getElementById('brawn-current')?.value || '0',
      evade: (this.artfulDodgerDisplayed || this.lightningReflexesDisplayed)
        ? this.getEvadeWithoutDisplayBonuses().toString() 
        : (document.getElementById('evade-current')?.value || '0')
    };
    
    // Apply rage bonuses
    this.applyRageBonuses();
    
    // Update UI
    const rageBtn = document.getElementById('btn-rage-toggle');
    const tracker = document.getElementById('rage-tracker');
    const btnText = document.getElementById('rage-btn-text');
    
    if (rageBtn) {
      rageBtn.classList.add('raging');
      rageBtn.disabled = true;
    }
    if (tracker) tracker.style.display = '';
    if (btnText) btnText.textContent = '🔥 RAGING! 🔥';
    
    const roundsInput = document.getElementById('rage-rounds-used');
    if (roundsInput) roundsInput.value = 0;
    
    this.updateBerserkRageDisplay();
    
    // Strikethrough Artful Dodger if present
    this.setArtfulDodgerStrikethrough(true);
    
    this.scheduleAutoSave();
  },
  
  /**
   * Apply Berserk Rage bonuses
   */
  applyRageBonuses() {
    // Damage Mod steps based on Berserker rank: Rank 5 = +3 steps, Rank 3-4 = +2 steps, else +1 step
    const berserkerRank = this.getBerserkerRank();
    const dmgSteps = berserkerRank >= 5 ? 3 : (berserkerRank >= 3 ? 2 : 1);
    this.character.rageDmgStepsApplied = dmgSteps; // Track for display accuracy if rank changes mid-rage
    
    const dmgCurrField = document.getElementById('damage-mod-current');
    const dmgOrigField = document.getElementById('damage-mod-original');
    if (dmgCurrField) {
      let mod = dmgCurrField.value;
      for (let i = 0; i < dmgSteps; i++) {
        mod = this.getNextDamageModStep(mod);
      }
      dmgCurrField.value = mod;
      dmgCurrField.classList.add('rage-boosted');
      dmgCurrField.title = `+${dmgSteps} step${dmgSteps > 1 ? 's' : ''} due to Rage`;
    }
    if (dmgOrigField) {
      let mod = dmgOrigField.value;
      for (let i = 0; i < dmgSteps; i++) {
        mod = this.getNextDamageModStep(mod);
      }
      dmgOrigField.value = mod;
      dmgOrigField.classList.add('rage-boosted');
    }
    
    // Endurance +20%
    const enduranceField = document.getElementById('endurance-current');
    if (enduranceField) {
      const curr = parseInt(enduranceField.value, 10) || 0;
      enduranceField.value = curr + 20;
      enduranceField.classList.add('rage-boosted');
    }
    
    // Willpower +20%
    const willpowerField = document.getElementById('willpower-current');
    if (willpowerField) {
      const curr = parseInt(willpowerField.value, 10) || 0;
      willpowerField.value = curr + 20;
      willpowerField.classList.add('rage-boosted');
    }
    
    // Brawn +40%
    const brawnField = document.getElementById('brawn-current');
    if (brawnField) {
      const curr = parseInt(brawnField.value, 10) || 0;
      brawnField.value = curr + 40;
      brawnField.classList.add('rage-boosted');
    }
    
    // Evade -20% (use base value without display bonuses)
    const evadeField = document.getElementById('evade-current');
    if (evadeField) {
      // Remove display bonuses first if active
      const baseEvade = (this.artfulDodgerDisplayed || this.lightningReflexesDisplayed)
        ? this.getEvadeWithoutDisplayBonuses()
        : (parseInt(evadeField.value, 10) || 0);
      this.artfulDodgerDisplayed = false;
      this.lightningReflexesDisplayed = false;
      this._lightningReflexesBonus = 0;
      evadeField.value = Math.max(0, baseEvade - 20);
      evadeField.classList.add('rage-penalized');
      // Remove display bonus styling during rage
      evadeField.classList.remove('artful-dodger-bonus', 'lightning-reflexes-bonus');
      evadeField.title = '';
    }
    
    // Weapon Precision Damage Mod also gets rage steps (if WP is active)
    const wpDmgCurrField = document.getElementById('wp-damage-mod-current');
    const wpDmgOrigField = document.getElementById('wp-damage-mod-original');
    if (wpDmgCurrField && wpDmgCurrField.value.trim()) {
      let mod = wpDmgCurrField.value;
      for (let i = 0; i < dmgSteps; i++) {
        mod = this.getNextDamageModStep(mod);
      }
      wpDmgCurrField.value = mod;
      wpDmgCurrField.classList.add('rage-boosted');
      wpDmgCurrField.title = `+${dmgSteps} step${dmgSteps > 1 ? 's' : ''} due to Rage`;
    }
    if (wpDmgOrigField && wpDmgOrigField.value.trim()) {
      let mod = wpDmgOrigField.value;
      for (let i = 0; i < dmgSteps; i++) {
        mod = this.getNextDamageModStep(mod);
      }
      wpDmgOrigField.value = mod;
      wpDmgOrigField.classList.add('rage-boosted');
    }
    
    // Update weapon damage displays to reflect new Damage Modifier
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    
    // Style all weapon damage fields green to indicate rage boost
    const weaponDamageFields = document.querySelectorAll('.weapon-damage');
    weaponDamageFields.forEach(field => {
      if (field.value.trim()) {
        field.classList.add('rage-boosted');
        field.title = 'Increased damage modifier due to Rage';
      }
    });
    
    // Update summary page
    this.refreshSummaryWidgets();
  },
  
  /**
   * Remove Berserk Rage bonuses
   */
  removeRageBonuses() {
    if (!this.character.preRageValues) return;
    
    // Restore Damage Mod
    const dmgCurrField = document.getElementById('damage-mod-current');
    const dmgOrigField = document.getElementById('damage-mod-original');
    if (dmgCurrField) {
      dmgCurrField.value = this.character.preRageValues.damageMod;
      dmgCurrField.classList.remove('rage-boosted');
      dmgCurrField.title = '';
    }
    if (dmgOrigField) {
      dmgOrigField.value = this.character.preRageValues.damageModOrig;
      dmgOrigField.classList.remove('rage-boosted');
    }
    
    // Restore Endurance
    const enduranceField = document.getElementById('endurance-current');
    if (enduranceField) {
      enduranceField.value = this.character.preRageValues.endurance;
      enduranceField.classList.remove('rage-boosted');
    }
    
    // Restore Willpower
    const willpowerField = document.getElementById('willpower-current');
    if (willpowerField) {
      willpowerField.value = this.character.preRageValues.willpower;
      willpowerField.classList.remove('rage-boosted');
    }
    
    // Restore Brawn
    const brawnField = document.getElementById('brawn-current');
    if (brawnField) {
      brawnField.value = this.character.preRageValues.brawn;
      brawnField.classList.remove('rage-boosted');
    }
    
    // Restore Evade
    const evadeField = document.getElementById('evade-current');
    if (evadeField) {
      evadeField.value = this.character.preRageValues.evade;
      evadeField.classList.remove('rage-penalized');
    }
    
    // Restore WP Damage Mod
    const wpDmgCurrField = document.getElementById('wp-damage-mod-current');
    const wpDmgOrigField = document.getElementById('wp-damage-mod-original');
    if (wpDmgCurrField) {
      wpDmgCurrField.value = this.character.preRageValues.wpDamageMod || wpDmgCurrField.value;
      wpDmgCurrField.classList.remove('rage-boosted');
      wpDmgCurrField.title = '';
    }
    if (wpDmgOrigField) {
      wpDmgOrigField.value = this.character.preRageValues.wpDamageModOrig || wpDmgOrigField.value;
      wpDmgOrigField.classList.remove('rage-boosted');
    }
    
    // Update weapon damage displays to reflect restored Damage Modifier
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    
    // Remove rage styling from all weapon damage fields
    const weaponDamageFields = document.querySelectorAll('.weapon-damage');
    weaponDamageFields.forEach(field => {
      field.classList.remove('rage-boosted');
      field.title = '';
    });
    
    // Update summary page
    this.refreshSummaryWidgets();
    
    this.character.preRageValues = null;
    
    // Ensure DM current matches original now that rage is over
    this.resetDamageModToOriginalIfClean();
  },
  
  /**
   * End Berserk Rage
   * @param {boolean} applyFatigue - Whether to apply fatigue penalty
   */
  endBerserkRage(applyFatigue = true) {
    if (!this.character.isRaging) return;
    
    this.character.isRaging = false;
    
    // Remove rage bonuses
    this.removeRageBonuses();
    
    // Remove Artful Dodger strikethrough
    this.setArtfulDodgerStrikethrough(false);
    
    // Re-check Artful Dodger display to restore styling if applicable
    this.artfulDodgerDisplayed = false;
    this.updateArtfulDodgerDisplay();
    
    // Re-check Lightning Reflexes display
    this.lightningReflexesDisplayed = false;
    this.updateLightningReflexesDisplay();
    
    // Update UI
    const rageBtn = document.getElementById('btn-rage-toggle');
    const tracker = document.getElementById('rage-tracker');
    const btnText = document.getElementById('rage-btn-text');
    
    if (rageBtn) {
      rageBtn.classList.remove('raging');
      rageBtn.disabled = this.character.rageUsesRemaining <= 0;
    }
    if (tracker) tracker.style.display = 'none';
    if (btnText) btnText.textContent = "I'm RAGING!";
    
    this.updateBerserkRageDisplay();
    
    // Apply one level of fatigue (unless this rage was waived by Rank 2+/3+ passive)
    if (applyFatigue) {
      if (this.character.currentRageIsWaived) {
        // Rank passive: this rage has no fatigue cost — show notification
        alert('Rage ended! No fatigue — this use of Rage was free (Berserker rank bonus).');
      } else {
        this.increaseFatigueByOne();
      }
    }
    this.character.currentRageIsWaived = false;
    this.character.rageDmgStepsApplied = 0;
    
    this.scheduleAutoSave();
  },
  
  /**
   * Restore rage state after page load (if was raging)
   */
  restoreRageState() {
    // Re-apply visual state without changing values (they're already set)
    const rageBtn = document.getElementById('btn-rage-toggle');
    const tracker = document.getElementById('rage-tracker');
    const btnText = document.getElementById('rage-btn-text');
    
    if (rageBtn) {
      rageBtn.classList.add('raging');
      rageBtn.disabled = true;
    }
    if (tracker) tracker.style.display = '';
    if (btnText) btnText.textContent = '🔥 RAGING! 🔥';
    
    // Re-apply visual indicators to fields
    const dmgCurrField = document.getElementById('damage-mod-current');
    const dmgOrigField = document.getElementById('damage-mod-original');
    const enduranceField = document.getElementById('endurance-current');
    const willpowerField = document.getElementById('willpower-current');
    const brawnField = document.getElementById('brawn-current');
    const evadeField = document.getElementById('evade-current');
    
    if (dmgCurrField) {
      dmgCurrField.classList.add('rage-boosted');
      const steps = this.character.rageDmgStepsApplied || 1;
      dmgCurrField.title = `+${steps} step${steps > 1 ? 's' : ''} due to Rage`;
    }
    if (dmgOrigField) dmgOrigField.classList.add('rage-boosted');
    if (enduranceField) enduranceField.classList.add('rage-boosted');
    if (willpowerField) willpowerField.classList.add('rage-boosted');
    if (brawnField) brawnField.classList.add('rage-boosted');
    
    // WP Damage Mod fields
    const wpDmgCurrField = document.getElementById('wp-damage-mod-current');
    const wpDmgOrigField = document.getElementById('wp-damage-mod-original');
    if (wpDmgCurrField && wpDmgCurrField.value.trim()) {
      wpDmgCurrField.classList.add('rage-boosted');
      const steps = this.character.rageDmgStepsApplied || 1;
      wpDmgCurrField.title = `+${steps} step${steps > 1 ? 's' : ''} due to Rage`;
    }
    if (wpDmgOrigField && wpDmgOrigField.value.trim()) {
      wpDmgOrigField.classList.add('rage-boosted');
    }
    
    // Re-apply rage styling to all weapon damage fields
    const weaponDamageFields = document.querySelectorAll('.weapon-damage');
    weaponDamageFields.forEach(field => {
      if (field.value.trim()) {
        field.classList.add('rage-boosted');
        field.title = 'Increased damage modifier due to Rage';
      }
    });
    
    if (evadeField) {
      evadeField.classList.add('rage-penalized');
      // Remove display bonus styling during rage (restored when rage ends)
      evadeField.classList.remove('artful-dodger-bonus', 'lightning-reflexes-bonus');
      evadeField.title = '';
      this.artfulDodgerDisplayed = false;
      this.lightningReflexesDisplayed = false;
      this._lightningReflexesBonus = 0;
    }
    
    this.setArtfulDodgerStrikethrough(true);
    
    // Update dynamic rage text (damage steps, end-rage button) based on current rank
    this.updateBerserkRageDisplay();
  },
  
  /**
   * Increase fatigue by one level
   */
  increaseFatigueByOne() {
    const fatigueOrder = ['fresh', 'winded', 'tired', 'wearied', 'exhausted', 'debilitated', 'incapacitated', 'semiconscious', 'coma'];
    const currentState = this.character.fatigueState || 'fresh';
    const currentIndex = fatigueOrder.indexOf(currentState);
    
    if (currentIndex < fatigueOrder.length - 1) {
      const newState = fatigueOrder[currentIndex + 1];
      this.setFatigueState(newState, true);
      
      // Show notification
      alert(`Rage ended! Fatigue increased from ${this.formatFatigueState(currentState)} to ${this.formatFatigueState(newState)}.`);
    }
  },
  
  /**
   * Set strikethrough on Artful Dodger ability if present
   */
  setArtfulDodgerStrikethrough(strikethrough) {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    const inputs = container.querySelectorAll('.class-ability-input');
    inputs.forEach(input => {
      if (input.value.toLowerCase().trim() === 'artful dodger') {
        if (strikethrough) {
          input.classList.add('rage-disabled');
        } else {
          input.classList.remove('rage-disabled');
        }
      }
    });
  },
  
  /**
   * Check and update Artful Dodger bonus display based on current conditions
   * Called on: page load, ENC change, ability add/remove, rage end
   */
  updateArtfulDodgerDisplay() {
    const hasAbility = this.hasAbility('Artful Dodger');
    const currField = document.getElementById('evade-current');
    if (!currField) return;
    
    // Don't apply during rage
    if (this.character.isRaging) return;
    
    // If ability is not present, ensure display is clean
    if (!hasAbility) {
      if (this.artfulDodgerDisplayed) {
        // Remove display bonus
        const displayedVal = parseInt(currField.value, 10) || 0;
        currField.value = Math.max(0, displayedVal - 10);
        currField.classList.remove('artful-dodger-bonus');
        this.artfulDodgerDisplayed = false;
        this._updateEvadeBonusTitle(currField);
      }
      return;
    }
    
    // Check conditions (must be Unburdened AND wearing no heavier than Light armor)
    const statusEl = document.getElementById('enc-status');
    const statusName = statusEl?.textContent?.trim() || 'Unburdened';
    const isUnburdened = (statusName === 'Unburdened' || statusName === 'Extremely Unburdened');
    
    // Check armor condition: Light armor or less (using ArmorData classification)
    let isLightOrLess = true;
    if (isUnburdened) {
      const armorFields = document.querySelectorAll('[id$="-armor"]');
      for (const field of armorFields) {
        const armorName = (field.value || '').trim();
        if (armorName && window.ArmorData && window.ArmorData.isHeavyArmor(armorName)) {
          isLightOrLess = false;
          break;
        }
      }
    }
    
    const meetsConditions = isUnburdened && isLightOrLess;
    
    if (meetsConditions && !this.artfulDodgerDisplayed) {
      // Add display bonus
      const baseVal = parseInt(currField.value, 10) || 0;
      currField.value = baseVal + 10;
      currField.classList.add('artful-dodger-bonus');
      this.artfulDodgerDisplayed = true;
      this._updateEvadeBonusTitle(currField);
    } else if (!meetsConditions && this.artfulDodgerDisplayed) {
      // Remove display bonus
      const displayedVal = parseInt(currField.value, 10) || 0;
      currField.value = Math.max(0, displayedVal - 10);
      currField.classList.remove('artful-dodger-bonus');
      this.artfulDodgerDisplayed = false;
      this._updateEvadeBonusTitle(currField);
    }
    // If conditions match current state, do nothing
  },
  
  /**
   * Get Evade value without Artful Dodger bonus (for EXP improvement)
   */
  getEvadeWithoutArtfulDodger() {
    return this.getEvadeWithoutDisplayBonuses();
  },
  
  /**
   * Get Evade value without any display bonuses (Artful Dodger, Lightning Reflexes)
   */
  getEvadeWithoutDisplayBonuses() {
    const currField = document.getElementById('evade-current');
    if (!currField) return 0;
    
    let val = parseInt(currField.value, 10) || 0;
    if (this.artfulDodgerDisplayed) val -= 10;
    if (this.lightningReflexesDisplayed) val -= (this._lightningReflexesBonus || 0);
    return Math.max(0, val);
  },
  
  // ============================================
  // LIGHTNING REFLEXES ABILITY SYSTEM (MONK)
  // Adds +10 to Evade when Extremely Unburdened + No Armor
  // ============================================
  
  /**
   * Update Lightning Reflexes Evade display bonus
   * Called on: ENC change, armor change, ability add/remove
   */
  updateLightningReflexesDisplay() {
    const hasAbility = this.hasAbility('Lightning Reflexes');
    const currField = document.getElementById('evade-current');
    if (!currField) return;
    
    // Don't apply during rage
    if (this.character.isRaging) return;
    
    // Calculate current bonus: 10 + floor(Mysticism / 10)
    const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
    const currentBonus = 10 + Math.ceil(mysticismVal / 10);
    
    // If ability is not present, ensure display is clean
    if (!hasAbility) {
      if (this.lightningReflexesDisplayed) {
        const prevBonus = this._lightningReflexesBonus || 0;
        const displayedVal = parseInt(currField.value, 10) || 0;
        currField.value = Math.max(0, displayedVal - prevBonus);
        currField.classList.remove('lightning-reflexes-bonus');
        this.lightningReflexesDisplayed = false;
        this._lightningReflexesBonus = 0;
        this._updateEvadeBonusTitle(currField);
      }
      return;
    }
    
    // Must be monk, Extremely Unburdened, and unarmored
    const isMonk = this.isMonkClass();
    const isEU = this.isMonkExtremelyUnburdened();
    const isUnarmored = this.isMonkUnarmored();
    const meetsConditions = isMonk && isEU && isUnarmored;
    
    if (meetsConditions && !this.lightningReflexesDisplayed) {
      // Add display bonus
      const baseVal = parseInt(currField.value, 10) || 0;
      currField.value = baseVal + currentBonus;
      currField.classList.add('lightning-reflexes-bonus');
      this.lightningReflexesDisplayed = true;
      this._lightningReflexesBonus = currentBonus;
      this._updateEvadeBonusTitle(currField);
    } else if (meetsConditions && this.lightningReflexesDisplayed) {
      // Already displayed — check if Mysticism changed and bonus needs updating
      const prevBonus = this._lightningReflexesBonus || 0;
      if (currentBonus !== prevBonus) {
        const displayedVal = parseInt(currField.value, 10) || 0;
        currField.value = Math.max(0, displayedVal - prevBonus + currentBonus);
        this._lightningReflexesBonus = currentBonus;
        this._updateEvadeBonusTitle(currField);
      }
    } else if (!meetsConditions && this.lightningReflexesDisplayed) {
      // Remove display bonus
      const prevBonus = this._lightningReflexesBonus || 0;
      const displayedVal = parseInt(currField.value, 10) || 0;
      currField.value = Math.max(0, displayedVal - prevBonus);
      currField.classList.remove('lightning-reflexes-bonus');
      this.lightningReflexesDisplayed = false;
      this._lightningReflexesBonus = 0;
      this._updateEvadeBonusTitle(currField);
    }
  },
  
  /**
   * Update Evade field title to reflect all active display bonuses
   * Also updates the combat quick ref evade tooltip
   */
  _updateEvadeBonusTitle(evadeField) {
    const bonusParts = [];
    if (this.artfulDodgerDisplayed) bonusParts.push('+10 Artful Dodger');
    if (this.lightningReflexesDisplayed) {
      const bonus = this._lightningReflexesBonus || 0;
      const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
      bonusParts.push(`+${bonus} Lightning Reflexes (10 + ⌈${mysticismVal}/10⌉)`);
    }
    const titleText = bonusParts.length > 0 ? bonusParts.join(', ') : '';
    evadeField.title = titleText;
    
    // Also update combat quick ref evade tooltip and styling
    const refEvade = document.getElementById('ref-evade');
    if (refEvade) {
      refEvade.title = titleText;
      if (this.lightningReflexesDisplayed || this.artfulDodgerDisplayed) {
        refEvade.classList.add('lightning-reflexes-bonus');
      } else {
        refEvade.classList.remove('lightning-reflexes-bonus');
      }
    }
  },
  // Design: Never modify saved data. Store base Initiative in character.derived.
  // Only add +4 bonus to the DISPLAY field. Track display state with agileDisplayed flag.
  
  /**
   * Check and update Agile bonus display based on current conditions
   * Called on: page load, ENC change, armor change, ability add/remove
   */
  updateAgileDisplay() {
    const hasAbility = this.hasAbility('Agile');
    const currField = document.getElementById('initiative-current');
    if (!currField) return;
    
    // If ability is not present, ensure display is clean
    if (!hasAbility) {
      if (this.agileDisplayed) {
        // Remove display bonus
        const displayedVal = parseInt(currField.value, 10) || 0;
        currField.value = Math.max(0, displayedVal - 4);
        currField.classList.remove('agile-bonus');
        this.agileDisplayed = false;
        this._updateInitBonusTitle(currField);
      }
      return;
    }
    
    // Check conditions
    const meetsConditions = this.checkAgileConditions();
    
    if (meetsConditions && !this.agileDisplayed) {
      // Add display bonus
      const baseVal = parseInt(currField.value, 10) || 0;
      currField.value = baseVal + 4;
      currField.classList.add('agile-bonus');
      this.agileDisplayed = true;
      this._updateInitBonusTitle(currField);
    } else if (!meetsConditions && this.agileDisplayed) {
      // Remove display bonus
      const displayedVal = parseInt(currField.value, 10) || 0;
      currField.value = Math.max(0, displayedVal - 4);
      currField.classList.remove('agile-bonus');
      this.agileDisplayed = false;
      this._updateInitBonusTitle(currField);
    }
    // If conditions match current state, do nothing
  },
  
  /**
   * Check if all Agile conditions are met
   * Returns true if: Unburdened AND light armor AND 50%+ Evade/Acrobatics
   */
  checkAgileConditions() {
    // Condition 1: Unburdened
    const statusEl = document.getElementById('enc-status');
    const statusName = statusEl?.textContent?.trim() || 'Unburdened';
    const isUnburdened = (statusName === 'Unburdened' || statusName === 'Extremely Unburdened');
    if (!isUnburdened) return false;
    
    // Condition 2: Light armor or less (using ArmorData classification)
    const armorFields = document.querySelectorAll('[id$="-armor"]');
    for (const field of armorFields) {
      const armorName = (field.value || '').trim();
      if (armorName && window.ArmorData && window.ArmorData.isHeavyArmor(armorName)) {
        return false; // Heavy armor found
      }
    }
    
    // Condition 3: 50%+ in Evade or Acrobatics
    let evadeVal = parseInt(document.getElementById('evade-current')?.value, 10) || 0;
    if (this.artfulDodgerDisplayed || this.lightningReflexesDisplayed) {
      evadeVal = this.getEvadeWithoutDisplayBonuses();
    }
    if (evadeVal >= 50) return true;
    
    // Check Acrobatics in professional skills
    for (let i = 0, _n = this._profSkillRowCount(); i < _n; i++) {
      const nameField = document.getElementById(`prof-skill-${i}-name`);
      const currentField = document.getElementById(`prof-skill-${i}-current`);
      if (nameField && currentField) {
        if ((nameField.value || '').toLowerCase().trim() === 'acrobatics') {
          if ((parseInt(currentField.value, 10) || 0) >= 50) return true;
        }
      }
    }
    
    return false;
  },

  // ============================================
  // VERY AGILE ABILITY SYSTEM (MONK)
  // Adds +1/10 Mysticism (min +5) to Initiative when Extremely Unburdened + No Armor
  // ============================================
  
  updateVeryAgileDisplay() {
    const hasAbility = this.hasAbility('Very Agile');
    const currField = document.getElementById('initiative-current');
    if (!currField) return;
    
    // Calculate current bonus: max(5, ceil(Mysticism / 10))
    const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
    const currentBonus = Math.max(5, Math.ceil(mysticismVal / 10));
    
    // If ability is not present, ensure display is clean
    if (!hasAbility) {
      if (this.veryAgileDisplayed) {
        const prevBonus = this._veryAgileBonus || 0;
        const displayedVal = parseInt(currField.value, 10) || 0;
        currField.value = Math.max(0, displayedVal - prevBonus);
        currField.classList.remove('agile-bonus');
        this.veryAgileDisplayed = false;
        this._veryAgileBonus = 0;
        this._updateInitBonusTitle(currField);
      }
      return;
    }
    
    // Must be Extremely Unburdened and unarmored
    const isMonk = this.isMonkClass();
    const isEU = this.isMonkExtremelyUnburdened();
    const isUnarmored = this.isMonkUnarmored();
    const meetsConditions = isMonk && isEU && isUnarmored;
    
    if (meetsConditions && !this.veryAgileDisplayed) {
      // Add display bonus
      const baseVal = parseInt(currField.value, 10) || 0;
      currField.value = baseVal + currentBonus;
      currField.classList.add('agile-bonus');
      this.veryAgileDisplayed = true;
      this._veryAgileBonus = currentBonus;
      this._updateInitBonusTitle(currField);
    } else if (meetsConditions && this.veryAgileDisplayed) {
      // Already displayed — check if Mysticism changed and bonus needs updating
      const prevBonus = this._veryAgileBonus || 0;
      if (currentBonus !== prevBonus) {
        const displayedVal = parseInt(currField.value, 10) || 0;
        currField.value = Math.max(0, displayedVal - prevBonus + currentBonus);
        this._veryAgileBonus = currentBonus;
        this._updateInitBonusTitle(currField);
      }
    } else if (!meetsConditions && this.veryAgileDisplayed) {
      // Remove display bonus
      const prevBonus = this._veryAgileBonus || 0;
      const displayedVal = parseInt(currField.value, 10) || 0;
      currField.value = Math.max(0, displayedVal - prevBonus);
      currField.classList.remove('agile-bonus');
      this.veryAgileDisplayed = false;
      this._veryAgileBonus = 0;
      this._updateInitBonusTitle(currField);
    }
  },
  
  /**
   * Update Initiative field title to reflect all active display bonuses
   */
  _updateInitBonusTitle(initField) {
    const parts = [];
    if (this.agileDisplayed) parts.push('+4 Agile');
    if (this.veryAgileDisplayed) {
      const bonus = this._veryAgileBonus || 0;
      const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
      parts.push(`+${bonus} Very Agile (⌈${mysticismVal}/10⌉, min 5)`);
    }
    initField.title = parts.length > 0 ? parts.join(', ') : '';
  },

  // ============================================
  // KI STRIKE ABILITY SYSTEM (MONK)
  // Adds "Magical" to Unarmed weapon traits
  // ============================================
  
  _applyKiStrikeTrait(add) {
    const monkRank = this.getMonkRank();
    for (let i = 1; i <= 5; i++) {
      const nameInput = document.getElementById(`melee-${i}-name`);
      if (!nameInput || nameInput.value.toLowerCase().trim() !== 'unarmed') continue;
      
      const traitsInput = document.getElementById(`melee-${i}-traits`);
      if (!traitsInput) continue;
      
      const currentTraits = traitsInput.value.trim();
      // Remove any existing Ki Strike trait ("+N Magical weapon" or "Magical")
      let cleanedTraits = currentTraits
        .replace(/,?\s*\+\d+ Magical weapon\s*/gi, '')
        .replace(/,?\s*Magical\s*/gi, '')
        .replace(/^\s*,\s*/, '')
        .replace(/,\s*$/, '')
        .replace(/^[–—-]$/, '') // Remove lone dash
        .trim();
      
      if (add) {
        const kiTrait = `+${monkRank} Magical weapon`;
        traitsInput.value = cleanedTraits ? `${cleanedTraits}, ${kiTrait}` : kiTrait;
      } else {
        traitsInput.value = cleanedTraits || '–';
      }
      break;
    }
  },

  // ============================================
  // NETHER WALK ABILITY (MONK)
  // Teleport up to 1/10 Mysticism in feet, 1/day
  // ============================================
  
  checkNertherWalkVisibility() {
    const section = document.getElementById('nether-walk-section');
    if (!section) return;
    
    if (this.hasAbility('Nether Walk')) {
      section.style.display = '';
      this.initNetherWalk();
    } else {
      section.style.display = 'none';
    }
  },
  
  initNetherWalk() {
    if (this.character.netherWalkUsesRemaining === undefined) {
      this.character.netherWalkUsesRemaining = 1;
    }
    
    // Update distance display
    const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
    const distance = Math.ceil(mysticismVal / 10);
    const distEl = document.getElementById('nether-walk-distance');
    const usesEl = document.getElementById('nether-walk-uses');
    if (distEl) distEl.textContent = distance;
    if (usesEl) usesEl.textContent = this.character.netherWalkUsesRemaining;
    
    const btn = document.getElementById('btn-nether-walk-use');
    const resetBtn = document.getElementById('btn-reset-nether-walk');
    
    if (btn) {
      btn.disabled = this.character.netherWalkUsesRemaining <= 0;
      if (this.character.netherWalkUsesRemaining <= 0) {
        btn.style.background = '#555';
      } else {
        btn.style.background = '#7c4dff';
      }
    }
    
    if (btn && !btn.dataset.listenerAttached) {
      btn.addEventListener('click', () => this.useNetherWalk());
      btn.dataset.listenerAttached = 'true';
    }
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.addEventListener('click', () => {
        this.character.netherWalkUsesRemaining = 1;
        this.initNetherWalk();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAttached = 'true';
    }
  },

  // ============================================
  // QUIVERING PALM ABILITY (MONK)
  // ============================================
  
  checkQuiveringPalmVisibility() {
    const section = document.getElementById('quivering-palm-section');
    if (!section) return;
    
    if (this.hasAbility('Quivering Palm')) {
      section.style.display = '';
      this.initQuiveringPalm();
    } else {
      section.style.display = 'none';
    }
  },
  
  initQuiveringPalm() {
    // State: 'ready', 'initiated', 'cooldown'
    if (this.character.qpState === undefined) this.character.qpState = 'ready';
    if (this.character.qpRestCount === undefined) this.character.qpRestCount = 0;
    
    const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
    const maxSiz = Math.floor(mysticismVal / 4);
    const daysToTrigger = Math.ceil(mysticismVal / 20);
    
    const statusEl = document.getElementById('qp-status-text');
    const maxSizEl = document.getElementById('qp-max-siz');
    const initiateBtn = document.getElementById('btn-qp-initiate');
    const triggerBtn = document.getElementById('btn-qp-trigger');
    const restTracker = document.getElementById('qp-rest-tracker');
    const restCountEl = document.getElementById('qp-rest-count');
    
    if (maxSizEl) maxSizEl.textContent = maxSiz;
    
    if (this.character.qpState === 'ready') {
      if (statusEl) { statusEl.textContent = 'Ready'; statusEl.style.color = '#4caf50'; }
      if (initiateBtn) { initiateBtn.style.display = ''; initiateBtn.disabled = false; }
      if (triggerBtn) triggerBtn.style.display = 'none';
      if (restTracker) restTracker.style.display = 'none';
    } else if (this.character.qpState === 'initiated') {
      if (statusEl) { statusEl.textContent = `You have ${daysToTrigger} days to end the vibrations and cause the target's death.`; statusEl.style.color = '#ff9800'; }
      if (initiateBtn) initiateBtn.style.display = 'none';
      if (triggerBtn) { triggerBtn.style.display = ''; triggerBtn.disabled = false; }
      if (restTracker) restTracker.style.display = 'none';
    } else if (this.character.qpState === 'cooldown') {
      if (statusEl) { statusEl.textContent = `Cooldown (${this.character.qpRestCount}/7 Long Rests)`; statusEl.style.color = '#f44336'; }
      if (initiateBtn) { initiateBtn.style.display = ''; initiateBtn.disabled = true; }
      if (triggerBtn) triggerBtn.style.display = 'none';
      if (restTracker) restTracker.style.display = '';
      if (restCountEl) restCountEl.textContent = this.character.qpRestCount;
    }
    
    // Setup listeners (only once)
    if (initiateBtn && !initiateBtn.dataset.listenerAttached) {
      initiateBtn.addEventListener('click', () => {
        const mysVal = this.getSkillValueByName('Mysticism') || 0;
        const days = Math.ceil(mysVal / 20);
        const mSiz = Math.floor(mysVal / 4);
        
        this.showConfirmModal('💀 Quivering Palm', `
          <div class="modal-confirm-body">
            <div class="confirm-icon">💀</div>
            <div class="confirm-text">You initiate vibrations in your hand.</div>
            <div class="confirm-details">
              • You have <strong>3 Melee Rounds</strong> to touch your target<br>
              • Max target SIZ: <strong>${mSiz}</strong><br>
              • You have <strong>${days} days</strong> to trigger the death<br>
              • No effect on undead or magic-weapon-only creatures<br>
              • Requires Extremely Unburdened + No Armor
            </div>
          </div>
        `, () => {
          this.character.qpState = 'initiated';
          this.initQuiveringPalm();
          this.scheduleAutoSave();
        });
      });
      initiateBtn.dataset.listenerAttached = 'true';
    }
    
    if (triggerBtn && !triggerBtn.dataset.listenerAttached) {
      triggerBtn.addEventListener('click', () => this.triggerQuiveringPalm());
      triggerBtn.dataset.listenerAttached = 'true';
    }
    
    const resetBtn = document.getElementById('btn-reset-qp');
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.addEventListener('click', () => {
        this.character.qpState = 'ready';
        this.character.qpRestCount = 0;
        this.initQuiveringPalm();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAttached = 'true';
    }
    
    const restBtn = document.getElementById('btn-qp-rest');
    if (restBtn && !restBtn.dataset.listenerAttached) {
      restBtn.addEventListener('click', () => {
        this.character.qpRestCount = (this.character.qpRestCount || 0) + 1;
        if (this.character.qpRestCount >= 7) {
          this.character.qpState = 'ready';
          this.character.qpRestCount = 0;
        }
        this.initQuiveringPalm();
        this.scheduleAutoSave();
      });
      restBtn.dataset.listenerAttached = 'true';
    }
  },
  
  triggerQuiveringPalm() {
    const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
    const adjustedMysticism = mysticismVal - 20; // Mysticism -20%
    const roll = Math.floor(Math.random() * 100) + 1;
    const success = roll <= adjustedMysticism && roll !== 100;
    
    // Enter cooldown regardless
    this.character.qpState = 'cooldown';
    this.character.qpRestCount = 0;
    this.initQuiveringPalm();
    this.scheduleAutoSave();
    
    if (success) {
      this._showQuiveringPalmAnimation(true, roll, adjustedMysticism);
    } else {
      this._showQuiveringPalmAnimation(false, roll, adjustedMysticism);
    }
  },
  
  _showQuiveringPalmAnimation(success, roll, target) {
    let overlay = document.getElementById('qp-animation-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'qp-animation-overlay';
      document.body.appendChild(overlay);
    }
    
    if (success) {
      overlay.innerHTML = `
        <div class="qp-anim-content">
          <div class="qp-skull">💀</div>
          <div class="qp-result-title" style="color: #f44336;">DEATH</div>
          <div class="qp-result-text">Your target dies instantly.</div>
          <div class="qp-roll-info">Rolled ${roll} vs Mysticism −20% (${target}%) — Success</div>
        </div>
      `;
    } else {
      overlay.innerHTML = `
        <div class="qp-anim-content">
          <div class="qp-skull">✋</div>
          <div class="qp-result-title" style="color: #ff9800;">FAILURE</div>
          <div class="qp-result-text">You fail to kill your target.</div>
          <div class="qp-roll-info">Rolled ${roll} vs Mysticism −20% (${target}%) — Failed</div>
        </div>
      `;
    }
    
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; transition: background 0.5s;
    `;
    
    const content = overlay.querySelector('.qp-anim-content');
    content.style.cssText = `
      text-align: center; opacity: 0; transform: scale(0.3);
      transition: opacity 0.6s, transform 0.6s;
    `;
    
    overlay.querySelector('.qp-skull').style.cssText = `
      font-size: 4rem; margin-bottom: 0.5rem;
      ${success ? 'animation: qpPulse 0.8s ease-in-out 3;' : ''}
    `;
    
    overlay.querySelector('.qp-result-title').style.cssText += `
      font-size: 2rem; font-weight: bold; margin: 0.5rem 0;
    `;
    
    overlay.querySelector('.qp-result-text').style.cssText = `
      font-size: 1.1rem; color: #e0e0e0; margin: 0.5rem 0;
    `;
    
    overlay.querySelector('.qp-roll-info').style.cssText = `
      font-size: 0.8rem; color: #888; margin-top: 1rem;
    `;
    
    // Add pulse animation if not present
    if (!document.getElementById('qp-pulse-style')) {
      const style = document.createElement('style');
      style.id = 'qp-pulse-style';
      style.textContent = `
        @keyframes qpPulse {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.3); }
        }
      `;
      document.head.appendChild(style);
    }
    
    requestAnimationFrame(() => {
      overlay.style.background = success ? 'rgba(30, 0, 0, 0.85)' : 'rgba(0, 0, 0, 0.8)';
      content.style.opacity = '1';
      content.style.transform = 'scale(1)';
    });
    
    overlay.addEventListener('click', () => {
      content.style.opacity = '0';
      content.style.transform = 'scale(0.8)';
      overlay.style.background = 'rgba(0, 0, 0, 0)';
      setTimeout(() => { if (overlay.parentNode) overlay.parentNode.removeChild(overlay); }, 500);
    });
  },

  // ============================================
  // PERFECTION ABILITY (MONK)
  // ============================================
  
  checkPerfectionVisibility() {
    const section = document.getElementById('perfection-section');
    if (!section) return;
    
    if (this.hasAbility('Perfection')) {
      section.style.display = '';
      this.initPerfection();
    } else {
      section.style.display = 'none';
    }
  },
  
  initPerfection() {
    if (this.character.perfectionRoundsRemaining === undefined) this.character.perfectionRoundsRemaining = 20;
    if (this.character.perfectionActive === undefined) this.character.perfectionActive = false;
    
    const roundsEl = document.getElementById('perfection-rounds');
    const btnText = document.getElementById('perfection-btn-text');
    const btn = document.getElementById('btn-perfection-toggle');
    const resetBtn = document.getElementById('btn-reset-perfection');
    
    if (roundsEl) roundsEl.textContent = this.character.perfectionRoundsRemaining;
    
    if (this.character.perfectionActive) {
      if (btnText) btnText.textContent = 'Deactivate Perfection';
      if (btn) btn.style.background = '#b71c1c';
      // Re-apply 10 AP styling on load if still active
      this._reapplyPerfectionAPStyle();
    } else {
      if (btnText) btnText.textContent = 'Activate Perfection';
      if (btn) {
        btn.style.background = '#1a237e';
        btn.disabled = this.character.perfectionRoundsRemaining <= 0;
      }
    }
    
    if (btn && !btn.dataset.listenerAttached) {
      btn.addEventListener('click', () => this.togglePerfection());
      btn.dataset.listenerAttached = 'true';
    }
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.addEventListener('click', () => {
        this.character.perfectionRoundsRemaining = 20;
        this.initPerfection();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAttached = 'true';
    }
  },
  
  togglePerfection() {
    if (this.character.perfectionActive) {
      // Deactivate — restore AP values
      this._restorePerfectionAP();
      this.character.perfectionActive = false;
      this.initPerfection();
      this.scheduleAutoSave();
    } else {
      // Activate — save current AP values and set all to 10
      if (this.character.perfectionRoundsRemaining <= 0) {
        this.showResultModal('✨ Perfection', '<div class="modal-result-body"><div class="result-title failure">No Perfection rounds remaining today.</div></div>');
        return;
      }
      this._applyPerfectionAP();
      this.character.perfectionActive = true;
      
      this.showResultModal('✨ Perfection Activated', `
        <div class="modal-result-body">
          <div class="result-icon">✨</div>
          <div class="result-text" style="line-height: 1.6;">
            All Hit Locations now have <strong style="color: #6a1b9a;">10 AP</strong> (magical armor)<br>
            You are immune to Charm spells<br>
            <strong style="color: #b8860b;">You have ${this.character.perfectionRoundsRemaining} Combat Rounds to use Perfection.</strong>
          </div>
          <div class="result-meta">
            When you wish, you may press the Perfection button again to stop.
          </div>
        </div>
      `);
      
      this.initPerfection();
      this.scheduleAutoSave();
    }
  },
  
  _applyPerfectionAP() {
    // Save current AP values before overwriting
    const savedAPs = [];
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return;
    
    const rows = tbody.querySelectorAll('tr');
    rows.forEach((row, i) => {
      const apInput = row.querySelector('.ap-input');
      if (apInput) {
        savedAPs.push(parseInt(apInput.value, 10) || 0);
        apInput.value = 10;
        apInput.dataset.perfectionSaved = savedAPs[savedAPs.length - 1];
        apInput.style.color = '#b388ff';
        apInput.title = 'Perfection: 10 magical AP (original: ' + savedAPs[savedAPs.length - 1] + ')';
      } else {
        savedAPs.push(0);
      }
    });
    
    this.character.perfectionSavedAPs = savedAPs;
    this.updateUnarmedAPHP();
    this.scheduleAutoSave();
  },
  
  _restorePerfectionAP() {
    const savedAPs = this.character.perfectionSavedAPs || [];
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return;
    
    const rows = tbody.querySelectorAll('tr');
    rows.forEach((row, i) => {
      const apInput = row.querySelector('.ap-input');
      if (apInput) {
        apInput.value = savedAPs[i] !== undefined ? savedAPs[i] : 0;
        delete apInput.dataset.perfectionSaved;
        apInput.style.color = '';
        apInput.title = '';
      }
    });
    
    delete this.character.perfectionSavedAPs;
    this.updateUnarmedAPHP();
    this.scheduleAutoSave();
  },
  
  _reapplyPerfectionAPStyle() {
    const savedAPs = this.character.perfectionSavedAPs || [];
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return;
    
    const rows = tbody.querySelectorAll('tr');
    rows.forEach((row, i) => {
      const apInput = row.querySelector('.ap-input');
      if (apInput) {
        apInput.value = 10;
        apInput.style.color = '#b388ff';
        apInput.title = 'Perfection: 10 magical AP (original: ' + (savedAPs[i] !== undefined ? savedAPs[i] : 0) + ')';
      }
    });
    this.updateUnarmedAPHP();
  },
  
  useNetherWalk() {
    if (!this.character.netherWalkUsesRemaining || this.character.netherWalkUsesRemaining <= 0) {
      alert('Nether Walk has already been used today.');
      return;
    }
    
    const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
    const distance = Math.ceil(mysticismVal / 10);
    
    // Create teleport animation overlay
    let overlay = document.getElementById('nether-walk-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'nether-walk-overlay';
      document.body.appendChild(overlay);
    }
    
    overlay.innerHTML = `
      <div class="nw-animation">
        <div class="nw-particles"></div>
        <div class="nw-flash"></div>
        <div class="nw-text">
          <div class="nw-title">✨ Nether Walk ✨</div>
          <div class="nw-distance">You teleport up to <strong>${distance} ft</strong> away.</div>
          <div class="nw-note">You must spend 1 full round recovering.<br>Defenses are 1 Difficulty Grade harder.</div>
        </div>
      </div>
    `;
    
    // Apply styles
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0); z-index: 10000;
      display: flex; align-items: center; justify-content: center;
      transition: background 0.4s;
    `;
    
    const animDiv = overlay.querySelector('.nw-animation');
    animDiv.style.cssText = `
      text-align: center; opacity: 0; transform: scale(0.5);
      transition: opacity 0.5s, transform 0.5s;
    `;
    
    const flash = overlay.querySelector('.nw-flash');
    flash.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: radial-gradient(circle, rgba(179, 136, 255, 0.4), transparent 70%);
      opacity: 0; pointer-events: none;
      transition: opacity 0.3s;
    `;
    
    const textDiv = overlay.querySelector('.nw-text');
    textDiv.style.cssText = `
      position: relative; z-index: 1; padding: 2rem;
      background: rgba(20, 10, 40, 0.9); border: 2px solid #b388ff;
      border-radius: 12px; color: #e0d0ff; max-width: 340px;
    `;
    
    overlay.querySelector('.nw-title').style.cssText = `
      font-size: 1.4rem; font-weight: bold; color: #b388ff; margin-bottom: 0.5rem;
    `;
    
    overlay.querySelector('.nw-distance').style.cssText = `
      font-size: 1.1rem; margin: 0.75rem 0; color: #e0d0ff;
    `;
    
    overlay.querySelector('.nw-note').style.cssText = `
      font-size: 0.78rem; color: #999; margin-top: 0.5rem;
    `;
    
    const particles = overlay.querySelector('.nw-particles');
    particles.style.cssText = `
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none; overflow: hidden;
    `;
    
    // Create sparkle particles
    for (let p = 0; p < 20; p++) {
      const spark = document.createElement('div');
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      const delay = Math.random() * 0.8;
      const size = 2 + Math.random() * 4;
      spark.style.cssText = `
        position: absolute; left: ${x}%; top: ${y}%;
        width: ${size}px; height: ${size}px; border-radius: 50%;
        background: #b388ff; opacity: 0;
        animation: nwSparkle 1.5s ease-in-out ${delay}s;
      `;
      particles.appendChild(spark);
    }
    
    // Add keyframe animation if not yet added
    if (!document.getElementById('nw-sparkle-style')) {
      const style = document.createElement('style');
      style.id = 'nw-sparkle-style';
      style.textContent = `
        @keyframes nwSparkle {
          0% { opacity: 0; transform: scale(0) translateY(0); }
          30% { opacity: 1; transform: scale(1.5) translateY(-10px); }
          70% { opacity: 0.8; transform: scale(1) translateY(-30px); }
          100% { opacity: 0; transform: scale(0) translateY(-60px); }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Animate in
    requestAnimationFrame(() => {
      overlay.style.background = 'rgba(0, 0, 0, 0.7)';
      flash.style.opacity = '1';
      animDiv.style.opacity = '1';
      animDiv.style.transform = 'scale(1)';
    });
    
    // Flash out after brief moment
    setTimeout(() => { flash.style.opacity = '0'; }, 600);
    
    // Close on click
    const closeNW = () => {
      overlay.style.background = 'rgba(0, 0, 0, 0)';
      animDiv.style.opacity = '0';
      animDiv.style.transform = 'scale(0.8)';
      setTimeout(() => {
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
      }, 400);
    };
    
    overlay.addEventListener('click', closeNW);
    
    // Deduct use
    this.character.netherWalkUsesRemaining = 0;
    this.initNetherWalk();
    this.scheduleAutoSave();
  },

  /**
   * Get the next step up in damage modifier progression
   */
  getNextDamageModStep(currentMod) {
    const progression = [
      '-1d8', '-1d6', '-1d4', '-1d2', '+0',
      '+1d2', '+1d4', '+1d6', '+1d8', '+1d10', '+1d12',
      '+2d6', '+1d8+1d6', '+2d8', '+1d10+1d8', '+2d10',
      '+2d10+1d2', '+2d10+1d4', '+2d10+1d6', '+2d10+1d8', '+2d10+1d10'
    ];
    
    const normalized = currentMod.replace(/\s/g, '');
    const currentIndex = progression.findIndex(m => m === normalized);
    
    if (currentIndex === -1) {
      // Not found, try to find closest match
      if (normalized === '0' || normalized === '') return '+1d2';
      return currentMod; // Return unchanged if unknown
    }
    
    if (currentIndex < progression.length - 1) {
      return progression[currentIndex + 1];
    }
    
    return currentMod; // Already at max
  },
  
  /**
   * Compare two damage modifiers and return the higher one
   * Uses progression index for comparison
   */
  getHigherDamageMod(modA, modB) {
    const progression = [
      '-1d8', '-1d6', '-1d4', '-1d2', '+0',
      '+1d2', '+1d4', '+1d6', '+1d8', '+1d10', '+1d12',
      '+2d6', '+1d8+1d6', '+2d8', '+1d10+1d8', '+2d10',
      '+2d10+1d2', '+2d10+1d4', '+2d10+1d6', '+2d10+1d8', '+2d10+1d10'
    ];
    
    const normA = (modA || '+0').replace(/\s/g, '');
    const normB = (modB || '+0').replace(/\s/g, '');
    const indexA = progression.indexOf(normA);
    const indexB = progression.indexOf(normB);
    
    // If either not found, return the one that was found, or modA as fallback
    if (indexA === -1 && indexB === -1) return modA;
    if (indexA === -1) return modB;
    if (indexB === -1) return modA;
    
    return indexA >= indexB ? modA : modB;
  },
  
  /**
   * Get the rank of the Berserker class (checks all class slots)
   */
  getBerserkerRank() {
    const slots = [
      { cls: 'class-primary', rank: 'rank-primary' },
      { cls: 'class-secondary', rank: 'rank-secondary' },
      { cls: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    for (const slot of slots) {
      const className = document.getElementById(slot.cls)?.value?.trim().toLowerCase() || '';
      if (className === 'berserker') {
        return parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      }
    }
    return 0;
  },
  
  /**
   * Get maximum fatigue waivers per day based on Berserker rank
   * Rank 2: first 1 rage free, Rank 3+: first 2 rages free
   */
  getRageFatigueWaiverMax() {
    const rank = this.getBerserkerRank();
    if (rank >= 5) return 4;
    if (rank >= 4) return 3;
    if (rank >= 3) return 2;
    if (rank >= 2) return 1;
    return 0;
  },
  
  /**
   * Get maximum Berserk Rage uses per day
   * Base = ceil(CON / 4), plus +1 for each Extra Rage ability
   */
  getMaxRageUses() {
    const con = parseInt(this.character.attributes?.CON, 10) || 10;
    let maxUses = Math.ceil(con / 4);
    
    // Extra Rage abilities add +1 each
    if (this.hasAbility('Extra Rage I') || this.hasAbility('Extra Rage 1')) maxUses += 1;
    if (this.hasAbility('Extra Rage II') || this.hasAbility('Extra Rage 2')) maxUses += 1;
    if (this.hasAbility('Extra Rage III') || this.hasAbility('Extra Rage 3')) maxUses += 1;
    if (this.hasAbility('Extra Rage IV') || this.hasAbility('Extra Rage 4')) maxUses += 1;
    
    return maxUses;
  },

  /**
   * Reset rage uses (called on long rest)
   */
  resetRageUses() {
    this.character.rageUsesRemaining = this.getMaxRageUses();
    this.character.rageFatigueWaiversUsed = 0;
    this.updateBerserkRageDisplay();
    this.scheduleAutoSave();
  },
  
  // ============================================
  // FORCEFUL STRIKE SYSTEM
  // ============================================
  
  /**
   * Check if character has Forceful Strike ability and show/hide section
   */
  checkForcefulStrikeVisibility() {
    const section = document.getElementById('forceful-strike-section');
    if (!section) return;
    
    // Check if character has Forceful Strike ability
    const hasForcefulStrike = this.hasAbility('Forceful Strike');
    
    if (hasForcefulStrike) {
      section.style.display = '';
      this.initForcefulStrike();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Initialize Forceful Strike system
   */
  initForcefulStrike() {
    this.setupForcefulStrikeListeners();
    
    // Restore state if it was active
    if (this.character.isForcefulStrikeActive) {
      this.restoreForcefulStrikeState();
    }
  },
  
  /**
   * Setup Forceful Strike button listeners
   */
  setupForcefulStrikeListeners() {
    const toggleBtn = document.getElementById('btn-forceful-toggle');
    
    if (toggleBtn && !toggleBtn.dataset.listenerAdded) {
      toggleBtn.addEventListener('click', () => {
        if (this.character.isForcefulStrikeActive) {
          this.deactivateForcefulStrike();
        } else {
          this.activateForcefulStrike();
        }
      });
      toggleBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Activate Forceful Strike
   */
  activateForcefulStrike() {
    if (this.character.isForcefulStrikeActive) return;
    
    // Capture baseline before any changes
    this.captureBaselineIfNeeded();
    
    this.character.isForcefulStrikeActive = true;
    
    // Recalculate all buffs from baseline
    this.recalculateCombatBuffs();
    
    // Update UI
    const toggleBtn = document.getElementById('btn-forceful-toggle');
    const btnText = document.getElementById('forceful-btn-text');
    
    if (toggleBtn) {
      toggleBtn.classList.add('active');
    }
    if (btnText) {
      btnText.textContent = '⚡ Forceful Strike Active ⚡';
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Deactivate Forceful Strike
   */
  deactivateForcefulStrike() {
    if (!this.character.isForcefulStrikeActive) return;
    
    this.character.isForcefulStrikeActive = false;
    
    // Recalculate all buffs from baseline (will restore DM and CS properly)
    this.recalculateCombatBuffs();
    this.releaseBaselineIfClean();
    
    // Update UI
    const toggleBtn = document.getElementById('btn-forceful-toggle');
    const btnText = document.getElementById('forceful-btn-text');
    
    if (toggleBtn) {
      toggleBtn.classList.remove('active');
    }
    if (btnText) {
      btnText.textContent = 'Activate Forceful Strike';
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Restore Forceful Strike visual state after page load.
   * Values are already baked into saved data — just re-apply CSS/titles.
   */
  restoreForcefulStrikeState() {
    const toggleBtn = document.getElementById('btn-forceful-toggle');
    const btnText = document.getElementById('forceful-btn-text');
    
    if (toggleBtn) {
      toggleBtn.classList.add('active');
    }
    if (btnText) {
      btnText.textContent = '⚡ Forceful Strike Active ⚡';
    }
    
    // Re-apply visual indicators
    const combatField = document.getElementById('combat-skill-1-percent');
    const dmgCurrField = document.getElementById('damage-mod-current');
    const dmgOrigField = document.getElementById('damage-mod-original');
    
    if (combatField) {
      combatField.classList.add('forceful-penalized');
      const existing = combatField.title || '';
      combatField.title = existing
        ? existing + ' | Forceful Strike: -20%'
        : 'Forceful Strike: -20% (one grade harder)';
    }
    if (dmgCurrField) {
      dmgCurrField.classList.add('forceful-boosted');
      dmgCurrField.title = 'Forceful Strike: +2 steps';
    }
    if (dmgOrigField) dmgOrigField.classList.add('forceful-boosted');
    
    // WP Damage Mod visual indicators
    const wpDmgCurrField = document.getElementById('wp-damage-mod-current');
    const wpDmgOrigField = document.getElementById('wp-damage-mod-original');
    if (wpDmgCurrField && wpDmgCurrField.value.trim()) {
      wpDmgCurrField.classList.add('forceful-boosted');
      wpDmgCurrField.title = 'Forceful Strike: +2 steps';
    }
    if (wpDmgOrigField && wpDmgOrigField.value.trim()) {
      wpDmgOrigField.classList.add('forceful-boosted');
    }
    
    // Style all weapon damage fields
    const weaponDamageFields = document.querySelectorAll('.weapon-damage');
    weaponDamageFields.forEach(field => {
      field.classList.add('forceful-boosted');
      field.title = 'Increased damage modifier with Forceful Strike';
    });
    
    // Update combat quick reference
    this.updateCombatQuickRef();
  },
  
  /**
   * Check if character has Brute Strength ability and show/hide section
   */
  checkBruteStrengthVisibility() {
    const section = document.getElementById('brute-strength-section');
    if (!section) return;
    
    // Check if character has Brute Strength ability
    const hasBruteStrength = this.hasAbility('Brute Strength');
    
    if (hasBruteStrength) {
      section.style.display = '';
      this.initBruteStrength();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Initialize Brute Strength system
   */
  initBruteStrength() {
    this.setupBruteStrengthListeners();
    
    // Restore state if it was active
    if (this.character.isBruteStrengthActive) {
      this.restoreBruteStrengthState();
    }
  },
  
  /**
   * Setup Brute Strength button listeners
   */
  setupBruteStrengthListeners() {
    const toggleBtn = document.getElementById('btn-brute-toggle');
    
    if (toggleBtn && !toggleBtn.dataset.listenerAdded) {
      toggleBtn.addEventListener('click', () => {
        if (this.character.isBruteStrengthActive) {
          this.deactivateBruteStrength();
        } else {
          this.activateBruteStrength();
        }
      });
      toggleBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Activate Brute Strength (+20 to Brawn for one action)
   */
  activateBruteStrength() {
    if (this.character.isBruteStrengthActive) return;
    
    this.character.isBruteStrengthActive = true;
    
    // Store pre-activation Brawn value
    const brawnInput = document.getElementById('brawn-current');
    this.character.preBruteStrengthBrawn = brawnInput?.value || '0';
    
    // Apply Brute Strength effect (+20 to Brawn)
    this.applyBruteStrengthEffects();
    
    // Update UI
    const toggleBtn = document.getElementById('btn-brute-toggle');
    const btnText = document.getElementById('brute-btn-text');
    
    if (toggleBtn) {
      toggleBtn.classList.add('active');
    }
    if (btnText) {
      btnText.textContent = '💪 Brute Strength Active - Click to End';
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Apply Brute Strength effects (+20 to Brawn)
   */
  applyBruteStrengthEffects() {
    const brawnInput = document.getElementById('brawn-current');
    if (brawnInput) {
      const curr = parseInt(brawnInput.value, 10) || 0;
      brawnInput.value = curr + 20;
      brawnInput.classList.add('brute-boosted');
    }
    
    // Update summary page
    this.refreshSummaryWidgets();
  },
  
  /**
   * Deactivate Brute Strength and apply fatigue (unless Berserker)
   */
  deactivateBruteStrength() {
    if (!this.character.isBruteStrengthActive) return;
    
    this.character.isBruteStrengthActive = false;
    
    // Remove Brute Strength effects (restore original Brawn)
    this.removeBruteStrengthEffects();
    
    // Update UI
    const toggleBtn = document.getElementById('btn-brute-toggle');
    const btnText = document.getElementById('brute-btn-text');
    
    if (toggleBtn) {
      toggleBtn.classList.remove('active');
    }
    if (btnText) {
      btnText.textContent = 'Use Brute Strength';
    }
    
    // Check if class is Berserker - if not, apply fatigue
    const primaryClass = document.getElementById('class-primary')?.value?.trim().toLowerCase() || '';
    const secondaryClass = document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '';
    const tertiaryClass = document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || '';
    
    const isBerserker = primaryClass === 'berserker' || secondaryClass === 'berserker' || tertiaryClass === 'berserker';
    
    if (!isBerserker) {
      // Apply one level of fatigue
      this.applyBruteStrengthFatigue();
    } else {
      alert('Brute Strength ended. No fatigue applied (Berserker class).');
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Remove Brute Strength effects
   */
  removeBruteStrengthEffects() {
    const brawnInput = document.getElementById('brawn-current');
    if (brawnInput && this.character.preBruteStrengthBrawn !== undefined) {
      brawnInput.value = this.character.preBruteStrengthBrawn;
      brawnInput.classList.remove('brute-boosted');
    }
    
    // Update summary page
    this.refreshSummaryWidgets();
    
    this.character.preBruteStrengthBrawn = null;
  },
  
  /**
   * Apply fatigue from Brute Strength use
   */
  applyBruteStrengthFatigue() {
    const fatigueOrder = ['fresh', 'winded', 'tired', 'wearied', 'exhausted', 'debilitated', 'incapacitated', 'semiconscious', 'coma'];
    const currentState = this.character.fatigueState || 'fresh';
    const currentIndex = fatigueOrder.indexOf(currentState);
    
    if (currentIndex < fatigueOrder.length - 1) {
      const newState = fatigueOrder[currentIndex + 1];
      this.setFatigueState(newState, true);
      
      alert(`Brute Strength ended! Fatigue increased from ${this.formatFatigueState(currentState)} to ${this.formatFatigueState(newState)}.`);
    } else {
      alert('Brute Strength ended! Already at maximum fatigue.');
    }
  },
  
  /**
   * Restore Brute Strength visual state after page load
   */
  restoreBruteStrengthState() {
    const toggleBtn = document.getElementById('btn-brute-toggle');
    const btnText = document.getElementById('brute-btn-text');
    
    if (toggleBtn) {
      toggleBtn.classList.add('active');
    }
    if (btnText) {
      btnText.textContent = '💪 Brute Strength Active - Click to End';
    }
    
    // Re-apply visual indicator
    const brawnInput = document.getElementById('brawn-current');
    if (brawnInput) brawnInput.classList.add('brute-boosted');
  },

  // ============================================
  // JUST A SCRATCH ABILITY SYSTEM
  // ============================================
  
  /**
   * Check if character has Just a Scratch ability and show/hide section
   */
  checkJustAScratchVisibility() {
    const section = document.getElementById('just-a-scratch-section');
    if (!section) return;
    
    // Check if character has Just a Scratch ability
    const hasJustAScratch = this.hasAbility('Just a Scratch');
    
    if (hasJustAScratch) {
      section.style.display = '';
      this.initJustAScratch();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Initialize Just a Scratch system
   */
  initJustAScratch() {
    // Initialize uses if not set
    if (this.character.scratchUsesRemaining === undefined) {
      this.character.scratchUsesRemaining = 1;
    }
    
    this.setupJustAScratchListeners();
    this.updateJustAScratchDisplay();
  },
  
  /**
   * Setup Just a Scratch button listeners
   */
  setupJustAScratchListeners() {
    const useBtn = document.getElementById('btn-scratch-use');
    const resetBtn = document.getElementById('btn-reset-scratch-uses');
    
    if (useBtn && !useBtn.dataset.listenerAdded) {
      useBtn.addEventListener('click', () => {
        this.openJustAScratchModal();
      });
      useBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetBtn && !resetBtn.dataset.listenerAdded) {
      resetBtn.addEventListener('click', () => {
        this.resetJustAScratchUses();
      });
      resetBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Update Just a Scratch display
   */
  updateJustAScratchDisplay() {
    const usesEl = document.getElementById('scratch-uses-available');
    const useBtn = document.getElementById('btn-scratch-use');
    
    if (usesEl) {
      usesEl.textContent = this.character.scratchUsesRemaining || 0;
    }
    
    if (useBtn) {
      useBtn.disabled = (this.character.scratchUsesRemaining || 0) <= 0;
    }
  },
  
  /**
   * Reset Just a Scratch uses (called on long rest)
   */
  resetJustAScratchUses() {
    this.character.scratchUsesRemaining = 1;
    this.updateJustAScratchDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * Open Just a Scratch explanation modal
   */
  openJustAScratchModal() {
    if ((this.character.scratchUsesRemaining || 0) <= 0) {
      alert('No uses of Just a Scratch remaining today.');
      return;
    }
    
    // Get healing rate
    const healingRate = parseInt(document.getElementById('healing-rate-current')?.value, 10) || 
                        parseInt(document.getElementById('healing-rate-original')?.value, 10) || 1;
    
    let modal = document.getElementById('just-a-scratch-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'just-a-scratch-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    modal.innerHTML = `
      <div class="modal-content scratch-modal-content">
        <div class="modal-header">
          <h3>🩹 Just a Scratch</h3>
          <button class="modal-close" id="scratch-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <p class="scratch-description">
            Once per day, after taking a break to check your wounds, you may regain 
            Hit Points in one Hit Location equal to <strong>${healingRate}</strong> (your Healing Rate).
          </p>
          <p class="scratch-note">This ability does not affect Major Wounds.</p>
          <div class="scratch-action">
            <button type="button" class="btn btn-primary" id="btn-scratch-continue">Choose Hit Location</button>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" id="btn-scratch-cancel">Cancel</button>
        </div>
      </div>
    `;
    
    // Setup listeners
    document.getElementById('scratch-modal-close').addEventListener('click', () => this.closeJustAScratchModal());
    document.getElementById('btn-scratch-cancel').addEventListener('click', () => this.closeJustAScratchModal());
    document.getElementById('btn-scratch-continue').addEventListener('click', () => {
      this.closeJustAScratchModal();
      this.openJustAScratchLocationModal();
    });
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) this.closeJustAScratchModal();
    });
    
    modal.classList.remove('hidden');
  },
  
  /**
   * Close Just a Scratch explanation modal
   */
  closeJustAScratchModal() {
    const modal = document.getElementById('just-a-scratch-modal');
    if (modal) modal.classList.add('hidden');
  },
  
  /**
   * Open Just a Scratch location selection modal
   */
  openJustAScratchLocationModal() {
    // Get injured hit locations (current HP < max HP, but not Major Wounds)
    const injuredLocations = this.getInjuredLocations();
    
    if (injuredLocations.length === 0) {
      alert('No injured hit locations to heal (excluding Major Wounds).');
      return;
    }
    
    const healingRate = parseInt(document.getElementById('healing-rate-current')?.value, 10) || 
                        parseInt(document.getElementById('healing-rate-original')?.value, 10) || 1;
    
    let modal = document.getElementById('scratch-location-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'scratch-location-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    const locationsHtml = injuredLocations.map(loc => `
      <div class="scratch-location-option">
        <button type="button" class="btn btn-location" data-loc-index="${loc.index}">
          <span class="loc-name">${loc.name}</span>
          <span class="loc-hp">${loc.currentHP}/${loc.maxHP} HP</span>
          <span class="loc-heal">→ ${Math.min(loc.maxHP, loc.currentHP + healingRate)}/${loc.maxHP} HP</span>
        </button>
      </div>
    `).join('');
    
    modal.innerHTML = `
      <div class="modal-content scratch-location-modal-content">
        <div class="modal-header">
          <h3>🩹 Choose Hit Location to Heal</h3>
          <button class="modal-close" id="scratch-loc-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <p>Select a hit location to heal by <strong>${healingRate}</strong> HP:</p>
          <div class="scratch-locations-list">
            ${locationsHtml}
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" id="btn-scratch-loc-cancel">Cancel</button>
        </div>
      </div>
    `;
    
    // Setup listeners
    document.getElementById('scratch-loc-modal-close').addEventListener('click', () => this.closeJustAScratchLocationModal());
    document.getElementById('btn-scratch-loc-cancel').addEventListener('click', () => this.closeJustAScratchLocationModal());
    
    // Location buttons
    modal.querySelectorAll('.btn-location').forEach(btn => {
      btn.addEventListener('click', () => {
        const locIndex = parseInt(btn.dataset.locIndex, 10);
        this.applyJustAScratch(locIndex);
      });
    });
    
    modal.addEventListener('click', (e) => {
      if (e.target === modal) this.closeJustAScratchLocationModal();
    });
    
    modal.classList.remove('hidden');
  },
  
  /**
   * Close Just a Scratch location modal
   */
  closeJustAScratchLocationModal() {
    const modal = document.getElementById('scratch-location-modal');
    if (modal) modal.classList.add('hidden');
  },
  
  /**
   * Get list of injured hit locations (current < max, not Major Wounds)
   */
  getInjuredLocations() {
    const locations = [];
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return locations;
    
    const rows = tbody.querySelectorAll('tr');
    
    rows.forEach((row, index) => {
      const cells = row.querySelectorAll('td');
      const currentInput = row.querySelector('.hp-current');
      const maxInput = row.querySelector('.hp-max-input');
      
      if (cells.length >= 2 && currentInput && maxInput) {
        const name = cells[1].textContent.trim(); // Location name is in 2nd cell
        const currentHP = parseInt(currentInput.value, 10) || 0;
        const maxHP = parseInt(maxInput.value, 10) || 0;
        
        // Only include if injured (current < max) and not a Major Wound (current >= -maxHP)
        // Major Wound is when damage equals or exceeds the location's max HP
        if (currentHP < maxHP && currentHP > -maxHP) {
          locations.push({
            index: index,
            name: name,
            currentHP: currentHP,
            maxHP: maxHP
          });
        }
      }
    });
    
    return locations;
  },
  
  /**
   * Apply Just a Scratch healing to a specific hit location
   */
  applyJustAScratch(locIndex) {
    const healingRate = parseInt(document.getElementById('healing-rate-current')?.value, 10) || 
                        parseInt(document.getElementById('healing-rate-original')?.value, 10) || 1;
    
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) {
      alert('Error: Could not find hit locations.');
      return;
    }
    
    const rows = tbody.querySelectorAll('tr');
    const row = rows[locIndex];
    
    if (!row) {
      alert('Error: Could not find hit location.');
      return;
    }
    
    const cells = row.querySelectorAll('td');
    const currentInput = row.querySelector('.hp-current');
    const maxInput = row.querySelector('.hp-max-input');
    
    if (!currentInput || !maxInput) {
      alert('Error: Could not find HP fields.');
      return;
    }
    
    const locName = cells.length >= 2 ? cells[1].textContent.trim() : 'Location';
    const currentHP = parseInt(currentInput.value, 10) || 0;
    const maxHP = parseInt(maxInput.value, 10) || 0;
    const newHP = Math.min(maxHP, currentHP + healingRate);
    
    // Apply healing
    currentInput.value = newHP;
    currentInput.dispatchEvent(new Event('input', { bubbles: true }));
    currentInput.dispatchEvent(new Event('change', { bubbles: true }));
    
    // Deduct use
    this.character.scratchUsesRemaining = Math.max(0, (this.character.scratchUsesRemaining || 1) - 1);
    this.updateJustAScratchDisplay();
    
    // Close modal
    this.closeJustAScratchLocationModal();
    
    // Show confirmation
    alert(`Healed ${locName} by ${newHP - currentHP} HP (${currentHP} → ${newHP}).`);
    
    this.scheduleAutoSave();
  },

  // ============================================
  // MYSTIC HEALING ABILITY (MONK)
  // ============================================
  
  checkMysticHealingVisibility() {
    const section = document.getElementById('mystic-healing-section');
    if (!section) return;
    
    if (this.hasAbility('Mystic Healing')) {
      section.style.display = '';
      this.initMysticHealing();
    } else {
      section.style.display = 'none';
    }
  },
  
  initMysticHealing() {
    const healingRate = parseInt(document.getElementById('healing-rate-current')?.value, 10) || 
                        parseInt(document.getElementById('healing-rate-original')?.value, 10) || 1;
    const pool = healingRate * 2;
    
    // Initialize remaining pool if not set
    if (this.character.mysticHealingRemaining === undefined) {
      this.character.mysticHealingRemaining = pool;
    }
    
    // Update display
    const remainingEl = document.getElementById('mystic-healing-remaining');
    const poolEl = document.getElementById('mystic-healing-pool');
    if (remainingEl) remainingEl.textContent = this.character.mysticHealingRemaining;
    if (poolEl) poolEl.textContent = pool;
    
    // Setup listeners (only once)
    const btn = document.getElementById('btn-mystic-healing-use');
    const resetBtn = document.getElementById('btn-reset-mystic-healing');
    if (btn && !btn.dataset.listenerAttached) {
      btn.addEventListener('click', () => this.openMysticHealingModal());
      btn.dataset.listenerAttached = 'true';
    }
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.addEventListener('click', () => {
        this.character.mysticHealingRemaining = pool;
        this.initMysticHealing();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAttached = 'true';
    }
    
    // Disable button if no healing remaining
    if (btn) {
      btn.disabled = this.character.mysticHealingRemaining <= 0;
    }
  },
  
  openMysticHealingModal() {
    const remaining = this.character.mysticHealingRemaining || 0;
    if (remaining <= 0) {
      alert('No Mystic Healing points remaining today.');
      return;
    }
    
    const injuredLocations = this.getInjuredLocations();
    if (injuredLocations.length === 0) {
      alert('No injured hit locations to heal.');
      return;
    }
    
    let modal = document.getElementById('mystic-healing-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'mystic-healing-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    const locationsHtml = injuredLocations.map(loc => {
      const canHeal = Math.min(remaining, loc.maxHP - loc.currentHP);
      return `
        <div class="scratch-location-option" style="display: flex; align-items: center; gap: 0.5rem; margin: 0.3rem 0;">
          <span class="loc-name" style="flex: 1; font-size: 0.85rem;">${loc.name}</span>
          <span class="loc-hp" style="font-size: 0.8rem; color: #999;">${loc.currentHP}/${loc.maxHP} HP</span>
          <input type="number" class="mh-heal-input" data-loc-index="${loc.index}" data-max-hp="${loc.maxHP}" data-current-hp="${loc.currentHP}"
                 min="0" max="${canHeal}" value="0" style="width: 50px; text-align: center; font-size: 0.85rem;">
        </div>
      `;
    }).join('');
    
    modal.innerHTML = `
      <div class="modal-content scratch-location-modal-content">
        <div class="modal-header">
          <h3>🧘 Mystic Healing</h3>
          <button class="modal-close" id="mh-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <p style="font-size: 0.85rem;">Distribute up to <strong id="mh-pool-display">${remaining}</strong> HP across injured locations:</p>
          <p style="font-size: 0.75rem; color: #999;">Requires 15 min meditation + Successful Meditation roll. Cannot regrow limbs.</p>
          <div class="scratch-locations-list" style="margin: 0.5rem 0;">
            ${locationsHtml}
          </div>
          <div style="text-align: right; font-size: 0.85rem; margin-top: 0.5rem;">
            <span style="color: #999;">Total allocated:</span> <strong id="mh-total-allocated">0</strong> / ${remaining}
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" id="mh-cancel">Cancel</button>
          <button type="button" class="btn btn-primary" id="mh-accept" disabled>Accept</button>
        </div>
      </div>
    `;
    
    // Setup listeners
    document.getElementById('mh-modal-close').addEventListener('click', () => modal.classList.add('hidden'));
    document.getElementById('mh-cancel').addEventListener('click', () => modal.classList.add('hidden'));
    modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.add('hidden'); });
    
    // Input change handlers - update total
    const inputs = modal.querySelectorAll('.mh-heal-input');
    const totalEl = document.getElementById('mh-total-allocated');
    const acceptBtn = document.getElementById('mh-accept');
    
    const updateTotal = () => {
      let total = 0;
      inputs.forEach(inp => { total += parseInt(inp.value, 10) || 0; });
      totalEl.textContent = total;
      acceptBtn.disabled = total <= 0 || total > remaining;
      totalEl.style.color = total > remaining ? '#ff4444' : '#4fc3f7';
    };
    
    inputs.forEach(inp => inp.addEventListener('input', updateTotal));
    
    // Accept button
    acceptBtn.addEventListener('click', () => {
      let totalHealed = 0;
      const healActions = [];
      inputs.forEach(inp => {
        const amount = parseInt(inp.value, 10) || 0;
        if (amount > 0) {
          const locIndex = parseInt(inp.dataset.locIndex, 10);
          const maxHP = parseInt(inp.dataset.maxHp, 10);
          const currentHP = parseInt(inp.dataset.currentHp, 10);
          healActions.push({ locIndex, amount: Math.min(amount, maxHP - currentHP) });
          totalHealed += Math.min(amount, maxHP - currentHP);
        }
      });
      
      if (totalHealed > remaining) {
        alert('Cannot heal more than remaining pool.');
        return;
      }
      
      // Apply healing to each location
      const tbody = document.getElementById('hit-locations-body');
      const rows = tbody?.querySelectorAll('tr');
      const healed = [];
      
      healActions.forEach(action => {
        const row = rows?.[action.locIndex];
        if (!row) return;
        const currentInput = row.querySelector('.hp-current');
        const maxInput = row.querySelector('.hp-max-input');
        const cells = row.querySelectorAll('td');
        if (!currentInput) return;
        
        const oldHP = parseInt(currentInput.value, 10) || 0;
        const maxHP = parseInt(maxInput?.value, 10) || 0;
        const newHP = Math.min(maxHP, oldHP + action.amount);
        currentInput.value = newHP;
        currentInput.dispatchEvent(new Event('input', { bubbles: true }));
        
        const locName = cells[1]?.textContent?.trim() || 'Location';
        healed.push(`${locName}: ${oldHP}→${newHP}`);
      });
      
      // Deduct from pool
      this.character.mysticHealingRemaining = Math.max(0, remaining - totalHealed);
      this.initMysticHealing();
      this.scheduleAutoSave();
      
      modal.classList.add('hidden');
      alert(`Mystic Healing: ${healed.join(', ')} (${totalHealed} HP total)`);
    });
    
    modal.classList.remove('hidden');
  },

  // ============================================
  // PAIN CONTROL ABILITY (MONK)
  // ============================================
  
  checkPainControlVisibility() {
    const section = document.getElementById('pain-control-section');
    if (!section) return;
    
    if (this.hasAbility('Pain Control')) {
      section.style.display = '';
      this.initPainControl();
    } else {
      section.style.display = 'none';
    }
  },
  
  initPainControl() {
    const btn = document.getElementById('btn-pain-control-roll');
    if (btn && !btn.dataset.listenerAttached) {
      btn.addEventListener('click', () => this.rollPainControl());
      btn.dataset.listenerAttached = 'true';
    }
  },
  
  rollPainControl() {
    const roll = Math.floor(Math.random() * 100) + 1;
    const enduranceVal = parseInt(document.getElementById('endurance-current')?.value, 10) || 0;
    
    let resultHTML;
    if (roll === 100) {
      resultHTML = `
        <div class="modal-result-body">
          <div class="result-icon">🎲</div>
          <div class="result-title failure">FUMBLE!</div>
          <div class="result-text">Roll: <strong>${roll}</strong></div>
          <div class="result-detail">The only way to fail Pain Control.</div>
          <div class="result-meta">Endurance: ${enduranceVal}%</div>
        </div>`;
    } else {
      const crit = Math.max(1, Math.floor(enduranceVal / 20));
      const isCrit = roll <= crit;
      resultHTML = `
        <div class="modal-result-body">
          <div class="result-icon">🎲</div>
          <div class="result-title ${isCrit ? 'critical' : 'success'}">
            Automatic ${isCrit ? 'Critical Success' : 'Success'}!
          </div>
          <div class="result-text">Roll: <strong>${roll}</strong></div>
          <div class="result-detail">Pain Control treats all Endurance rolls vs injury as Automatic Successes.</div>
          <div class="result-meta">Endurance: ${enduranceVal}%</div>
        </div>`;
    }
    
    this.showResultModal('🎲 Pain Control — Endurance Roll', resultHTML);
  },
  
  /**
   * Generic result modal for ability rolls
   */
  showResultModal(title, bodyHTML) {
    let modal = document.getElementById('result-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'result-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    modal.innerHTML = `
      <div class="modal-content scratch-modal-content" style="max-width: 380px;">
        <div class="modal-header">
          <h3>${title}</h3>
          <button class="modal-close" id="result-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          ${bodyHTML}
        </div>
        <div class="modal-footer" style="text-align: center;">
          <button class="btn btn-primary" id="result-modal-ok">OK</button>
        </div>
      </div>
    `;
    
    modal.classList.remove('hidden');
    
    const closeModal = () => modal.classList.add('hidden');
    modal.querySelector('#result-modal-close').addEventListener('click', closeModal);
    modal.querySelector('#result-modal-ok').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
  },
  
  /**
   * Generic confirmation modal with Proceed/Cancel buttons
   */
  showConfirmModal(title, bodyHTML, onConfirm) {
    let modal = document.getElementById('confirm-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'confirm-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    modal.innerHTML = `
      <div class="modal-content scratch-modal-content" style="max-width: 400px;">
        <div class="modal-header">
          <h3>${title}</h3>
          <button class="modal-close" id="confirm-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          ${bodyHTML}
        </div>
        <div class="modal-footer" style="text-align: center; display: flex; gap: 0.5rem; justify-content: center;">
          <button class="btn btn-secondary" id="confirm-modal-cancel">Cancel</button>
          <button class="btn btn-primary" id="confirm-modal-proceed">Proceed</button>
        </div>
      </div>
    `;
    
    modal.classList.remove('hidden');
    
    const closeModal = () => modal.classList.add('hidden');
    modal.querySelector('#confirm-modal-close').addEventListener('click', closeModal);
    modal.querySelector('#confirm-modal-cancel').addEventListener('click', closeModal);
    modal.querySelector('#confirm-modal-proceed').addEventListener('click', () => {
      closeModal();
      if (onConfirm) onConfirm();
    });
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
  },

  // ============================================
  // SPEAK WITH ANIMALS ABILITY (MONK)
  // ============================================
  
  promptSpeakWithAnimals(inputField) {
    let modal = document.getElementById('speak-animals-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'speak-animals-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    modal.innerHTML = `
      <div class="modal-content scratch-modal-content">
        <div class="modal-header">
          <h3>🐾 Speak with Animals</h3>
          <button class="modal-close" id="swa-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <p style="font-size: 0.85rem;">Choose the animal species you can communicate with:</p>
          <input type="text" id="swa-animal-input" placeholder="e.g., Wolves, Eagles, Bears..." 
                 style="width: 100%; padding: 0.5rem; font-size: 0.9rem; margin-top: 0.5rem; border: 1px solid #555; background: #2a2a3a; color: #eee; border-radius: 4px;">
          <p style="font-size: 0.72rem; color: #999; margin-top: 0.3rem;">The chosen animal species (and any nearby) must answer your questions.</p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" id="swa-cancel">Cancel</button>
          <button type="button" class="btn btn-primary" id="swa-accept">Accept</button>
        </div>
      </div>
    `;
    
    document.getElementById('swa-modal-close').addEventListener('click', () => modal.classList.add('hidden'));
    document.getElementById('swa-cancel').addEventListener('click', () => {
      modal.classList.add('hidden');
      // Remove the ability if cancelled (user didn't pick an animal)
      if (inputField && inputField.value.toLowerCase().trim() === 'speak with animals') {
        inputField.value = '';
        this.syncClassAbilitiesToCharacter();
        this.scheduleAutoSave();
      }
    });
    modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.add('hidden'); });
    
    const animalInput = document.getElementById('swa-animal-input');
    document.getElementById('swa-accept').addEventListener('click', () => {
      const animal = animalInput.value.trim();
      if (!animal) {
        animalInput.style.borderColor = '#ff4444';
        return;
      }
      
      // Update the ability name to include the animal
      if (inputField) {
        inputField.value = `Speak with Animals (${animal})`;
        inputField.dataset.previousValue = inputField.value;
        this.updateAbilityTooltip(inputField);
        this.syncClassAbilitiesToCharacter();
        this.scheduleAutoSave();
      }
      
      modal.classList.add('hidden');
    });
    
    // Focus the input
    modal.classList.remove('hidden');
    setTimeout(() => animalInput.focus(), 100);
  },

  // ============================================
  // COMMANDING ABILITY
  // ============================================
  
  /**
   * Check if character has Commanding ability and show/hide section
   */
  checkCommandingVisibility() {
    const section = document.getElementById('commanding-section');
    if (!section) return;
    
    const hasCommanding = this.hasAbility('Commanding');
    
    if (hasCommanding) {
      section.style.display = '';
      this.initCommanding();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Initialize Commanding system
   */
  initCommanding() {
    this.updateCommandingDisplay();
    this.setupCommandingListeners();
    
    // Restore commanding state if active
    if (this.character.isCommanding) {
      this.restoreCommandingState();
    }
  },
  
  /**
   * Get maximum Commanding uses (1 per rank, based on rank of Paladin/Cavalier)
   */
  getMaxCommandingUses() {
    // Check all class slots for Paladin or Cavalier
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    
    let maxRank = 0;
    
    for (const slot of classSlots) {
      const className = document.getElementById(slot.class)?.value?.toLowerCase().trim() || '';
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      
      if ((className === 'paladin' || className === 'cavalier') && rank > maxRank) {
        maxRank = rank;
      }
    }
    
    // Return at least 1 use if character has Commanding ability
    return Math.max(maxRank, 1);
  },
  
  /**
   * Update Commanding display values
   */
  updateCommandingDisplay() {
    const maxUses = this.getMaxCommandingUses();
    
    // Initialize uses remaining if not set
    if (this.character.commandingUsesRemaining === undefined || this.character.commandingUsesRemaining === null) {
      this.character.commandingUsesRemaining = maxUses;
    }
    
    const usesAvail = document.getElementById('commanding-uses-available');
    const usesMax = document.getElementById('commanding-uses-max');
    
    if (usesAvail) usesAvail.textContent = this.character.commandingUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;
    
    // Update button states
    const insightBtn = document.getElementById('btn-commanding-insight');
    const influenceBtn = document.getElementById('btn-commanding-influence');
    const noUses = this.character.commandingUsesRemaining <= 0;
    const isActive = this.character.isCommanding;
    
    if (insightBtn) insightBtn.disabled = noUses || isActive;
    if (influenceBtn) influenceBtn.disabled = noUses || isActive;
  },
  
  /**
   * Setup Commanding event listeners
   */
  setupCommandingListeners() {
    const insightBtn = document.getElementById('btn-commanding-insight');
    const influenceBtn = document.getElementById('btn-commanding-influence');
    const endBtn = document.getElementById('btn-end-commanding');
    const resetBtn = document.getElementById('btn-reset-commanding-uses');
    
    if (insightBtn && !insightBtn.dataset.listenerAdded) {
      insightBtn.addEventListener('click', () => this.useCommanding('insight'));
      insightBtn.dataset.listenerAdded = 'true';
    }
    
    if (influenceBtn && !influenceBtn.dataset.listenerAdded) {
      influenceBtn.addEventListener('click', () => this.useCommanding('influence'));
      influenceBtn.dataset.listenerAdded = 'true';
    }
    
    if (endBtn && !endBtn.dataset.listenerAdded) {
      endBtn.addEventListener('click', () => this.endCommanding());
      endBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetBtn && !resetBtn.dataset.listenerAdded) {
      resetBtn.addEventListener('click', () => {
        this.character.commandingUsesRemaining = this.getMaxCommandingUses();
        this.updateCommandingDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Use Commanding ability on a skill
   */
  useCommanding(skill) {
    if (this.character.isCommanding || this.character.commandingUsesRemaining <= 0) return;
    
    const skillId = skill === 'insight' ? 'insight-current' : 'influence-current';
    const skillField = document.getElementById(skillId);
    
    if (!skillField) {
      alert(`Error: Could not find ${skill} skill field.`);
      return;
    }
    
    // Store pre-commanding value
    const currentValue = parseInt(skillField.value, 10) || 0;
    this.character.preCommandingValue = currentValue;
    this.character.commandingSkill = skill;
    this.character.isCommanding = true;
    this.character.commandingUsesRemaining--;
    
    // Apply +40% bonus
    const newValue = currentValue + 40;
    skillField.value = newValue;
    skillField.classList.add('commanding-boosted');
    skillField.title = '+40% from Commanding (2 Difficulty Grades easier)';
    
    // Update UI
    const buttonsRow = document.getElementById('commanding-buttons');
    const activeRow = document.getElementById('commanding-active');
    const activeSkillLabel = document.getElementById('commanding-active-skill');
    
    if (buttonsRow) buttonsRow.style.display = 'none';
    if (activeRow) activeRow.style.display = '';
    if (activeSkillLabel) activeSkillLabel.textContent = skill.charAt(0).toUpperCase() + skill.slice(1);
    
    this.updateCommandingDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * End Commanding effect and restore skill
   */
  endCommanding() {
    if (!this.character.isCommanding) return;
    
    const skill = this.character.commandingSkill;
    const skillId = skill === 'insight' ? 'insight-current' : 'influence-current';
    const skillField = document.getElementById(skillId);
    
    if (skillField) {
      // Restore original value
      skillField.value = this.character.preCommandingValue;
      skillField.classList.remove('commanding-boosted');
      skillField.title = '';
    }
    
    // Reset state
    this.character.isCommanding = false;
    this.character.commandingSkill = null;
    this.character.preCommandingValue = null;
    
    // Update UI
    const buttonsRow = document.getElementById('commanding-buttons');
    const activeRow = document.getElementById('commanding-active');
    
    if (buttonsRow) buttonsRow.style.display = '';
    if (activeRow) activeRow.style.display = 'none';
    
    this.updateCommandingDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * Restore Commanding state after page reload
   */
  restoreCommandingState() {
    const skill = this.character.commandingSkill;
    if (!skill) return;
    
    const skillId = skill === 'insight' ? 'insight-current' : 'influence-current';
    const skillField = document.getElementById(skillId);
    
    if (skillField) {
      // Reapply the +40% bonus display
      const boostedValue = (this.character.preCommandingValue || 0) + 40;
      skillField.value = boostedValue;
      skillField.classList.add('commanding-boosted');
      skillField.title = '+40% from Commanding (2 Difficulty Grades easier)';
    }
    
    // Update UI to show active state
    const buttonsRow = document.getElementById('commanding-buttons');
    const activeRow = document.getElementById('commanding-active');
    const activeSkillLabel = document.getElementById('commanding-active-skill');
    
    if (buttonsRow) buttonsRow.style.display = 'none';
    if (activeRow) activeRow.style.display = '';
    if (activeSkillLabel) activeSkillLabel.textContent = skill.charAt(0).toUpperCase() + skill.slice(1);
    
    this.updateCommandingDisplay();
  },

  // ============================================
  // HOLY STRIKE ABILITY (PALADIN)
  // +1d6 holy damage vs Evil, 1x/day per Rank
  // ============================================

  checkHolyStrikeVisibility() {
    const section = document.getElementById('holy-strike-section');
    if (!section) return;
    if (this.hasAbility('Holy Strike')) {
      section.style.display = '';
      this.initHolyStrike();
    } else {
      section.style.display = 'none';
    }
  },

  initHolyStrike() {
    this.updateHolyStrikeDisplay();
    this.setupHolyStrikeListeners();
    // Restore active state if saved
    if (this.character.holyStrikeActive) {
      this._applyHolyStrikeVisuals();
    }
  },

  getMaxHolyStrikeUses() {
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    let maxRank = 0;
    for (const slot of classSlots) {
      const className = (document.getElementById(slot.class)?.value || '').toLowerCase().trim();
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      if ((className === 'paladin' || className === 'cavalier') && rank > maxRank) {
        maxRank = rank;
      }
    }
    return Math.max(maxRank, 1);
  },

  updateHolyStrikeDisplay() {
    const maxUses = this.getMaxHolyStrikeUses();
    if (this.character.holyStrikeUsesRemaining === undefined || this.character.holyStrikeUsesRemaining === null) {
      this.character.holyStrikeUsesRemaining = maxUses;
    }
    const usesAvail = document.getElementById('holy-strike-uses-available');
    const usesMax = document.getElementById('holy-strike-uses-max');
    if (usesAvail) usesAvail.textContent = this.character.holyStrikeUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;
    const useBtn = document.getElementById('btn-holy-strike-use');
    if (useBtn) {
      useBtn.disabled = this.character.holyStrikeUsesRemaining <= 0 || this.character.holyStrikeActive;
      if (this.character.holyStrikeActive) {
        useBtn.textContent = '⚔️ Holy Strike ACTIVE';
        useBtn.classList.add('holy-strike-active-btn');
      } else {
        useBtn.textContent = '⚔️ Holy Strike (+1d6)';
        useBtn.classList.remove('holy-strike-active-btn');
      }
    }
  },

  setupHolyStrikeListeners() {
    const useBtn = document.getElementById('btn-holy-strike-use');
    const resetBtn = document.getElementById('btn-reset-holy-strike-uses');
    if (useBtn && !useBtn.dataset.listenerAttached) {
      useBtn.addEventListener('click', () => this.activateHolyStrike());
      useBtn.dataset.listenerAttached = 'true';
    }
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.addEventListener('click', () => {
        this.character.holyStrikeUsesRemaining = this.getMaxHolyStrikeUses();
        this.deactivateHolyStrike();
        this.updateHolyStrikeDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAttached = 'true';
    }
  },

  activateHolyStrike() {
    if (this.character.holyStrikeUsesRemaining <= 0 || this.character.holyStrikeActive) return;
    this.character.holyStrikeUsesRemaining--;
    this.character.holyStrikeActive = true;

    // Show animation overlay
    let overlay = document.getElementById('holy-strike-anim-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'holy-strike-anim-overlay';
      overlay.className = 'ability-anim-overlay';
      overlay.innerHTML = `
        <div class="ability-anim-content holy-strike-anim">
          <div class="holy-strike-icon">⚔️</div>
          <div class="holy-strike-title">Holy Strike</div>
          <div class="holy-strike-subtitle">Attack an Evil creature!</div>
        </div>
      `;
      document.body.appendChild(overlay);
    }
    overlay.style.display = 'flex';
    overlay.offsetHeight; // force reflow
    overlay.classList.add('active');

    setTimeout(() => {
      overlay.classList.remove('active');
      setTimeout(() => { overlay.style.display = 'none'; }, 300);
      this._applyHolyStrikeVisuals();
    }, 1500);

    this.updateHolyStrikeDisplay();
    this.scheduleAutoSave();
  },

  _applyHolyStrikeVisuals() {
    // Add "+1d6" badges to all melee weapon damage cells except Unarmed
    const meleeDamageCells = document.querySelectorAll('[id^="melee-"][id$="-damage"]');
    meleeDamageCells.forEach(input => {
      const row = input.closest('tr');
      if (!row) return;
      const nameInput = row.querySelector('.weapon-name');
      const nameVal = (nameInput?.value || '').toLowerCase().trim();
      if (nameVal === 'unarmed') return;
      if (!nameVal) return; // skip empty rows

      const cell = input.closest('.damage-cell');
      if (!cell) return;
      cell.classList.add('holy-strike-highlight');

      // Add badge if not present
      if (!cell.querySelector('.holy-strike-badge')) {
        const badge = document.createElement('span');
        badge.className = 'holy-strike-badge';
        badge.textContent = '+1d6';
        cell.appendChild(badge);
      }
    });
  },

  deactivateHolyStrike() {
    this.character.holyStrikeActive = false;
    // Remove all badges and highlights
    document.querySelectorAll('.holy-strike-badge').forEach(b => b.remove());
    document.querySelectorAll('.holy-strike-highlight').forEach(c => c.classList.remove('holy-strike-highlight'));
    this.updateHolyStrikeDisplay();
    this.scheduleAutoSave();
  },

  // ============================================
  // LAY ON HANDS ABILITY (PALADIN)
  // Heal Minor Wound or stabilize, 1x/day per Rank
  // ============================================

  checkLayOnHandsVisibility() {
    const section = document.getElementById('lay-on-hands-section');
    if (!section) return;
    if (this.hasAbility('Lay on Hands')) {
      section.style.display = '';
      this.initLayOnHands();
    } else {
      section.style.display = 'none';
    }
  },

  initLayOnHands() {
    this.updateLayOnHandsDisplay();
    this.setupLayOnHandsListeners();
  },

  getMaxLayOnHandsUses() {
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    let maxRank = 0;
    for (const slot of classSlots) {
      const className = (document.getElementById(slot.class)?.value || '').toLowerCase().trim();
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      if ((className === 'paladin' || className === 'cavalier') && rank > maxRank) {
        maxRank = rank;
      }
    }
    return Math.max(maxRank, 1);
  },

  updateLayOnHandsDisplay() {
    const maxUses = this.getMaxLayOnHandsUses();
    if (this.character.layOnHandsUsesRemaining === undefined || this.character.layOnHandsUsesRemaining === null) {
      this.character.layOnHandsUsesRemaining = maxUses;
    }
    const usesAvail = document.getElementById('lay-on-hands-uses-available');
    const usesMax = document.getElementById('lay-on-hands-uses-max');
    if (usesAvail) usesAvail.textContent = this.character.layOnHandsUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;
    const useBtn = document.getElementById('btn-lay-on-hands-use');
    if (useBtn) useBtn.disabled = this.character.layOnHandsUsesRemaining <= 0;
  },

  setupLayOnHandsListeners() {
    const useBtn = document.getElementById('btn-lay-on-hands-use');
    const resetBtn = document.getElementById('btn-reset-lay-on-hands-uses');
    if (useBtn && !useBtn.dataset.listenerAttached) {
      useBtn.addEventListener('click', () => this.useLayOnHands());
      useBtn.dataset.listenerAttached = 'true';
    }
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.addEventListener('click', () => {
        this.character.layOnHandsUsesRemaining = this.getMaxLayOnHandsUses();
        this.updateLayOnHandsDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAttached = 'true';
    }
  },

  useLayOnHands() {
    if (this.character.layOnHandsUsesRemaining <= 0) return;

    // Show healing animation first
    let overlay = document.getElementById('lay-on-hands-anim-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'lay-on-hands-anim-overlay';
      overlay.className = 'ability-anim-overlay';
      overlay.innerHTML = `
        <div class="ability-anim-content lay-on-hands-anim">
          <div class="lay-on-hands-icon">🙌</div>
          <div class="lay-on-hands-anim-title">Lay on Hands</div>
          <div class="lay-on-hands-particles">
            <span class="heal-particle">✦</span>
            <span class="heal-particle">✦</span>
            <span class="heal-particle">✦</span>
            <span class="heal-particle">✦</span>
            <span class="heal-particle">✦</span>
          </div>
        </div>
      `;
      document.body.appendChild(overlay);
    }
    overlay.style.display = 'flex';
    overlay.offsetHeight;
    overlay.classList.add('active');

    setTimeout(() => {
      overlay.classList.remove('active');
      setTimeout(() => { overlay.style.display = 'none'; }, 300);
      this._showLayOnHandsChoice();
    }, 1500);
  },

  _showLayOnHandsChoice() {
    const modalHTML = `
      <div class="modal-result-body">
        <div class="result-icon">🙌</div>
        <div class="result-title success">Lay on Hands</div>
        <div class="result-detail" style="text-align:center;margin-bottom:0.5rem;">
          <p>Are you healing yourself or another?</p>
        </div>
        <div style="display:flex;gap:0.5rem;justify-content:center;flex-wrap:wrap;">
          <button class="btn btn-lay-on-hands-choice" id="loh-self" style="padding:0.5rem 1rem;font-size:0.9rem;background:linear-gradient(135deg,#1a3a3a,#2a5050);color:white;border:1px solid #5fa8a8;border-radius:5px;cursor:pointer;">Myself</button>
          <button class="btn btn-lay-on-hands-choice" id="loh-other" style="padding:0.5rem 1rem;font-size:0.9rem;background:linear-gradient(135deg,#2a2a3a,#3a3a50);color:white;border:1px solid #8888aa;border-radius:5px;cursor:pointer;">Another</button>
          <button class="btn btn-lay-on-hands-choice" id="loh-cancel" style="padding:0.5rem 1rem;font-size:0.9rem;background:#333;color:#aaa;border:1px solid #666;border-radius:5px;cursor:pointer;">Cancel</button>
        </div>
      </div>`;
    
    this.showResultModal('🙌 Lay on Hands', modalHTML);

    // Attach choice handlers after modal renders
    setTimeout(() => {
      document.getElementById('loh-self')?.addEventListener('click', () => {
        this._closeResultModal();
        this._layOnHandsSelf();
      });
      document.getElementById('loh-other')?.addEventListener('click', () => {
        this._closeResultModal();
        this._layOnHandsOther();
      });
      document.getElementById('loh-cancel')?.addEventListener('click', () => {
        this._closeResultModal();
      });
    }, 50);
  },

  _layOnHandsSelf() {
    // Find hit locations with Minor Wounds
    const tbody = document.getElementById('hit-locations-body');
    if (!tbody) return;
    const rows = tbody.querySelectorAll('tr');
    const injuredLocations = [];

    rows.forEach((row, i) => {
      const statusSpan = document.getElementById(`loc-${i}-status`);
      const maxInput = document.getElementById(`loc-${i}-hp`);
      const currentInput = document.getElementById(`loc-${i}-current`);
      if (!statusSpan || !maxInput || !currentInput) return;

      const status = statusSpan.dataset.status;
      const locationName = statusSpan.dataset.location || `Location ${i}`;
      const maxHP = parseInt(maxInput.value, 10) || 0;
      const currentHP = parseInt(currentInput.value, 10);

      if (status === 'wound-minor') {
        injuredLocations.push({ index: i, name: locationName, maxHP, currentHP });
      }
    });

    if (injuredLocations.length === 0) {
      const noWoundsHTML = `
        <div class="modal-result-body">
          <div class="result-icon">🙌</div>
          <div class="result-title" style="color:#7dd4d4;">No Minor Wounds</div>
          <div class="result-detail">
            <p>You have no locations with Minor Wounds to heal.</p>
            <p style="font-size:0.8rem;color:#999;margin-top:0.5rem;">Lay on Hands restores all lost HP from a Minor Wound. For Serious or Major Wounds, it stabilizes only — no HP is restored.</p>
          </div>
        </div>`;
      this.showResultModal('🙌 Lay on Hands', noWoundsHTML);
      return;
    }

    // Consume use
    this.character.layOnHandsUsesRemaining--;
    this.updateLayOnHandsDisplay();
    this.scheduleAutoSave();

    // Build location picker
    let buttonsHTML = injuredLocations.map(loc => 
      `<button class="btn loh-location-btn" data-loc-index="${loc.index}" 
        style="padding:0.4rem 0.8rem;font-size:0.85rem;background:linear-gradient(135deg,#1a3a3a,#2a5050);color:white;border:1px solid #5fa8a8;border-radius:5px;cursor:pointer;margin:0.2rem;">
        ${loc.name} (${loc.currentHP}/${loc.maxHP} HP)
      </button>`
    ).join('');

    const pickerHTML = `
      <div class="modal-result-body">
        <div class="result-icon">🙌</div>
        <div class="result-title success">Choose Location to Heal</div>
        <div class="result-detail" style="text-align:center;margin-bottom:0.5rem;">
          <p>Select a location with a Minor Wound to restore all HP:</p>
        </div>
        <div style="display:flex;flex-wrap:wrap;justify-content:center;gap:0.25rem;">
          ${buttonsHTML}
        </div>
      </div>`;
    
    this.showResultModal('🙌 Lay on Hands — Choose Location', pickerHTML);

    setTimeout(() => {
      document.querySelectorAll('.loh-location-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const locIndex = parseInt(btn.dataset.locIndex, 10);
          this._healLocation(locIndex);
          this._closeResultModal();
        });
      });
    }, 50);
  },

  _healLocation(locationIndex) {
    const maxInput = document.getElementById(`loc-${locationIndex}-hp`);
    const currentInput = document.getElementById(`loc-${locationIndex}-current`);
    const statusSpan = document.getElementById(`loc-${locationIndex}-status`);
    if (!maxInput || !currentInput) return;

    const maxHP = maxInput.value;
    const prevHP = currentInput.value;
    currentInput.value = maxHP;
    this.updateWoundStatus(locationIndex);
    this.scheduleAutoSave();
    this.refreshSummaryWidgets();

    const locationName = statusSpan?.dataset.location || `Location ${locationIndex}`;
    const healedHTML = `
      <div class="modal-result-body">
        <div class="result-icon">✨</div>
        <div class="result-title success">Healed!</div>
        <div class="result-detail" style="text-align:center;">
          <p><strong>${locationName}</strong> restored from ${prevHP} to ${maxHP} HP.</p>
        </div>
        <div class="result-meta">${this.character.layOnHandsUsesRemaining} use(s) remaining today</div>
      </div>`;
    this.showResultModal('🙌 Lay on Hands — Healed!', healedHTML);
  },

  _layOnHandsOther() {
    // Consume use
    this.character.layOnHandsUsesRemaining--;
    this.updateLayOnHandsDisplay();
    this.scheduleAutoSave();

    const otherHTML = `
      <div class="modal-result-body">
        <div class="result-icon">🙌</div>
        <div class="result-title success">Lay on Hands — Another Creature</div>
        <div class="result-detail">
          <p>You may restore all lost Hit Points from a <strong>Minor Wound</strong> to a single location of another person.</p>
          <p style="margin-top:0.5rem;">For <strong>Serious or Major Wounds</strong>, no Hit Points are restored, but laying on hands will stabilize the injury, halting bleeding and preventing imminent death from neglect.</p>
        </div>
        <div class="result-meta">${this.character.layOnHandsUsesRemaining} use(s) remaining today</div>
      </div>`;
    this.showResultModal('🙌 Lay on Hands', otherHTML);
  },

  _closeResultModal() {
    const modal = document.getElementById('result-modal');
    if (modal) modal.classList.add('hidden');
  },

  // ============================================
  // DETECT EVIL ABILITY (PALADIN)
  // Concentrate 1 Round to sense Evil within 60ft
  // ============================================

  checkDetectEvilVisibility() {
    const section = document.getElementById('detect-evil-section');
    if (!section) return;
    if (this.hasAbility('Detect Evil')) {
      section.style.display = '';
      this.setupDetectEvilListeners();
    } else {
      section.style.display = 'none';
    }
  },

  setupDetectEvilListeners() {
    const btn = document.getElementById('btn-detect-evil-use');
    if (btn && !btn.dataset.listenerAttached) {
      btn.addEventListener('click', () => this.useDetectEvil());
      btn.dataset.listenerAttached = 'true';
    }
  },

  useDetectEvil() {
    // Show animation overlay
    let overlay = document.getElementById('detect-evil-anim-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'detect-evil-anim-overlay';
      overlay.className = 'ability-anim-overlay';
      overlay.innerHTML = `
        <div class="ability-anim-content detect-evil-anim">
          <div class="detect-evil-icon">👁️</div>
          <div class="detect-evil-rings">
            <div class="detect-ring ring-1"></div>
            <div class="detect-ring ring-2"></div>
            <div class="detect-ring ring-3"></div>
          </div>
          <div class="detect-evil-anim-title">Detecting Evil...</div>
        </div>
      `;
      document.body.appendChild(overlay);
    }
    overlay.style.display = 'flex';
    overlay.offsetHeight;
    overlay.classList.add('active');

    setTimeout(() => {
      overlay.classList.remove('active');
      setTimeout(() => { overlay.style.display = 'none'; }, 300);
      this._showDetectEvilResult();
    }, 2000);
  },

  _showDetectEvilResult() {
    const resultHTML = `
      <div class="modal-result-body">
        <div class="result-icon">👁️</div>
        <div class="result-title" style="color:#c080ff;">Detect Evil</div>
        <div class="result-detail">
          <p>You may detect <strong>Evil beings within 60 feet</strong> and in your field of vision.</p>
          <p style="margin-top:0.5rem;">This ability reveals <strong>supernatural Evil creatures</strong> such as demons and vampires, as well as <strong>mundane beings with Evil or vile intentions</strong>, as determined by the Games Master.</p>
        </div>
      </div>`;
    this.showResultModal('👁️ Detect Evil', resultHTML);
  },

  // ============================================
  // CURE DISEASE ABILITY (PALADIN)
  // 1/week per Rank, resets after 7 Long Rests
  // ============================================

  checkCureDiseaseVisibility() {
    const section = document.getElementById('cure-disease-section');
    if (!section) return;
    if (this.hasAbility('Cure Disease')) {
      section.style.display = '';
      this.initCureDisease();
    } else {
      section.style.display = 'none';
    }
  },

  initCureDisease() {
    if (this.character.cureDiseaseState === undefined) this.character.cureDiseaseState = 'ready'; // 'ready' or 'cooldown'
    if (this.character.cureDiseaseUsesRemaining === undefined || this.character.cureDiseaseUsesRemaining === null) {
      this.character.cureDiseaseUsesRemaining = this.getMaxCureDiseaseUses();
    }
    if (this.character.cureDiseaseRestCount === undefined) this.character.cureDiseaseRestCount = 0;
    this.updateCureDiseaseDisplay();
    this.setupCureDiseaseListeners();
  },

  getMaxCureDiseaseUses() {
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    let maxRank = 0;
    for (const slot of classSlots) {
      const className = (document.getElementById(slot.class)?.value || '').toLowerCase().trim();
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      if ((className === 'paladin' || className === 'cavalier') && rank > maxRank) {
        maxRank = rank;
      }
    }
    return Math.max(maxRank, 1);
  },

  updateCureDiseaseDisplay() {
    const maxUses = this.getMaxCureDiseaseUses();
    const usesAvail = document.getElementById('cure-disease-uses-available');
    const usesMax = document.getElementById('cure-disease-uses-max');
    const useBtn = document.getElementById('btn-cure-disease-use');
    const restTracker = document.getElementById('cure-disease-rest-tracker');
    const restCountEl = document.getElementById('cure-disease-rest-count');

    if (usesAvail) usesAvail.textContent = this.character.cureDiseaseUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;

    if (this.character.cureDiseaseState === 'cooldown') {
      if (useBtn) { useBtn.disabled = true; useBtn.textContent = '🩺 On Cooldown'; }
      if (restTracker) restTracker.style.display = '';
      if (restCountEl) restCountEl.textContent = this.character.cureDiseaseRestCount;
    } else {
      if (useBtn) {
        useBtn.disabled = this.character.cureDiseaseUsesRemaining <= 0;
        useBtn.textContent = '🩺 Cure Disease';
      }
      if (restTracker) restTracker.style.display = 'none';
    }
  },

  setupCureDiseaseListeners() {
    const useBtn = document.getElementById('btn-cure-disease-use');
    const resetBtn = document.getElementById('btn-reset-cure-disease-uses');
    const restBtn = document.getElementById('btn-cure-disease-rest');

    if (useBtn && !useBtn.dataset.listenerAttached) {
      useBtn.addEventListener('click', () => this.useCureDisease());
      useBtn.dataset.listenerAttached = 'true';
    }
    if (resetBtn && !resetBtn.dataset.listenerAttached) {
      resetBtn.addEventListener('click', () => {
        this.character.cureDiseaseUsesRemaining = this.getMaxCureDiseaseUses();
        this.character.cureDiseaseState = 'ready';
        this.character.cureDiseaseRestCount = 0;
        this.updateCureDiseaseDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAttached = 'true';
    }
    if (restBtn && !restBtn.dataset.listenerAttached) {
      restBtn.addEventListener('click', () => {
        this.character.cureDiseaseRestCount++;
        if (this.character.cureDiseaseRestCount >= 7) {
          this.character.cureDiseaseState = 'ready';
          this.character.cureDiseaseRestCount = 0;
          this.character.cureDiseaseUsesRemaining = this.getMaxCureDiseaseUses();
        }
        this.updateCureDiseaseDisplay();
        this.scheduleAutoSave();
      });
      restBtn.dataset.listenerAttached = 'true';
    }
  },

  useCureDisease() {
    if (this.character.cureDiseaseUsesRemaining <= 0 || this.character.cureDiseaseState === 'cooldown') return;
    this.character.cureDiseaseUsesRemaining--;

    // Show animation
    let overlay = document.getElementById('cure-disease-anim-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'cure-disease-anim-overlay';
      overlay.className = 'ability-anim-overlay';
      overlay.innerHTML = `
        <div class="ability-anim-content cure-disease-anim">
          <div class="cure-disease-icon">🩺</div>
          <div class="cure-disease-particles">
            <span class="cure-particle">✦</span>
            <span class="cure-particle">✦</span>
            <span class="cure-particle">✦</span>
            <span class="cure-particle">✧</span>
            <span class="cure-particle">✧</span>
          </div>
          <div class="cure-disease-anim-title">Curing Disease...</div>
        </div>
      `;
      document.body.appendChild(overlay);
    }
    overlay.style.display = 'flex';
    overlay.offsetHeight;
    overlay.classList.add('active');

    setTimeout(() => {
      overlay.classList.remove('active');
      setTimeout(() => { overlay.style.display = 'none'; }, 300);

      // If all uses spent, enter cooldown
      if (this.character.cureDiseaseUsesRemaining <= 0) {
        this.character.cureDiseaseState = 'cooldown';
        this.character.cureDiseaseRestCount = 0;
      }

      const resultHTML = `
        <div class="modal-result-body">
          <div class="result-icon">🩺</div>
          <div class="result-title success">Disease Cured!</div>
          <div class="result-detail">
            <p>You have removed one <strong>natural disease</strong> from the afflicted individual.</p>
            <p style="margin-top:0.5rem;font-size:0.85rem;color:#aaa;">This does not cure supernatural diseases such as lycanthropy or vampirism.</p>
          </div>
          <div class="result-meta">${this.character.cureDiseaseUsesRemaining} use(s) remaining this week</div>
        </div>`;
      this.showResultModal('🩺 Cure Disease', resultHTML);
      this.updateCureDiseaseDisplay();
      this.scheduleAutoSave();
    }, 1500);
  },

  // ============================================
  // DIVINE PROTECTION ABILITY (PALADIN)
  // +10% to Willpower, Endurance, Evade (toggle)
  // ============================================

  checkDivineProtectionVisibility() {
    const section = document.getElementById('divine-protection-section');
    if (!section) return;
    if (this.hasAbility('Divine Protection')) {
      section.style.display = '';
      this.initDivineProtection();
    } else {
      section.style.display = 'none';
    }
  },

  initDivineProtection() {
    if (this.character.divineProtectionActive === undefined) this.character.divineProtectionActive = false;
    this.setupDivineProtectionListeners();
    this.updateDivineProtectionDisplay();
    // If it was active, re-apply visuals
    if (this.character.divineProtectionActive) {
      this._applyDivineProtectionVisuals();
    }
  },

  setupDivineProtectionListeners() {
    const btn = document.getElementById('btn-divine-protection-toggle');
    if (btn && !btn.dataset.listenerAttached) {
      btn.addEventListener('click', () => this.toggleDivineProtection());
      btn.dataset.listenerAttached = 'true';
    }
  },

  updateDivineProtectionDisplay() {
    const btn = document.getElementById('btn-divine-protection-toggle');
    const textEl = document.getElementById('divine-prot-btn-text');
    if (this.character.divineProtectionActive) {
      if (textEl) textEl.textContent = 'Deactivate';
      if (btn) btn.classList.add('divine-protection-active-btn');
    } else {
      if (textEl) textEl.textContent = 'Activate';
      if (btn) btn.classList.remove('divine-protection-active-btn');
    }
  },

  toggleDivineProtection() {
    if (this.character.divineProtectionActive) {
      this.deactivateDivineProtection();
    } else {
      this.activateDivineProtection();
    }
  },

  activateDivineProtection() {
    this.character.divineProtectionActive = true;

    // Show animation
    let overlay = document.getElementById('divine-prot-anim-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'divine-prot-anim-overlay';
      overlay.className = 'ability-anim-overlay';
      overlay.innerHTML = `
        <div class="ability-anim-content divine-prot-anim">
          <div class="divine-prot-icon">🛡️</div>
          <div class="divine-prot-anim-title">Divine Protection</div>
          <div class="divine-prot-subtitle">+10% Willpower, Endurance & Evade</div>
        </div>
      `;
      document.body.appendChild(overlay);
    }
    overlay.style.display = 'flex';
    overlay.offsetHeight;
    overlay.classList.add('active');

    setTimeout(() => {
      overlay.classList.remove('active');
      setTimeout(() => { overlay.style.display = 'none'; }, 300);
    }, 1200);

    this._applyDivineProtectionVisuals();
    this._applyDivineProtectionBonuses();
    this.updateDivineProtectionDisplay();
    this.scheduleAutoSave();
  },

  deactivateDivineProtection() {
    this.character.divineProtectionActive = false;
    this._removeDivineProtectionBonuses();
    this._removeDivineProtectionVisuals();
    this.updateDivineProtectionDisplay();
    this.scheduleAutoSave();
  },

  _applyDivineProtectionBonuses() {
    // Store original values then add +10% to Willpower, Endurance, Evade
    const skills = [
      { id: 'willpower-current', storeKey: 'preDivProtWillpower' },
      { id: 'endurance-current', storeKey: 'preDivProtEndurance' },
      { id: 'evade-current', storeKey: 'preDivProtEvade' }
    ];
    for (const s of skills) {
      const el = document.getElementById(s.id);
      if (!el) continue;
      const current = parseInt(el.value, 10) || 0;
      if (this.character[s.storeKey] === undefined) {
        this.character[s.storeKey] = current;
      }
      el.value = current + 10;
      el.classList.add('divine-prot-boosted');
      el.title = '+10% from Divine Protection';
    }
  },

  _removeDivineProtectionBonuses() {
    const skills = [
      { id: 'willpower-current', storeKey: 'preDivProtWillpower' },
      { id: 'endurance-current', storeKey: 'preDivProtEndurance' },
      { id: 'evade-current', storeKey: 'preDivProtEvade' }
    ];
    for (const s of skills) {
      const el = document.getElementById(s.id);
      if (!el) continue;
      if (this.character[s.storeKey] !== undefined) {
        el.value = this.character[s.storeKey];
        delete this.character[s.storeKey];
      }
      el.classList.remove('divine-prot-boosted');
      el.title = '';
    }
  },

  _applyDivineProtectionVisuals() {
    const ids = ['willpower-current', 'endurance-current', 'evade-current'];
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) {
        el.classList.add('divine-prot-boosted');
        // Also highlight the parent skill row
        const row = el.closest('.skill-row');
        if (row) row.classList.add('divine-prot-row');
      }
    });
  },

  _removeDivineProtectionVisuals() {
    document.querySelectorAll('.divine-prot-boosted').forEach(el => {
      el.classList.remove('divine-prot-boosted');
      el.title = '';
    });
    document.querySelectorAll('.divine-prot-row').forEach(el => {
      el.classList.remove('divine-prot-row');
    });
  },

  // ============================================
  // CIRCLE OF POWER ABILITY (PALADIN)
  // Informational box showing Channel/10 suppression
  // ============================================

  checkCircleOfPowerVisibility() {
    const section = document.getElementById('circle-of-power-section');
    if (!section) return;
    if (this.hasAbility('Circle of Power') || this.hasAbility('Circle of Power (Holy Weapon Only)')) {
      section.style.display = '';
      this.updateCircleOfPowerDisplay();
      // Listen for Channel changes
      const channelEl = document.getElementById('channel-percent');
      if (channelEl && !channelEl.dataset.copListenerAttached) {
        channelEl.addEventListener('input', () => this.updateCircleOfPowerDisplay());
        channelEl.dataset.copListenerAttached = 'true';
      }
    } else {
      section.style.display = 'none';
    }
  },

  updateCircleOfPowerDisplay() {
    const channelEl = document.getElementById('channel-percent');
    const channelValue = parseInt(channelEl?.value, 10) || 0;
    const magnitude = Math.ceil(channelValue / 10);

    const magEl = document.getElementById('cop-magnitude-value');
    const chanEl = document.getElementById('cop-channel-value');
    if (magEl) magEl.textContent = magnitude;
    if (chanEl) chanEl.textContent = channelValue;
  },

  // ============================================
  // IMPROVED AIM (RANGER RANGED SPEC)
  // Button that adds +20 to Combat Skill temporarily
  // ============================================

  checkImprovedAimVisibility() {
    const section = document.getElementById('improved-aim-section');
    if (!section) return;
    const hasRangerRangedSpec = (this.character.weaponSpecializations || []).some(s => s.type === 'Ranger Ranged');
    if (hasRangerRangedSpec) {
      section.style.display = '';
      this._setupImprovedAimButton();
      // Restore active state if saved
      if (this.character.improvedAimActive) {
        this._applyImprovedAimVisuals();
      }
    } else {
      section.style.display = 'none';
    }
  },

  _setupImprovedAimButton() {
    const btn = document.getElementById('btn-improved-aim');
    if (!btn || btn.dataset.listenerAttached) return;
    btn.dataset.listenerAttached = 'true';
    btn.addEventListener('click', () => this.toggleImprovedAim());
  },

  toggleImprovedAim() {
    if (this.character.improvedAimActive) {
      this.deactivateImprovedAim();
    } else {
      this.activateImprovedAim();
    }
  },

  activateImprovedAim() {
    // Play animation
    const section = document.getElementById('improved-aim-section');
    if (section) {
      const animOverlay = document.createElement('div');
      animOverlay.className = 'ability-anim-overlay improved-aim-anim';
      animOverlay.innerHTML = `
        <div class="aim-reticle">🎯</div>
        <div class="aim-text">Aiming...</div>
      `;
      section.style.position = 'relative';
      section.appendChild(animOverlay);
      setTimeout(() => animOverlay.remove(), 1500);
    }

    // Apply +20 to combat skill
    const combatInput = document.getElementById('combat-skill-1-percent');
    if (combatInput) {
      const currentVal = parseInt(combatInput.value, 10) || 0;
      if (!this.character.preImprovedAimCombat) {
        this.character.preImprovedAimCombat = currentVal;
      }
      combatInput.value = currentVal + 20;
      combatInput.classList.add('improved-aim-boosted');
      combatInput.dispatchEvent(new Event('input', { bubbles: true }));
      
      // Also highlight the row
      const row = combatInput.closest('.combat-skill-row');
      if (row) row.classList.add('improved-aim-row');
    }

    this.character.improvedAimActive = true;

    // Update button
    const btn = document.getElementById('btn-improved-aim');
    if (btn) {
      btn.textContent = '🎯 Aim ACTIVE — Click to Deactivate';
      btn.classList.add('improved-aim-active-btn');
    }

    // Refresh combat summary widget so d100 button gets updated target
    this.refreshSummaryWidget('combat');

    // Show modal
    setTimeout(() => {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
      overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:10000;';
      const modal = document.createElement('div');
      modal.style.cssText = 'background:linear-gradient(135deg,#1a2a1a,#25352a);border:2px solid #4a8a4a;border-radius:12px;padding:1.5rem;max-width:380px;width:90%;text-align:center;';
      modal.innerHTML = `
        <h3 style="color:#7dcc7d;margin:0 0 0.75rem 0;">🎯 Improved Aim</h3>
        <p style="color:#ddd;font-size:0.95rem;line-height:1.5;">
          After taking <strong>1 Turn</strong> to steady your weapon, your next attack is 
          <strong style="color:#7dcc7d;">1 Difficulty Grade easier</strong>.
        </p>
        <p style="color:#999;font-size:0.8rem;margin-top:0.75rem;">
          Combat Skill boosted by <strong>+20%</strong>. The bonus will deactivate when you roll Combat Skill or click the button again.
        </p>
        <button type="button" style="margin-top:1rem;background:#3a6a3a;color:#aaffaa;border:1px solid #4a8a4a;padding:0.4rem 1.5rem;border-radius:5px;cursor:pointer;font-size:0.85rem;">OK</button>
      `;
      modal.querySelector('button').addEventListener('click', () => document.body.removeChild(overlay));
      overlay.addEventListener('click', (e) => { if (e.target === overlay) document.body.removeChild(overlay); });
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    }, 500);

    this.scheduleAutoSave();
  },

  deactivateImprovedAim() {
    // Restore combat skill
    const combatInput = document.getElementById('combat-skill-1-percent');
    if (combatInput && this.character.preImprovedAimCombat !== undefined) {
      combatInput.value = this.character.preImprovedAimCombat;
      combatInput.classList.remove('improved-aim-boosted');
      combatInput.dispatchEvent(new Event('input', { bubbles: true }));
      
      const row = combatInput.closest('.combat-skill-row');
      if (row) row.classList.remove('improved-aim-row');
    }

    delete this.character.preImprovedAimCombat;
    this.character.improvedAimActive = false;

    // Update button
    const btn = document.getElementById('btn-improved-aim');
    if (btn) {
      btn.textContent = '🎯 Improved Aim';
      btn.classList.remove('improved-aim-active-btn');
    }

    // Refresh combat summary widget so d100 button gets restored target
    this.refreshSummaryWidget('combat');

    this.scheduleAutoSave();
  },

  _applyImprovedAimVisuals() {
    const combatInput = document.getElementById('combat-skill-1-percent');
    if (combatInput) {
      combatInput.classList.add('improved-aim-boosted');
      const row = combatInput.closest('.combat-skill-row');
      if (row) row.classList.add('improved-aim-row');
    }
    const btn = document.getElementById('btn-improved-aim');
    if (btn) {
      btn.textContent = '🎯 Aim ACTIVE — Click to Deactivate';
      btn.classList.add('improved-aim-active-btn');
    }
  },

  // ============================================
  // SPECIES ENEMY ABILITY (RANGER)
  // Button that activates +10% all skills, +1 DM step
  // ============================================

  /**
   * Prompt user to enter species enemy name
   */
  promptSpeciesEnemy(inputField) {
    let modal = document.getElementById('species-enemy-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'species-enemy-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }

    modal.innerHTML = `
      <div class="modal-content scratch-modal-content">
        <div class="modal-header">
          <h3>🎯 Species Enemy</h3>
          <button class="modal-close" id="se-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <p style="font-size: 0.85rem;">Enter the species you have dedicated yourself to fighting:</p>
          <input type="text" id="se-species-input" placeholder="e.g., Goblins, Orcs, Undead..." 
                 style="width: 100%; padding: 0.5rem; font-size: 0.9rem; margin-top: 0.5rem; border: 1px solid #555; background: #2a2a3a; color: #eee; border-radius: 4px; box-sizing: border-box;">
          <p style="font-size: 0.72rem; color: #999; margin-top: 0.5rem;">
            Common species enemies include bugbears, ettins, giants, gnolls, goblins, hobgoblins, kobolds, ogres, orcs, trolls, and undead.
          </p>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" id="se-cancel">Cancel</button>
          <button type="button" class="btn btn-primary" id="se-accept">Accept</button>
        </div>
      </div>
    `;

    document.getElementById('se-modal-close').addEventListener('click', () => modal.classList.add('hidden'));
    document.getElementById('se-cancel').addEventListener('click', () => {
      modal.classList.add('hidden');
      // Remove if they didn't pick a species
      if (inputField) {
        const val = inputField.value.toLowerCase().trim();
        if (val.match(/^species enem(y|ies)\s*(i{1,3}|iv|v|\d)?$/) && !val.includes('(')) {
          inputField.value = '';
          this.syncClassAbilitiesToCharacter();
          this.scheduleAutoSave();
        }
      }
    });
    modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.add('hidden'); });

    const speciesInput = document.getElementById('se-species-input');
    document.getElementById('se-accept').addEventListener('click', () => {
      const species = speciesInput.value.trim();
      if (!species) {
        speciesInput.style.borderColor = '#ff4444';
        return;
      }

      if (inputField) {
        // Get the current ability tier from the value
        const currentVal = inputField.value.trim();
        // Build display name with species in parentheses
        inputField.value = `${currentVal} (${species})`;
        inputField.dataset.previousValue = inputField.value;
        this.updateAbilityTooltip(inputField);
        this.syncClassAbilitiesToCharacter();
        // Reformat all species enemy display names (drop numerals, singular/plural)
        this.updateSpeciesEnemyDisplayNames();
        this.checkSpeciesEnemyVisibility();
        this.scheduleAutoSave();
      }

      modal.classList.add('hidden');
    });

    modal.classList.remove('hidden');
    setTimeout(() => speciesInput.focus(), 100);
  },

  /**
   * Check if character has any Species Enemy ability and show/hide button section
   */
  checkSpeciesEnemyVisibility() {
    const section = document.getElementById('species-enemy-section');
    if (!section) return;

    const enemies = this._getSpeciesEnemies();
    if (enemies.length > 0) {
      section.style.display = '';
      // Reformat ability input display names (drop numerals, singular/plural)
      this.updateSpeciesEnemyDisplayNames();
      // Update header: singular or plural with all names
      const header = document.getElementById('species-enemy-header');
      if (header) {
        const label = enemies.length === 1 ? 'Species Enemy' : 'Species Enemies';
        header.textContent = `🎯 ${label}`;
      }
      // Update enemy list display
      const listEl = document.getElementById('species-enemy-list');
      if (listEl) {
        listEl.innerHTML = enemies.map(e =>
          `<span class="se-enemy-tag">${e}</span>`
        ).join('');
      }
      this._setupSpeciesEnemyButton();
      // Restore active state
      if (this.character.speciesEnemyActive) {
        this._applySpeciesEnemyVisuals();
      }
    } else {
      section.style.display = 'none';
    }
  },

  /**
   * Reformat all Species Enemy ability inputs:
   * - Drop roman numerals (I, II, III, IV, V) and digit suffixes
   * - Use "Species Enemy" (singular) when only one, "Species Enemies" (plural) when multiple
   */
  updateSpeciesEnemyDisplayNames() {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;

    // Collect all species enemy inputs and their extracted species names
    const seInputs = [];
    for (const input of container.querySelectorAll('.class-ability-input')) {
      const val = input.value.trim();
      const match = val.match(/^Species Enem(?:y|ies)\s*(?:I{1,3}|IV|V|\d)?\s*\(([^)]+)\)/i);
      if (match) {
        seInputs.push({ input, species: match[1].trim() });
      }
    }

    if (seInputs.length === 0) return;

    const label = seInputs.length === 1 ? 'Species Enemy' : 'Species Enemies';

    for (const { input, species } of seInputs) {
      const newVal = `${label} (${species})`;
      if (input.value !== newVal) {
        input.value = newVal;
        input.dataset.previousValue = newVal;
        this.updateAbilityTooltip(input);
      }
    }
  },

  /**
   * Parse species enemies from class abilities
   * Matches both formats: "Species Enemy I (Undead)" and "Species Enemy (Undead)" / "Species Enemies (Undead)"
   */
  _getSpeciesEnemies() {
    const enemies = [];
    const container = document.getElementById('class-abilities-list');
    if (!container) return enemies;
    for (const input of container.querySelectorAll('.class-ability-input')) {
      const val = input.value.trim();
      const match = val.match(/^Species Enem(?:y|ies)\s*(?:I{1,3}|IV|V|\d)?\s*\(([^)]+)\)/i);
      if (match) enemies.push(match[1].trim());
    }
    return enemies;
  },

  _setupSpeciesEnemyButton() {
    const btn = document.getElementById('btn-species-enemy');
    if (!btn || btn.dataset.listenerAttached) return;
    btn.dataset.listenerAttached = 'true';
    btn.addEventListener('click', () => this.toggleSpeciesEnemy());
  },

  toggleSpeciesEnemy() {
    if (this.character.speciesEnemyActive) {
      this.deactivateSpeciesEnemy();
    } else {
      this.activateSpeciesEnemy();
    }
  },

  /**
   * Damage modifier ranking for step increases
   */
  _DM_RANKING: [
    '-1d8', '-1d6', '-1d4', '-1d2', '+0',
    '+1d2', '+1d4', '+1d6', '+1d8', '+1d10', '+1d12',
    '+2d6', '+1d8+1d6', '+2d8', '+1d10+1d8', '+2d10',
    '+2d10+1d2', '+2d10+1d4', '+2d10+1d6', '+2d10+1d8', '+2d10+1d10', '+2d10+1d12', '+3d10'
  ],

  _stepDamageModifier(currentMod, steps) {
    const idx = this._DM_RANKING.indexOf(currentMod);
    if (idx === -1) return currentMod; // unknown, don't change
    const newIdx = Math.max(0, Math.min(this._DM_RANKING.length - 1, idx + steps));
    return this._DM_RANKING[newIdx];
  },

  activateSpeciesEnemy() {
    // Animation
    const section = document.getElementById('species-enemy-section');
    if (section) {
      const animOverlay = document.createElement('div');
      animOverlay.className = 'ability-anim-overlay species-enemy-anim';
      animOverlay.innerHTML = `
        <div class="se-icon">🎯</div>
        <div class="se-text">Species Enemy!</div>
      `;
      section.style.position = 'relative';
      section.appendChild(animOverlay);
      setTimeout(() => animOverlay.remove(), 1500);
    }

    // Store original values and apply +10 to all skill fields
    this.character.preSpeciesEnemySkills = {};

    // Standard skills (class .skill-input inside .standard-skills)
    document.querySelectorAll('.standard-skills .skill-input').forEach(input => {
      if (!input.id) return;
      const val = parseInt(input.value, 10);
      if (isNaN(val) || val === 0) return;
      this.character.preSpeciesEnemySkills[input.id] = val;
      input.value = val + 10;
      input.classList.add('se-boosted');
    });

    // Professional skills (.prof-skill-current inside #professional-skills-container)
    document.querySelectorAll('#professional-skills-container .prof-skill-current').forEach(input => {
      if (!input.id) return;
      const val = parseInt(input.value, 10);
      if (isNaN(val) || val === 0) return;
      this.character.preSpeciesEnemySkills[input.id] = val;
      input.value = val + 10;
      input.classList.add('se-boosted');
    });

    // Combat skill
    const combatInput = document.getElementById('combat-skill-1-percent');
    if (combatInput) {
      const val = parseInt(combatInput.value, 10);
      if (!isNaN(val) && val > 0) {
        this.character.preSpeciesEnemySkills['combat-skill-1-percent'] = val;
        combatInput.value = val + 10;
        combatInput.classList.add('se-boosted');
      }
    }

    // Unarmed
    const unarmedInput = document.getElementById('unarmed-percent');
    if (unarmedInput) {
      const val = parseInt(unarmedInput.value, 10);
      if (!isNaN(val) && val > 0) {
        this.character.preSpeciesEnemySkills['unarmed-percent'] = val;
        unarmedInput.value = val + 10;
        unarmedInput.classList.add('se-boosted');
      }
    }

    // Magic skills
    ['channel-percent', 'piety-percent', 'arcane-casting-percent', 'arcane-knowledge-percent',
     'musicianship-percent', 'arcane-sorcery-percent', 'sorcerous-wisdom-percent'].forEach(id => {
      const input = document.getElementById(id);
      if (input) {
        const val = parseInt(input.value, 10);
        if (!isNaN(val) && val > 0) {
          this.character.preSpeciesEnemySkills[id] = val;
          input.value = val + 10;
          input.classList.add('se-boosted');
        }
      }
    });

    // +1 step to Damage Modifier
    const dmField = document.getElementById('damage-mod-current');
    if (dmField) {
      const currentDM = dmField.value.trim();
      this.character.preSpeciesEnemyDM = currentDM;
      dmField.value = this._stepDamageModifier(currentDM, 1);
      dmField.classList.add('se-boosted');
    }

    // +1 step to Weapon Precision Damage Modifier if present
    const wpDmField = document.getElementById('wp-damage-mod-current');
    if (wpDmField && wpDmField.value.trim()) {
      this.character.preSpeciesEnemyWPDM = wpDmField.value.trim();
      wpDmField.value = this._stepDamageModifier(wpDmField.value.trim(), 1);
      wpDmField.classList.add('se-boosted');
    }

    // Update weapon damage displays on combat page
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }

    // Green highlight on body
    document.body.classList.add('species-enemy-active-mode');

    this.character.speciesEnemyActive = true;
    this.character.speciesEnemyCombatRolled = false;

    // Update button
    const btn = document.getElementById('btn-species-enemy');
    if (btn) {
      btn.textContent = '🎯 Species Enemy ACTIVE — Click to Deactivate';
      btn.classList.add('se-active-btn');
    }

    // Refresh combat summary
    this.refreshSummaryWidget('combat');

    // Show modal
    setTimeout(() => {
      const overlay = document.createElement('div');
      overlay.className = 'modal-overlay';
      overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:10000;';
      const modal = document.createElement('div');
      modal.style.cssText = 'background:linear-gradient(135deg,#1a2a1a,#2a3a1a);border:2px solid #5a8a3a;border-radius:12px;padding:1.5rem;max-width:420px;width:90%;text-align:left;';
      modal.innerHTML = `
        <h3 style="color:#7dcc7d;margin:0 0 0.75rem 0;text-align:center;">🎯 Species Enemy Activated</h3>
        <p style="color:#ddd;font-size:0.9rem;line-height:1.5;">
          You're facing a <strong style="color:#7dcc7d;">Species Enemy</strong> and all your skill rolls are increased by <strong>+10%</strong> for the next roll. This could be for:
        </p>
        <ul style="color:#ccc;font-size:0.85rem;line-height:1.6;margin:0.5rem 0;">
          <li><strong>Combat Skill</strong> for both attacking and defending</li>
          <li><strong>Track</strong> when following their trail</li>
          <li><strong>Perception</strong> when spotting an ambush</li>
          <li><strong>Lore</strong> when identifying specific information</li>
        </ul>
        <p style="color:#ddd;font-size:0.9rem;margin-top:0.5rem;">The skill used is your choice. <strong>Damage Modifier also increased by one step.</strong></p>
        <p style="color:#999;font-size:0.78rem;margin-top:0.75rem;">
          Bonuses deactivate after your next skill roll. If you roll Combat Skill, bonuses remain active until you also roll damage.
        </p>
        <div style="text-align:center;margin-top:1rem;">
          <button type="button" style="background:#3a6a3a;color:#aaffaa;border:1px solid #4a8a4a;padding:0.4rem 1.5rem;border-radius:5px;cursor:pointer;font-size:0.85rem;">OK</button>
        </div>
      `;
      modal.querySelector('button').addEventListener('click', () => document.body.removeChild(overlay));
      overlay.addEventListener('click', (e) => { if (e.target === overlay) document.body.removeChild(overlay); });
      overlay.appendChild(modal);
      document.body.appendChild(overlay);
    }, 500);

    this.scheduleAutoSave();
  },

  deactivateSpeciesEnemy() {
    // Restore all skill values
    const saved = this.character.preSpeciesEnemySkills || {};
    for (const [id, val] of Object.entries(saved)) {
      const input = document.getElementById(id);
      if (input) {
        input.value = val;
        input.classList.remove('se-boosted');
      }
    }

    // Restore damage modifier
    const dmField = document.getElementById('damage-mod-current');
    if (dmField && this.character.preSpeciesEnemyDM !== undefined) {
      dmField.value = this.character.preSpeciesEnemyDM;
      dmField.classList.remove('se-boosted');
    }

    // Restore WP damage modifier
    const wpDmField = document.getElementById('wp-damage-mod-current');
    if (wpDmField && this.character.preSpeciesEnemyWPDM !== undefined) {
      wpDmField.value = this.character.preSpeciesEnemyWPDM;
      wpDmField.classList.remove('se-boosted');
    }

    // Update weapon damage displays on combat page
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }

    // Remove green mode
    document.body.classList.remove('species-enemy-active-mode');

    delete this.character.preSpeciesEnemySkills;
    delete this.character.preSpeciesEnemyDM;
    delete this.character.preSpeciesEnemyWPDM;
    this.character.speciesEnemyActive = false;
    this.character.speciesEnemyCombatRolled = false;

    // Update button
    const btn = document.getElementById('btn-species-enemy');
    if (btn) {
      btn.textContent = '🎯 Activate Species Enemy';
      btn.classList.remove('se-active-btn');
    }

    // Refresh combat summary
    this.refreshSummaryWidget('combat');

    this.scheduleAutoSave();
    
    // Ensure DM current matches original now that Species Enemy is over
    this.resetDamageModToOriginalIfClean();
  },

  _applySpeciesEnemyVisuals() {
    // Re-add green highlights to boosted fields
    const saved = this.character.preSpeciesEnemySkills || {};
    for (const id of Object.keys(saved)) {
      const input = document.getElementById(id);
      if (input) input.classList.add('se-boosted');
    }
    const dmField = document.getElementById('damage-mod-current');
    if (dmField && this.character.preSpeciesEnemyDM !== undefined) {
      dmField.classList.add('se-boosted');
    }
    const wpDmField = document.getElementById('wp-damage-mod-current');
    if (wpDmField && this.character.preSpeciesEnemyWPDM !== undefined) {
      wpDmField.classList.add('se-boosted');
    }
    document.body.classList.add('species-enemy-active-mode');
    const btn = document.getElementById('btn-species-enemy');
    if (btn) {
      btn.textContent = '🎯 Species Enemy ACTIVE — Click to Deactivate';
      btn.classList.add('se-active-btn');
    }
  },

  // ============================================
  // MENTAL STRENGTH ABILITY
  // ============================================
  
  /**
   * Check if character has Mental Strength ability and show/hide section
   */
  checkMentalStrengthVisibility() {
    const section = document.getElementById('mental-strength-section');
    if (!section) return;
    
    const hasMentalStrength = this.hasAbility('Mental Strength I') || 
                              this.hasAbility('Mental Strength 1') ||
                              this.hasAbility('Mental Strength II') ||
                              this.hasAbility('Mental Strength 2') ||
                              this.hasAbility('Mental Strength III') ||
                              this.hasAbility('Mental Strength 3') ||
                              this.hasAbility('Mental Strength IV') ||
                              this.hasAbility('Mental Strength 4') ||
                              this.hasAbility('Mental Strength V') ||
                              this.hasAbility('Mental Strength 5');
    
    if (hasMentalStrength) {
      section.style.display = '';
      this.initMentalStrength();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Initialize Mental Strength system
   */
  initMentalStrength() {
    this.updateMentalStrengthDisplay();
    this.setupMentalStrengthListeners();
    
    // Restore mental strength state if active
    if (this.character.isMentalStrengthActive) {
      this.restoreMentalStrengthState();
    }
  },
  
  /**
   * Get Mental Strength level (1-5) based on highest version character has
   */
  getMentalStrengthLevel() {
    // Check from highest to lowest
    if (this.hasAbility('Mental Strength V') || this.hasAbility('Mental Strength 5')) return 5;
    if (this.hasAbility('Mental Strength IV') || this.hasAbility('Mental Strength 4')) return 4;
    if (this.hasAbility('Mental Strength III') || this.hasAbility('Mental Strength 3')) return 3;
    if (this.hasAbility('Mental Strength II') || this.hasAbility('Mental Strength 2')) return 2;
    if (this.hasAbility('Mental Strength I') || this.hasAbility('Mental Strength 1')) return 1;
    return 0;
  },
  
  /**
   * Get maximum Mental Strength uses (equal to level)
   */
  getMaxMentalStrengthUses() {
    return this.getMentalStrengthLevel();
  },
  
  /**
   * Update Mental Strength display values
   */
  updateMentalStrengthDisplay() {
    const maxUses = this.getMaxMentalStrengthUses();
    
    // Initialize uses remaining if not set
    if (this.character.mentalStrengthUsesRemaining === undefined || this.character.mentalStrengthUsesRemaining === null) {
      this.character.mentalStrengthUsesRemaining = maxUses;
    }
    
    const usesAvail = document.getElementById('mental-strength-uses-available');
    const usesMax = document.getElementById('mental-strength-uses-max');
    
    if (usesAvail) usesAvail.textContent = this.character.mentalStrengthUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;
    
    // Update button state
    const useBtn = document.getElementById('btn-mental-strength-use');
    const noUses = this.character.mentalStrengthUsesRemaining <= 0;
    const isActive = this.character.isMentalStrengthActive;
    
    if (useBtn) useBtn.disabled = noUses || isActive;
  },
  
  /**
   * Setup Mental Strength event listeners
   */
  setupMentalStrengthListeners() {
    const useBtn = document.getElementById('btn-mental-strength-use');
    const endBtn = document.getElementById('btn-end-mental-strength');
    const resetBtn = document.getElementById('btn-reset-mental-strength-uses');
    
    if (useBtn && !useBtn.dataset.listenerAdded) {
      useBtn.addEventListener('click', () => this.useMentalStrength());
      useBtn.dataset.listenerAdded = 'true';
    }
    
    if (endBtn && !endBtn.dataset.listenerAdded) {
      endBtn.addEventListener('click', () => this.endMentalStrength());
      endBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetBtn && !resetBtn.dataset.listenerAdded) {
      resetBtn.addEventListener('click', () => {
        this.character.mentalStrengthUsesRemaining = this.getMaxMentalStrengthUses();
        this.updateMentalStrengthDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Use Mental Strength ability
   */
  useMentalStrength() {
    if (this.character.isMentalStrengthActive || this.character.mentalStrengthUsesRemaining <= 0) return;
    
    const willpowerField = document.getElementById('willpower-current');
    
    if (!willpowerField) {
      alert('Error: Could not find Willpower skill field.');
      return;
    }
    
    // Store pre-mental strength value
    const currentValue = parseInt(willpowerField.value, 10) || 0;
    this.character.preMentalStrengthValue = currentValue;
    this.character.isMentalStrengthActive = true;
    this.character.mentalStrengthUsesRemaining--;
    
    // Apply +40% bonus (2 difficulty grades)
    const newValue = currentValue + 40;
    willpowerField.value = newValue;
    willpowerField.classList.add('mental-strength-boosted');
    willpowerField.title = '+40% from Mental Strength (2 Difficulty Grades easier vs mind magic)';
    
    // Update UI
    const buttonsRow = document.getElementById('mental-strength-buttons');
    const activeRow = document.getElementById('mental-strength-active');
    
    if (buttonsRow) buttonsRow.style.display = 'none';
    if (activeRow) activeRow.style.display = '';
    
    this.updateMentalStrengthDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * End Mental Strength effect and restore Willpower
   */
  endMentalStrength() {
    if (!this.character.isMentalStrengthActive) return;
    
    const willpowerField = document.getElementById('willpower-current');
    
    if (willpowerField) {
      // Restore original value
      willpowerField.value = this.character.preMentalStrengthValue;
      willpowerField.classList.remove('mental-strength-boosted');
      willpowerField.title = '';
    }
    
    // Reset state
    this.character.isMentalStrengthActive = false;
    this.character.preMentalStrengthValue = null;
    
    // Update UI
    const buttonsRow = document.getElementById('mental-strength-buttons');
    const activeRow = document.getElementById('mental-strength-active');
    
    if (buttonsRow) buttonsRow.style.display = '';
    if (activeRow) activeRow.style.display = 'none';
    
    this.updateMentalStrengthDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * Restore Mental Strength state after page reload
   */
  restoreMentalStrengthState() {
    const willpowerField = document.getElementById('willpower-current');
    
    if (willpowerField && this.character.preMentalStrengthValue !== null) {
      // Reapply the +40% bonus display
      const boostedValue = (this.character.preMentalStrengthValue || 0) + 40;
      willpowerField.value = boostedValue;
      willpowerField.classList.add('mental-strength-boosted');
      willpowerField.title = '+40% from Mental Strength (2 Difficulty Grades easier vs mind magic)';
    }
    
    // Update UI to show active state
    const buttonsRow = document.getElementById('mental-strength-buttons');
    const activeRow = document.getElementById('mental-strength-active');
    
    if (buttonsRow) buttonsRow.style.display = 'none';
    if (activeRow) activeRow.style.display = '';
    
    this.updateMentalStrengthDisplay();
  },
  
  /**
   * Handle Mental Strength upgrades - remove lower versions when a higher version is added
   */
  handleMentalStrengthUpgrade(newAbilityName) {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    // Map ability names to their level
    const mentalStrengthLevels = {
      'mental strength i': 1, 'mental strength 1': 1,
      'mental strength ii': 2, 'mental strength 2': 2,
      'mental strength iii': 3, 'mental strength 3': 3,
      'mental strength iv': 4, 'mental strength 4': 4,
      'mental strength v': 5, 'mental strength 5': 5
    };
    
    const newLevel = mentalStrengthLevels[newAbilityName.toLowerCase().trim()];
    if (!newLevel) return;
    
    // Find and remove all lower-level Mental Strength abilities
    const inputs = container.querySelectorAll('.class-ability-input');
    const rowsToRemove = [];
    
    inputs.forEach(input => {
      const existingName = input.value.toLowerCase().trim();
      const existingLevel = mentalStrengthLevels[existingName];
      
      if (existingLevel && existingLevel < newLevel) {
        // This is a lower-level Mental Strength - mark for removal
        rowsToRemove.push(input.closest('.class-ability-row'));
      }
    });
    
    // Remove the rows
    rowsToRemove.forEach(row => {
      if (row) {
        row.remove();
        console.log('handleMentalStrengthUpgrade: removed lower Mental Strength version');
      }
    });
    
    // Sync to character data
    if (rowsToRemove.length > 0) {
      this.syncClassAbilitiesToCharacter();
    }
  },

  // ========================================
  // Turn Undead System (Cleric)
  // ========================================
  
  /**
   * Check if character has Turn Undead ability and show/hide section
   */
  checkTurnUndeadVisibility() {
    const section = document.getElementById('turn-undead-section');
    if (!section) return;
    
    const hasTurnUndead = this.hasAbility('Turn Undead');
    
    if (hasTurnUndead) {
      section.style.display = '';
      this.initTurnUndead();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Initialize Turn Undead system
   */
  initTurnUndead() {
    this.updateTurnUndeadDisplay();
    this.setupTurnUndeadListeners();
  },
  
  /**
   * Get maximum Turn Undead uses per encounter
   * Based on class rank (Cleric rank) - uses = rank per encounter
   * Extra Turning doubles this amount
   */
  getMaxTurnUndeadUses() {
    // Check all class slots for Cleric
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    
    let maxRank = 0;
    
    for (const slot of classSlots) {
      const className = document.getElementById(slot.class)?.value?.toLowerCase().trim() || '';
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      
      if (className === 'cleric' && rank > maxRank) {
        maxRank = rank;
      }
    }
    
    // Base uses = rank (at least 1 if character has Turn Undead ability)
    let uses = Math.max(maxRank, 1);
    
    // Extra Turning doubles the uses
    if (this.hasAbility('Extra Turning')) {
      uses *= 2;
    }
    
    return uses;
  },
  
  /**
   * Get Cleric rank (for Turn Undead intensity calculation)
   */
  getClericRank() {
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    
    let maxRank = 0;
    
    for (const slot of classSlots) {
      const className = document.getElementById(slot.class)?.value?.toLowerCase().trim() || '';
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      
      if (className === 'cleric' && rank > maxRank) {
        maxRank = rank;
      }
    }
    
    return Math.max(maxRank, 1);
  },
  
  /**
   * Update Turn Undead display values
   */
  updateTurnUndeadDisplay() {
    const maxUses = this.getMaxTurnUndeadUses();
    
    // Initialize uses remaining if not set
    if (this.character.turnUndeadUsesRemaining === undefined || this.character.turnUndeadUsesRemaining === null) {
      this.character.turnUndeadUsesRemaining = maxUses;
    }
    
    const usesAvail = document.getElementById('turn-undead-uses-available');
    const usesMax = document.getElementById('turn-undead-uses-max');
    
    if (usesAvail) usesAvail.textContent = this.character.turnUndeadUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;
    
    // Update button state
    const useBtn = document.getElementById('btn-turn-undead-use');
    const noUses = this.character.turnUndeadUsesRemaining <= 0;
    
    if (useBtn) useBtn.disabled = noUses;
  },
  
  /**
   * Setup Turn Undead event listeners
   */
  setupTurnUndeadListeners() {
    const useBtn = document.getElementById('btn-turn-undead-use');
    const resetBtn = document.getElementById('btn-reset-turn-undead-uses');
    
    if (useBtn && !useBtn.dataset.listenerAdded) {
      useBtn.addEventListener('click', () => this.useTurnUndead());
      useBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetBtn && !resetBtn.dataset.listenerAdded) {
      resetBtn.addEventListener('click', () => {
        this.character.turnUndeadUsesRemaining = this.getMaxTurnUndeadUses();
        this.updateTurnUndeadDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Use Turn Undead ability - show animation then open modal
   */
  useTurnUndead() {
    if (this.character.turnUndeadUsesRemaining <= 0) return;
    
    // Decrement uses
    this.character.turnUndeadUsesRemaining--;
    this.updateTurnUndeadDisplay();
    this.scheduleAutoSave();
    
    // Show animation then open modal
    this.showTurnUndeadAnimation(() => {
      this.openTurnUndeadModal();
    });
  },
  
  /**
   * Show Turn Undead animation (holy light burst)
   */
  showTurnUndeadAnimation(callback) {
    // Create animation overlay
    const overlay = document.createElement('div');
    overlay.className = 'turn-undead-anim-overlay';
    overlay.innerHTML = `
      <div class="turn-undead-anim-content">
        <div class="holy-burst"></div>
        <div class="holy-rays">
          <div class="ray"></div>
          <div class="ray"></div>
          <div class="ray"></div>
          <div class="ray"></div>
          <div class="ray"></div>
          <div class="ray"></div>
          <div class="ray"></div>
          <div class="ray"></div>
        </div>
        <div class="turn-undead-icon">☀️</div>
        <div class="turn-undead-anim-text">Channeling Divine Power...</div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    // Trigger animation
    requestAnimationFrame(() => {
      overlay.classList.add('active');
    });
    
    // Remove after animation and call callback
    setTimeout(() => {
      overlay.classList.add('fade-out');
      setTimeout(() => {
        overlay.remove();
        if (callback) callback();
      }, 400);
    }, 1500);
  },
  
  /**
   * Open Turn Undead modal for rolling
   */
  openTurnUndeadModal() {
    let modal = document.getElementById('turn-undead-modal');
    
    // Check if character has Greater Turning ability
    const hasGreaterTurning = this.hasAbility('Greater Turning');
    
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'turn-undead-modal';
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content turn-undead-modal-content">
          <div class="modal-header turn-undead-modal-header">
            <h3>☀️ Turn Undead</h3>
            <button class="modal-close" id="turn-undead-modal-close">&times;</button>
          </div>
          <div class="modal-body turn-undead-modal-body">
            <div class="turn-undead-roll-section">
              <h4>Step 1: Determine Turning Power</h4>
              <p class="turn-undead-instruction">Roll to determine how much Intensity you can Turn.</p>
              <div class="turn-undead-roll-row">
                <span class="turn-undead-roll-label">Intensity Roll:</span>
                <span class="turn-undead-roll-formula" id="turn-undead-intensity-formula">1d6+2</span>
                <button type="button" class="btn btn-roll-intensity" id="btn-roll-intensity">🎲 Roll</button>
                <span class="turn-undead-roll-result" id="turn-undead-intensity-result"></span>
              </div>
              <div class="turn-undead-intensity-display" id="turn-undead-intensity-display" style="display: none;">
                <span>Turning Power: <strong id="turning-power-value">0</strong></span>
              </div>
            </div>
            
            <hr class="turn-undead-divider">
            
            <div class="turn-undead-roll-section">
              <h4>Step 2: Channel Roll</h4>
              <p class="turn-undead-instruction">Roll Channel to determine the outcome.</p>
              <div class="turn-undead-roll-row">
                <span class="turn-undead-roll-label">Channel:</span>
                <span class="turn-undead-roll-skill" id="turn-undead-channel-value">0%</span>
                <button type="button" class="btn btn-roll-channel" id="btn-roll-channel" disabled>🎲 Roll d100</button>
                <span class="turn-undead-roll-result" id="turn-undead-channel-result"></span>
              </div>
              <div class="turn-undead-reroll-row" id="turn-undead-reroll-row" style="display: none;">
                <button type="button" class="btn btn-reroll-channel" id="btn-reroll-channel">🔄 Reroll (Greater Turning)</button>
                <span class="reroll-note">Must use new result</span>
              </div>
            </div>
            
            <div class="turn-undead-outcome" id="turn-undead-outcome" style="display: none;">
              <h4>Result</h4>
              <div class="turn-undead-outcome-text" id="turn-undead-outcome-text"></div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="turn-undead-modal-done">Done</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Setup event listeners
      document.getElementById('turn-undead-modal-close').addEventListener('click', () => {
        this.closeTurnUndeadModal();
      });
      
      document.getElementById('turn-undead-modal-done').addEventListener('click', () => {
        this.closeTurnUndeadModal();
      });
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeTurnUndeadModal();
        }
      });
      
      document.getElementById('btn-roll-intensity').addEventListener('click', () => {
        this.rollTurnUndeadIntensity();
      });
      
      document.getElementById('btn-roll-channel').addEventListener('click', () => {
        this.rollTurnUndeadChannel(false);
      });
      
      document.getElementById('btn-reroll-channel').addEventListener('click', () => {
        this.rollTurnUndeadChannel(true);
      });
    }
    
    // Reset modal state
    this.resetTurnUndeadModal();
    
    // Update Channel skill value
    const channelPercent = parseInt(document.getElementById('channel-percent')?.value, 10) || 0;
    document.getElementById('turn-undead-channel-value').textContent = channelPercent + '%';
    
    // Update intensity formula based on Cleric rank
    const rank = this.getClericRank();
    const bonus = rank * 2; // Rank 1 = +2, Rank 2 = +4, etc.
    document.getElementById('turn-undead-intensity-formula').textContent = `1d6+${bonus}`;
    
    // Store values for roll calculation
    modal.dataset.clericRank = rank;
    modal.dataset.channelSkill = channelPercent;
    modal.dataset.hasGreaterTurning = hasGreaterTurning ? 'true' : 'false';
    modal.dataset.hasUsedReroll = 'false';
    
    // Show modal
    modal.classList.remove('hidden');
  },
  
  /**
   * Reset Turn Undead modal state
   */
  resetTurnUndeadModal() {
    document.getElementById('turn-undead-intensity-result').textContent = '';
    document.getElementById('turn-undead-intensity-result').className = 'turn-undead-roll-result';
    document.getElementById('turn-undead-intensity-display').style.display = 'none';
    document.getElementById('turn-undead-channel-result').textContent = '';
    document.getElementById('turn-undead-channel-result').className = 'turn-undead-roll-result';
    document.getElementById('turn-undead-outcome').style.display = 'none';
    document.getElementById('turn-undead-reroll-row').style.display = 'none';
    document.getElementById('btn-roll-intensity').disabled = false;
    document.getElementById('btn-roll-channel').disabled = true;
  },
  
  /**
   * Roll Turning Power (Intensity)
   */
  rollTurnUndeadIntensity() {
    const modal = document.getElementById('turn-undead-modal');
    const rank = parseInt(modal.dataset.clericRank, 10) || 1;
    const bonus = rank * 2;
    
    // Roll 1d6
    const dieRoll = Math.floor(Math.random() * 6) + 1;
    const total = dieRoll + bonus;
    
    // Display result with animation
    const resultSpan = document.getElementById('turn-undead-intensity-result');
    resultSpan.textContent = `🎲 ${dieRoll} + ${bonus} = `;
    resultSpan.className = 'turn-undead-roll-result rolling';
    
    setTimeout(() => {
      resultSpan.innerHTML = `🎲 ${dieRoll} + ${bonus} = <strong>${total}</strong>`;
      resultSpan.className = 'turn-undead-roll-result success';
      
      // Show turning power
      document.getElementById('turning-power-value').textContent = total;
      document.getElementById('turn-undead-intensity-display').style.display = '';
      
      // Store for channel roll
      modal.dataset.turningPower = total;
      
      // Enable channel roll, disable intensity roll
      document.getElementById('btn-roll-intensity').disabled = true;
      document.getElementById('btn-roll-channel').disabled = false;
    }, 500);
  },
  
  /**
   * Roll Channel skill for Turn Undead
   * @param {boolean} isReroll - Whether this is a Greater Turning reroll
   */
  rollTurnUndeadChannel(isReroll = false) {
    const modal = document.getElementById('turn-undead-modal');
    const channelSkill = parseInt(modal.dataset.channelSkill, 10) || 0;
    const turningPower = parseInt(modal.dataset.turningPower, 10) || 0;
    const hasGreaterTurning = modal.dataset.hasGreaterTurning === 'true';
    
    // If rerolling, mark that we've used the reroll
    if (isReroll) {
      modal.dataset.hasUsedReroll = 'true';
    }
    
    // Roll d100
    const roll = Math.floor(Math.random() * 100) + 1;
    
    // Determine result using standard d100 rules:
    // Critical = ceil(skill/10), Fumble = 99-00 (or just 00 if skill >= 100)
    // 96-00 always failure, 01-05 always success
    const critThreshold = Math.max(1, Math.ceil(channelSkill / 10));
    const isFumble = channelSkill >= 100 ? (roll === 100) : (roll >= 99);
    const isAutoFail = roll >= 96;
    const isAutoSuccess = roll <= 5;
    
    let resultType = '';
    let resultClass = '';
    let outcomeHtml = '';
    
    if (isFumble) {
      resultType = 'FUMBLE!';
      resultClass = 'fumble';
      const doublePower = turningPower * 2;
      outcomeHtml = `
        <div class="outcome-fumble">
          <p><strong>💀 Fumble!</strong></p>
          <p>Your attempt to Turn not only fails, but it <em>provokes</em> several undead, demons, or devils within the area.</p>
          <p>Creatures with a combined Intensity equal to <strong>(${doublePower})</strong> (2× your Turning Power) will focus their attacks on you specifically.</p>
        </div>
      `;
    } else if (isAutoFail) {
      resultType = 'Failure';
      resultClass = 'failure';
      outcomeHtml = `
        <div class="outcome-failure">
          <p><strong>✗ Failure</strong></p>
          <p>No undead, demons, or devils Turned.</p>
        </div>
      `;
    } else if (roll <= critThreshold && (roll <= channelSkill || isAutoSuccess)) {
      resultType = 'CRITICAL!';
      resultClass = 'critical';
      const doublePower = turningPower * 2;
      outcomeHtml = `
        <div class="outcome-critical">
          <p><strong>🌟 Critical Success!</strong></p>
          <p>You may Turn undead with a total Intensity up to <strong>(${doublePower})</strong> (2× your Turning Power),</p>
          <p>OR demons/devils with Intensity up to <strong>(${turningPower})</strong> (full Turning Power).</p>
          <p class="outcome-note">Start with those of the lowest Intensity first.</p>
        </div>
      `;
    } else if (roll <= channelSkill || isAutoSuccess) {
      resultType = 'Success';
      resultClass = 'success';
      const halfPower = Math.ceil(turningPower / 2); // Round UP
      outcomeHtml = `
        <div class="outcome-success">
          <p><strong>✓ Success!</strong></p>
          <p>You may Turn undead with a total Intensity up to <strong>(${turningPower})</strong> (your Turning Power),</p>
          <p>OR demons/devils with Intensity up to <strong>(${halfPower})</strong> (half your Turning Power, rounded up).</p>
          <p class="outcome-note">Start with those of the lowest Intensity first.</p>
        </div>
      `;
    } else {
      resultType = 'Failure';
      resultClass = 'failure';
      outcomeHtml = `
        <div class="outcome-failure">
          <p><strong>✗ Failure</strong></p>
          <p>No undead, demons, or devils Turned.</p>
        </div>
      `;
    }
    
    // Display roll result with animation
    const resultSpan = document.getElementById('turn-undead-channel-result');
    resultSpan.textContent = `🎲 Rolling...`;
    resultSpan.className = 'turn-undead-roll-result rolling';
    
    setTimeout(() => {
      resultSpan.innerHTML = `🎲 <strong>${roll}</strong> vs ${channelSkill}% — <span class="result-${resultClass}">${resultType}</span>`;
      resultSpan.className = `turn-undead-roll-result ${resultClass}`;
      
      // Show outcome
      document.getElementById('turn-undead-outcome-text').innerHTML = outcomeHtml;
      document.getElementById('turn-undead-outcome').style.display = '';
      
      // Disable channel roll button
      document.getElementById('btn-roll-channel').disabled = true;
      
      // Show reroll option if Greater Turning and haven't used it yet
      const hasUsedReroll = modal.dataset.hasUsedReroll === 'true';
      if (hasGreaterTurning && !hasUsedReroll) {
        document.getElementById('turn-undead-reroll-row').style.display = '';
      } else {
        document.getElementById('turn-undead-reroll-row').style.display = 'none';
      }
    }, 800);
  },
  
  /**
   * Close Turn Undead modal
   */
  closeTurnUndeadModal() {
    const modal = document.getElementById('turn-undead-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  // ========================================
  // HOLY SMITE SYSTEM
  // ========================================
  
  /**
   * Check if character has any Holy Smite ability and show/hide section
   */
  checkHolySmiteVisibility() {
    const section = document.getElementById('holy-smite-section');
    if (!section) return;
    
    const hasGreaterHolySmite = this.hasAbility('Greater Holy Smite');
    const hasImprovedHolySmite = this.hasAbility('Improved Holy Smite');
    const hasHolySmite = this.hasAbility('Holy Smite');
    
    if (hasGreaterHolySmite || hasImprovedHolySmite || hasHolySmite) {
      section.style.display = '';
      this.initHolySmite();
    } else {
      section.style.display = 'none';
      // End active effect if ability lost
      if (this.character.isHolySmiteActive) {
        this.endHolySmite();
      }
    }
  },
  
  /**
   * Initialize Holy Smite system
   */
  initHolySmite() {
    this.updateHolySmiteDisplay();
    this.setupHolySmiteListeners();
    
    // Restore Holy Smite state if it was active
    if (this.character.isHolySmiteActive) {
      this.restoreHolySmiteState();
    }
  },
  
  /**
   * Get the current Holy Smite tier and step bonus
   * @returns {{ tier: string, steps: number }}
   */
  getHolySmiteTier() {
    if (this.hasAbility('Greater Holy Smite')) {
      return { tier: 'Greater Holy Smite', steps: 4 };
    }
    if (this.hasAbility('Improved Holy Smite')) {
      return { tier: 'Improved Holy Smite', steps: 2 };
    }
    if (this.hasAbility('Holy Smite')) {
      return { tier: 'Holy Smite', steps: 1 };
    }
    return { tier: null, steps: 0 };
  },
  
  /**
   * Get maximum Holy Smite uses per day (1 per Cleric rank)
   */
  getMaxHolySmiteUses() {
    // Check all class slots for Cleric
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    
    let maxRank = 0;
    
    for (const slot of classSlots) {
      const className = document.getElementById(slot.class)?.value?.toLowerCase().trim() || '';
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      
      if (className === 'cleric' && rank > maxRank) {
        maxRank = rank;
      }
    }
    
    // Uses = Cleric rank (minimum 1 if they have the ability)
    return Math.max(1, maxRank);
  },
  
  /**
   * Update Holy Smite display
   */
  updateHolySmiteDisplay() {
    const { tier, steps } = this.getHolySmiteTier();
    const maxUses = this.getMaxHolySmiteUses();
    
    // Initialize uses remaining if not set
    if (this.character.holySmiteUsesRemaining === undefined || this.character.holySmiteUsesRemaining === null) {
      this.character.holySmiteUsesRemaining = maxUses;
    }
    
    const headerEl = document.getElementById('holy-smite-header');
    const bonusEl = document.getElementById('holy-smite-bonus');
    const btnTextEl = document.getElementById('holy-smite-btn-text');
    const btn = document.getElementById('btn-holy-smite-toggle');
    const usesAvailableEl = document.getElementById('holy-smite-uses-available');
    const usesMaxEl = document.getElementById('holy-smite-uses-max');
    
    if (headerEl && tier) {
      headerEl.textContent = `⚔️ ${tier}`;
    }
    
    if (bonusEl) {
      bonusEl.textContent = `+${steps} step${steps > 1 ? 's' : ''} damage modifier vs Evil`;
    }
    
    // Update uses display
    if (usesAvailableEl) usesAvailableEl.textContent = this.character.holySmiteUsesRemaining;
    if (usesMaxEl) usesMaxEl.textContent = maxUses;
    
    if (btnTextEl && btn) {
      if (this.character.isHolySmiteActive) {
        btnTextEl.textContent = 'Deactivate';
        btn.classList.add('active');
        btn.disabled = false;
      } else {
        btnTextEl.textContent = 'Activate';
        btn.classList.remove('active');
        // Disable if no uses remaining
        btn.disabled = this.character.holySmiteUsesRemaining <= 0;
      }
    }
  },
  
  /**
   * Setup Holy Smite event listeners
   */
  setupHolySmiteListeners() {
    const toggleBtn = document.getElementById('btn-holy-smite-toggle');
    const resetBtn = document.getElementById('btn-reset-holy-smite-uses');
    
    if (toggleBtn && !toggleBtn.dataset.listenerAdded) {
      toggleBtn.addEventListener('click', () => this.toggleHolySmite());
      toggleBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetBtn && !resetBtn.dataset.listenerAdded) {
      resetBtn.addEventListener('click', () => {
        this.character.holySmiteUsesRemaining = this.getMaxHolySmiteUses();
        this.updateHolySmiteDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Toggle Holy Smite on/off
   */
  toggleHolySmite() {
    if (this.character.isHolySmiteActive) {
      this.endHolySmite();
    } else {
      this.activateHolySmite();
    }
  },
  
  /**
   * Activate Holy Smite - increase damage modifier by tier steps
   */
  activateHolySmite() {
    if (this.character.isHolySmiteActive) return;
    
    // Check if uses remaining
    if (this.character.holySmiteUsesRemaining <= 0) {
      return;
    }
    
    const { tier, steps } = this.getHolySmiteTier();
    if (steps === 0) return;
    
    const dmgCurrent = document.getElementById('damage-mod-current');
    const wpDmgCurrent = document.getElementById('wp-damage-mod-current');
    const tooltipText = `${tier}: +${steps} step${steps > 1 ? 's' : ''} vs undead/demons/devils`;
    
    // Store original values
    if (dmgCurrent) {
      this.character.holySmiteOriginalDmg = dmgCurrent.value;
      const steppedUp = this.stepDamageModifier(dmgCurrent.value, steps);
      dmgCurrent.value = steppedUp;
      dmgCurrent.classList.add('damage-boosted');
      dmgCurrent.title = tooltipText;
    }
    
    if (wpDmgCurrent && wpDmgCurrent.value) {
      this.character.holySmiteOriginalWpDmg = wpDmgCurrent.value;
      const steppedUp = this.stepDamageModifier(wpDmgCurrent.value, steps);
      wpDmgCurrent.value = steppedUp;
      wpDmgCurrent.classList.add('damage-boosted');
      wpDmgCurrent.title = tooltipText;
    }
    
    this.character.isHolySmiteActive = true;
    
    // Decrement uses remaining
    this.character.holySmiteUsesRemaining--;
    
    // Update weapon damage displays and highlight them
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    this.applyDamageBoostToWeapons(tooltipText);
    
    this.updateHolySmiteDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * End Holy Smite - restore original damage modifiers
   */
  endHolySmite() {
    if (!this.character.isHolySmiteActive) return;
    
    const dmgCurrent = document.getElementById('damage-mod-current');
    const wpDmgCurrent = document.getElementById('wp-damage-mod-current');
    
    // Restore original values
    if (dmgCurrent && this.character.holySmiteOriginalDmg !== undefined) {
      dmgCurrent.value = this.character.holySmiteOriginalDmg;
      dmgCurrent.classList.remove('damage-boosted');
      dmgCurrent.title = '';
    }
    
    if (wpDmgCurrent && this.character.holySmiteOriginalWpDmg !== undefined) {
      wpDmgCurrent.value = this.character.holySmiteOriginalWpDmg;
      wpDmgCurrent.classList.remove('damage-boosted');
      wpDmgCurrent.title = '';
    }
    
    this.character.isHolySmiteActive = false;
    delete this.character.holySmiteOriginalDmg;
    delete this.character.holySmiteOriginalWpDmg;
    
    // Update weapon damage displays and remove highlighting
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    this.removeDamageBoostFromWeapons();
    
    this.updateHolySmiteDisplay();
    this.scheduleAutoSave();
    
    // Ensure DM current matches original now that Holy Smite is over
    this.resetDamageModToOriginalIfClean();
  },
  
  /**
   * Restore Holy Smite state on page load
   */
  restoreHolySmiteState() {
    if (!this.character.isHolySmiteActive) return;
    
    const { tier, steps } = this.getHolySmiteTier();
    const tooltipText = `${tier}: +${steps} step${steps > 1 ? 's' : ''} vs undead/demons/devils`;
    
    const dmgCurrent = document.getElementById('damage-mod-current');
    const wpDmgCurrent = document.getElementById('wp-damage-mod-current');
    
    // Apply visual class and tooltip
    if (dmgCurrent) {
      dmgCurrent.classList.add('damage-boosted');
      dmgCurrent.title = tooltipText;
    }
    if (wpDmgCurrent && wpDmgCurrent.value) {
      wpDmgCurrent.classList.add('damage-boosted');
      wpDmgCurrent.title = tooltipText;
    }
    
    // Apply to weapons
    this.applyDamageBoostToWeapons(tooltipText);
    
    this.updateHolySmiteDisplay();
  },

  // ========================================
  // POWERFUL CONCENTRATION SYSTEM
  // ========================================
  
  /**
   * Check if character has Powerful Concentration ability and show/hide section
   */
  checkPowerfulConcentrationVisibility() {
    const section = document.getElementById('powerful-concentration-section');
    if (!section) return;
    
    const hasPowerfulConcentration = this.hasAbility('Powerful Concentration');
    
    if (hasPowerfulConcentration) {
      section.style.display = '';
      this.initPowerfulConcentration();
    } else {
      section.style.display = 'none';
      // End active effect if ability lost
      if (this.character.isPowerfulConcentrationActive) {
        this.endPowerfulConcentration();
      }
    }
  },
  
  /**
   * Initialize Powerful Concentration system
   */
  initPowerfulConcentration() {
    this.updatePowerfulConcentrationDisplay();
    this.setupPowerfulConcentrationListeners();
    
    // Restore state if it was active
    if (this.character.isPowerfulConcentrationActive) {
      this.restorePowerfulConcentrationState();
    }
  },
  
  /**
   * Update Powerful Concentration display
   */
  updatePowerfulConcentrationDisplay() {
    const btnTextEl = document.getElementById('powerful-concentration-btn-text');
    const btn = document.getElementById('btn-powerful-concentration-toggle');
    
    if (btnTextEl && btn) {
      if (this.character.isPowerfulConcentrationActive) {
        btnTextEl.textContent = 'Deactivate';
        btn.classList.add('active');
      } else {
        btnTextEl.textContent = 'Activate (+20 Willpower)';
        btn.classList.remove('active');
      }
    }
  },
  
  /**
   * Setup Powerful Concentration event listeners
   */
  setupPowerfulConcentrationListeners() {
    const toggleBtn = document.getElementById('btn-powerful-concentration-toggle');
    
    if (toggleBtn && !toggleBtn.dataset.listenerAdded) {
      toggleBtn.addEventListener('click', () => this.togglePowerfulConcentration());
      toggleBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Toggle Powerful Concentration on/off
   */
  togglePowerfulConcentration() {
    if (this.character.isPowerfulConcentrationActive) {
      this.endPowerfulConcentration();
    } else {
      this.activatePowerfulConcentration();
    }
  },
  
  /**
   * Activate Powerful Concentration - add +20 to Willpower
   */
  activatePowerfulConcentration() {
    if (this.character.isPowerfulConcentrationActive) return;
    
    const willpowerField = document.getElementById('willpower-current');
    if (willpowerField) {
      // Store original value
      this.character.powerfulConcentrationOriginalWillpower = parseInt(willpowerField.value, 10) || 0;
      
      // Add +20 to Willpower
      const newValue = this.character.powerfulConcentrationOriginalWillpower + 20;
      willpowerField.value = newValue;
      willpowerField.classList.add('powerful-concentration-bonus');
      willpowerField.title = 'Powerful Concentration: +20 Willpower for concentration checks';
    }
    
    this.character.isPowerfulConcentrationActive = true;
    this.updatePowerfulConcentrationDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * End Powerful Concentration - restore original Willpower
   */
  endPowerfulConcentration() {
    if (!this.character.isPowerfulConcentrationActive) return;
    
    const willpowerField = document.getElementById('willpower-current');
    if (willpowerField && this.character.powerfulConcentrationOriginalWillpower !== undefined) {
      willpowerField.value = this.character.powerfulConcentrationOriginalWillpower;
      willpowerField.classList.remove('powerful-concentration-bonus');
      willpowerField.title = '';
    }
    
    this.character.isPowerfulConcentrationActive = false;
    delete this.character.powerfulConcentrationOriginalWillpower;
    
    this.updatePowerfulConcentrationDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * Restore Powerful Concentration state on page load
   */
  restorePowerfulConcentrationState() {
    if (!this.character.isPowerfulConcentrationActive) return;
    
    const willpowerField = document.getElementById('willpower-current');
    if (willpowerField) {
      willpowerField.classList.add('powerful-concentration-bonus');
      willpowerField.title = 'Powerful Concentration: +20 Willpower for concentration checks';
    }
    
    this.updatePowerfulConcentrationDisplay();
  },

  // ========================================
  // ANIMAL COMPANION SYSTEM
  // ========================================
  
  /**
   * Animal examples by SIZ
   */
  ANIMAL_EXAMPLES_BY_SIZ: {
    1: ['Hamster', 'Parakeet', 'Gecko', 'Ferret', 'Hedgehog', 'Squirrel', 'Box Turtle', 'Hummingbird'],
    2: ['Raccoon', 'Otter', 'Swan', 'Bald Eagle', 'Armadillo', 'Wild Turkey', 'Barn Owl', 'Porcupine'],
    3: ['Coyote', 'Bobcat', 'Beaver', 'Red Fox', 'Badger', 'Wolverine', 'Sloth', 'Snowy Owl'],
    4: ['Capybara', 'Caracal', 'Sea Otter', 'Tasmanian Devil', 'Javelina', 'African Wild Dog', 'Emperor Penguin'],
    5: ['Serval', 'Giant Armadillo', 'Muntjac Deer', "Thomson's Gazelle", 'Ibex Kid', 'Coypu'],
    6: ['Cheetah (juvenile)', 'Roe Deer', 'Springbok', 'Pronghorn Fawn', 'Large Beaver'],
    7: ['Dingo', 'Jackal', 'Small Wolf', 'Duiker'],
    8: ['Wolf'],
    9: ['Snow Leopard', 'Warthog', 'Giant Anteater', 'Common Seal'],
    10: ['Baboon', 'Hyena'],
    11: ['Chimpanzee', 'Mountain Lion/Cougar', 'Tufted Deer'],
    12: ['Leopard', 'White-tailed Deer', 'Wild Goat', 'Gray Seal'],
    13: ['Gorilla', 'Mule Deer', 'Fallow Deer', 'Impala'],
    14: ['Red Deer', 'Blackbuck', 'Hartebeest'],
    15: ['Jaguar', 'Sika Deer', 'Pronghorn'],
    16: ['Dire Wolf'],
    17: ['Boar'],
    18: ['Giant Panda', 'Reindeer', 'Kudu'],
    19: ['Wapiti/Elk (smaller)', 'Gemsbok'],
    20: ['Tapir', 'Wildebeest', 'Zebra'],
    21: ['Siberian Tiger (juvenile)', 'Bongo', 'Eland Calf'],
    22: ['Lion'],
    25: ['Tiger'],
    26: ['Bonacon'],
    28: ['Giant Spider'],
    29: ['Alligator'],
    31: ['Camel', 'Riding Horse', 'Smilodon', 'Giant Vulture'],
    34: ['Bear'],
    35: ['War Horse'],
    37: ['Crocodile'],
    38: ['Auroch', 'Owl Bear'],
    39: ['Heavy Work Horse'],
    41: ['Giant Snake'],
    42: ['Shark'],
    44: ['Short-faced Bear'],
    53: ['Elephant'],
    63: ['Mammoth'],
    67: ['Sea Serpent'],
    75: ['Colossal Squid']
  },
  
  /**
   * Check if character has Animal Companion ability and show/hide section
   */
  checkAnimalCompanionVisibility() {
    const section = document.getElementById('animal-companion-section');
    if (!section) return;
    
    const tier = this.getAnimalCompanionTier();
    
    if (tier > 0) {
      section.style.display = '';
      this.initAnimalCompanion();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Get the current Animal Companion tier (1-5)
   */
  getAnimalCompanionTier() {
    if (this.hasAbility('Animal Companion V') || this.hasAbility('Animal Companion 5')) return 5;
    if (this.hasAbility('Animal Companion IV') || this.hasAbility('Animal Companion 4')) return 4;
    if (this.hasAbility('Animal Companion III') || this.hasAbility('Animal Companion 3')) return 3;
    if (this.hasAbility('Animal Companion II') || this.hasAbility('Animal Companion 2')) return 2;
    if (this.hasAbility('Animal Companion I') || this.hasAbility('Animal Companion 1')) return 1;
    return 0;
  },
  
  /**
   * Get max SIZ for current Animal Companion tier
   */
  getAnimalCompanionMaxSIZ() {
    const tier = this.getAnimalCompanionTier();
    const tierMax = { 1: 35, 2: 45, 3: 55, 4: 65, 5: 75 }[tier] || 35;
    
    // Also limited by 1/2 Animal Handling (rounded up)
    const animalHandling = this.getSkillValueByName('Animal Handling') || 0;
    const halfAnimalHandling = Math.ceil(animalHandling / 2);
    
    // If they don't have Animal Handling, small animals only (SIZ up to ~10 from Small Animal table)
    // But if they have Animal Handling, use the calculated limit
    if (animalHandling === 0) {
      return Math.min(10, tierMax); // Small animals only without Animal Handling
    }
    
    return Math.min(halfAnimalHandling, tierMax);
  },
  
  /**
   * Initialize Animal Companion system
   */
  initAnimalCompanion() {
    this.updateAnimalCompanionDisplay();
    this.renderCompanionList();
  },
  
  /**
   * Update Animal Companion display
   */
  updateAnimalCompanionDisplay() {
    const tier = this.getAnimalCompanionTier();
    const maxSIZ = this.getAnimalCompanionMaxSIZ();
    
    const tierLabel = document.getElementById('companion-tier-label');
    const sizLimit = document.getElementById('companion-siz-limit');
    
    if (tierLabel) {
      const tierNames = { 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V' };
      tierLabel.textContent = `Tier ${tierNames[tier] || 'I'}`;
    }
    
    if (sizLimit) {
      sizLimit.textContent = `Max SIZ: ${maxSIZ}`;
    }
  },
  
  /**
   * Render the list of current companions
   */
  renderCompanionList() {
    const listEl = document.getElementById('companion-list');
    if (!listEl) return;
    
    const companions = this.character.animalCompanions || [];
    
    if (companions.length === 0) {
      listEl.innerHTML = '<p class="no-companions">No companions yet. Use Spend XP Rolls to add one.</p>';
      return;
    }
    
    listEl.innerHTML = companions.map((companion, index) => `
      <div class="companion-item" data-index="${index}">
        <span class="companion-name">${companion.name}</span>
        <span class="companion-siz">SIZ ${companion.siz || '?'}</span>
        <button type="button" class="btn-remove-companion" data-index="${index}" title="Remove companion">✕</button>
      </div>
    `).join('');
    
    // Add remove listeners
    listEl.querySelectorAll('.btn-remove-companion').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const index = parseInt(e.target.dataset.index, 10);
        this.removeAnimalCompanion(index);
      });
    });
  },
  
  /**
   * Show Animal Companion modal
   * @param {number} selectedTier - Optional tier when selecting from Spend XP Rolls
   */
  showAnimalCompanionModal(selectedTier = null) {
    // If a specific tier was selected (from Spend XP Rolls), use that
    // Otherwise use the current tier (from clicking + button)
    const tier = selectedTier || this.getAnimalCompanionTier();
    const isNewAbility = selectedTier !== null;
    
    // Store selected tier for later use when adding companion
    this._pendingCompanionTier = selectedTier;
    
    // Calculate max SIZ based on tier and Animal Handling
    const tierMax = { 1: 35, 2: 45, 3: 55, 4: 65, 5: 75 }[tier] || 35;
    const animalHandling = this.getSkillValueByName('Animal Handling') || 0;
    const halfAnimalHandling = Math.ceil(animalHandling / 2);
    
    // If no Animal Handling, small animals only (SIZ up to ~10)
    let maxSIZ;
    if (animalHandling === 0) {
      maxSIZ = Math.min(10, tierMax);
    } else {
      maxSIZ = Math.min(halfAnimalHandling, tierMax);
    }
    
    // Build examples list (only animals up to maxSIZ)
    const examples = [];
    for (const [siz, animals] of Object.entries(this.ANIMAL_EXAMPLES_BY_SIZ)) {
      if (parseInt(siz, 10) <= maxSIZ) {
        animals.forEach(animal => {
          examples.push({ name: animal, siz: parseInt(siz, 10) });
        });
      }
    }
    
    // Create modal
    let overlay = document.getElementById('animal-companion-modal');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'animal-companion-modal';
      overlay.className = 'modal-overlay animal-companion-modal';
      document.body.appendChild(overlay);
    }
    
    // Build examples HTML
    const examplesHtml = examples.map(ex => 
      `<span class="companion-example"><span class="example-siz">${ex.siz}</span> ${ex.name}</span>`
    ).join('');
    
    // Build description based on Animal Handling skill
    let description = '';
    if (animalHandling === 0) {
      description = `Without Animal Handling skill, you can only befriend <strong>small animals</strong>.`;
    } else {
      description = `With Animal Handling at ${animalHandling}%, you can choose animals up to <strong>SIZ ${halfAnimalHandling}</strong> (half your skill, rounded up). Your tier maximum is ${tierMax}.`;
    }
    
    const tierNames = { 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V' };
    
    overlay.innerHTML = `
      <div class="animal-companion-modal-content">
        <h3>🐾 Animal Companion ${tierNames[tier] || 'I'}</h3>
        <p class="companion-modal-description">
          ${description}
        </p>
        <div class="companion-siz-info">
          <span class="siz-value">${maxSIZ}</span>
          <span class="siz-label">Maximum SIZ</span>
        </div>
        <div class="companion-input-section">
          <label for="companion-name-input">Enter your companion's name/type:</label>
          <div class="companion-input-row">
            <input type="text" id="companion-name-input" placeholder="e.g., Wolf, Hawk, Bear...">
            <button type="button" class="btn btn-add-animal" id="btn-confirm-companion">Add</button>
          </div>
        </div>
        <div class="companion-examples-section">
          <span class="companion-examples-label">Sample animals by SIZ (up to ${maxSIZ}):</span>
          <div class="companion-examples-grid">
            ${examplesHtml}
          </div>
        </div>
        <div class="companion-modal-footer">
          <button type="button" class="btn btn-cancel" id="companion-modal-cancel">Cancel</button>
        </div>
      </div>
    `;
    
    overlay.classList.remove('hidden');
    overlay.style.display = 'flex';
    
    // Focus input
    const input = overlay.querySelector('#companion-name-input');
    setTimeout(() => input.focus(), 100);
    
    // Add event listeners
    const addBtn = overlay.querySelector('#btn-confirm-companion');
    addBtn.addEventListener('click', () => {
      const name = input.value.trim();
      if (name) {
        this.addAnimalCompanion(name, maxSIZ);
        this.closeAnimalCompanionModal();
      }
    });
    
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const name = input.value.trim();
        if (name) {
          this.addAnimalCompanion(name, maxSIZ);
          this.closeAnimalCompanionModal();
        }
      }
    });
    
    const cancelBtn = overlay.querySelector('#companion-modal-cancel');
    cancelBtn.addEventListener('click', () => this.closeAnimalCompanionModal());
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        this.closeAnimalCompanionModal();
      }
    });
  },
  
  /**
   * Close Animal Companion modal
   */
  closeAnimalCompanionModal() {
    const overlay = document.getElementById('animal-companion-modal');
    if (overlay) {
      overlay.style.display = 'none';
      overlay.classList.add('hidden');
    }
    // Clear pending tier
    this._pendingCompanionTier = null;
  },
  
  /**
   * Add an animal companion
   */
  addAnimalCompanion(name, maxSIZ) {
    console.log('addAnimalCompanion called:', name, 'maxSIZ:', maxSIZ, 'pendingTier:', this._pendingCompanionTier);
    
    if (!this.character.animalCompanions) {
      this.character.animalCompanions = [];
    }
    
    // Try to find the SIZ from our examples
    let estimatedSIZ = null;
    const normalizedName = name.toLowerCase().trim();
    
    for (const [siz, animals] of Object.entries(this.ANIMAL_EXAMPLES_BY_SIZ)) {
      for (const animal of animals) {
        if (animal.toLowerCase().includes(normalizedName) || normalizedName.includes(animal.toLowerCase())) {
          estimatedSIZ = parseInt(siz, 10);
          break;
        }
      }
      if (estimatedSIZ) break;
    }
    
    this.character.animalCompanions.push({
      name: this.toTitleCase(name),
      siz: estimatedSIZ || `≤${maxSIZ}`,
      addedAt: new Date().toISOString()
    });
    
    // Always add the ability to the sheet when a companion is added
    // Since the + button was removed, companions can only be added via Spend XP Rolls
    const tier = this._pendingCompanionTier || 1; // Default to tier 1
    const tierNames = { 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V' };
    const abilityName = `Animal Companion ${tierNames[tier]}`;
    
    console.log('Adding ability:', abilityName);
    
    // Always try to add the ability - addAbilityDirectly will check if it's already in the DOM
    this.addAbilityDirectly(abilityName);
    
    // Clear the pending tier
    this._pendingCompanionTier = null;
    
    this.renderCompanionList();
    this.checkAnimalCompanionVisibility();
    this.updateAnimalCompanionDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * Remove an animal companion
   */
  removeAnimalCompanion(index) {
    if (!this.character.animalCompanions) return;
    
    this.character.animalCompanions.splice(index, 1);
    this.renderCompanionList();
    this.scheduleAutoSave();
  },

  // ========================================
  // SHAPE CHANGE SYSTEM (Druid)
  // ========================================
  
  /**
   * Shape Change tier descriptions for each level
   */
  SHAPE_CHANGE_DATA: {
    1: {
      label: 'Shape Change I',
      sizRange: 'SIZ 3–20',
      description: `<p>You can transform into a mundane reptile, bird, or mammal and back again without expending Magic Points. This ability does not allow you to take the form of magical or supernatural creatures.</p>
<p>The transformation lasts up to 5 hours, plus 5 additional hours for each Rank beyond the minimum requirement, or until you choose to revert. Changing form requires 1 Cast Magic Action. You can assume the shape of any natural animal with a SIZ between 3 and 20. Upon transformation, you adopt the creature's average physical Characteristics (STR, CON, SIZ, and DEX), as well as any inherent attacks and movement Creature Abilities (such as Swimmer or Flying). You may use either the creature's skills or your own, whichever is higher. For specific animals related to Shape Change I–IV, see the <em>Monster Manual</em>.</p>
<p>Your clothing and one item in each hand (up to 2 Things per item, or a single item of 4 Things held with both hands) transform with you. Any additional items drop to the ground and can be retrieved after you revert to your original form. Any items transformed are not useable unless the animal you change into has opposable thumbs (an ape for instance).</p>`
    },
    2: {
      label: 'Shape Change II',
      sizRange: 'SIZ 1–60',
      description: `<p>This ability functions like Shape Change I, but with expanded options. You can now transform into tiny animals with a SIZ of 1–2 or larger animals with a SIZ of 21–60. If your Piety reaches 100% or higher, you also gain the ability to transform into plant creatures, such as a tree'nt or shambler.</p>`
    },
    3: {
      label: 'Shape Change III',
      sizRange: 'SIZ 1–60 + Elementals',
      description: `<p>This ability functions like Shape Change I, but with additional forms. You can now transform into a small, medium, or large elemental once per day. At 120% Piety, you may use this ability twice per day. When in elemental form, you gain all the elemental's supernatural and Spell-Like Abilities. This transformation is in addition to your usual animal forms and does not replace them.</p>`
    },
    4: {
      label: 'Shape Change IV',
      sizRange: 'SIZ 1–60 + Huge Elemental',
      description: `<p>This ability functions like Shape Change III, but you may now transform into a Huge elemental once per day. This form is in addition to your existing animal and elemental transformations and does not replace any previously gained forms.</p>`
    }
  },
  
  /**
   * Random transformation animations and phrases
   */
  SHAPE_CHANGE_PHRASES: [
    'You transform into the animal of your choice.',
    'Your bones shift and reshape as fur sprouts across your skin...',
    'Nature\'s power flows through you as your form changes...',
    'With a shimmer of druidic magic, you take on a new shape.',
    'The wild calls to you and your body answers.',
    'Your senses sharpen as you embrace the beast within.',
    'Feathers, fur, or scales — the choice is yours.',
    'The boundary between humanoid and animal blurs and fades...',
    'You feel the earth\'s pulse as your transformation completes.',
    'The spirit of the wild grants you a new form.'
  ],
  
  SHAPE_CHANGE_EMOJIS: ['🐺', '🦅', '🐻', '🐍', '🦌', '🐆', '🦉', '🐗', '🦎', '🐬', '🦇', '🐒', '🦈', '🐊', '🐘'],
  
  /**
   * Check if character has Shape Change ability and show/hide section
   */
  checkShapeChangeVisibility() {
    const section = document.getElementById('shape-change-section');
    if (!section) return;
    
    const tier = this.getShapeChangeTier();
    
    if (tier) {
      section.style.display = '';
      this.initShapeChange();
    } else {
      section.style.display = 'none';
    }
  },
  
  /**
   * Get the highest Shape Change tier the character has (1-4, or 0 if none)
   */
  getShapeChangeTier() {
    if (this.hasAbility('Shape Change IV') || this.hasAbility('Shape Change 4')) return 4;
    if (this.hasAbility('Shape Change III') || this.hasAbility('Shape Change 3')) return 3;
    if (this.hasAbility('Shape Change II') || this.hasAbility('Shape Change 2')) return 2;
    if (this.hasAbility('Shape Change I') || this.hasAbility('Shape Change 1')) return 1;
    return 0;
  },
  
  /**
   * Get Piety skill value
   */
  getPietyValue() {
    const pietyInput = document.getElementById('piety-percent');
    if (pietyInput) return parseInt(pietyInput.value, 10) || 0;
    
    // Fallback: search professional skills
    const profSkills = document.querySelectorAll('.prof-skill-row');
    for (const row of profSkills) {
      const nameInput = row.querySelector('.prof-skill-name');
      const totalInput = row.querySelector('.prof-skill-total');
      if (nameInput && nameInput.value.toLowerCase().trim() === 'piety' && totalInput) {
        return parseInt(totalInput.value, 10) || 0;
      }
    }
    return 0;
  },
  
  /**
   * Get Druid rank for duration calculation
   */
  getDruidRank() {
    const classSlots = [
      { class: 'class-primary', rank: 'rank-primary' },
      { class: 'class-secondary', rank: 'rank-secondary' },
      { class: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    
    let maxRank = 0;
    for (const slot of classSlots) {
      const className = document.getElementById(slot.class)?.value?.toLowerCase().trim() || '';
      const rank = parseInt(document.getElementById(slot.rank)?.value, 10) || 0;
      if (className === 'druid' && rank > maxRank) {
        maxRank = rank;
      }
    }
    return maxRank;
  },
  
  /**
   * Get maximum Shape Change uses per day based on Piety
   * 1/day at 70% Piety, +1 per full 10% above that
   */
  getMaxShapeChangeUses() {
    const piety = this.getPietyValue();
    if (piety < 70) return 0;
    return 1 + Math.floor((piety - 70) / 10);
  },
  
  /**
   * Initialize Shape Change system
   */
  initShapeChange() {
    this.updateShapeChangeDisplay();
    this.setupShapeChangeListeners();
  },
  
  /**
   * Update Shape Change display values
   */
  updateShapeChangeDisplay() {
    const tier = this.getShapeChangeTier();
    const maxUses = this.getMaxShapeChangeUses();
    const druidRank = this.getDruidRank();
    const data = this.SHAPE_CHANGE_DATA[tier];
    
    // Initialize uses remaining if not set
    if (this.character.shapeChangeUsesRemaining === undefined || this.character.shapeChangeUsesRemaining === null) {
      this.character.shapeChangeUsesRemaining = maxUses;
    }
    
    const usesAvail = document.getElementById('shape-change-uses-available');
    const usesMax = document.getElementById('shape-change-uses-max');
    const tierLabel = document.getElementById('shape-change-tier-label');
    const durationLabel = document.getElementById('shape-change-duration');
    
    if (usesAvail) usesAvail.textContent = this.character.shapeChangeUsesRemaining;
    if (usesMax) usesMax.textContent = maxUses;
    if (tierLabel && data) tierLabel.textContent = data.label;
    
    // Duration: 5 hrs base + 5 hrs per rank beyond 2 (minimum rank for Shape Change I)
    const bonusRanks = Math.max(druidRank - 2, 0);
    const totalHours = 5 + (bonusRanks * 5);
    if (durationLabel) durationLabel.textContent = `Duration: ${totalHours} hrs`;
    
    // Update button state
    const useBtn = document.getElementById('btn-shape-change-use');
    const noUses = this.character.shapeChangeUsesRemaining <= 0;
    if (useBtn) useBtn.disabled = noUses;
  },
  
  /**
   * Setup Shape Change event listeners
   */
  setupShapeChangeListeners() {
    const useBtn = document.getElementById('btn-shape-change-use');
    const resetBtn = document.getElementById('btn-reset-shape-change-uses');
    
    if (useBtn && !useBtn.dataset.listenerAdded) {
      useBtn.addEventListener('click', () => this.openShapeChangeModal());
      useBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetBtn && !resetBtn.dataset.listenerAdded) {
      resetBtn.addEventListener('click', () => {
        this.character.shapeChangeUsesRemaining = this.getMaxShapeChangeUses();
        this.updateShapeChangeDisplay();
        this.scheduleAutoSave();
      });
      resetBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Open the Shape Change modal with tier-appropriate description
   */
  openShapeChangeModal() {
    const tier = this.getShapeChangeTier();
    const data = this.SHAPE_CHANGE_DATA[tier];
    if (!data) return;
    
    // Remove existing modal if any
    const existing = document.getElementById('shape-change-modal-overlay');
    if (existing) existing.remove();
    
    const overlay = document.createElement('div');
    overlay.id = 'shape-change-modal-overlay';
    overlay.className = 'shape-change-modal-overlay';
    overlay.innerHTML = `
      <div class="shape-change-modal">
        <div class="shape-change-modal-header">
          <h3>🐺 ${data.label}</h3>
          <span class="shape-change-modal-siz">${data.sizRange}</span>
        </div>
        <div class="shape-change-modal-body">
          ${data.description}
        </div>
        <div class="shape-change-modal-footer">
          <button type="button" class="btn btn-shape-change-transform" id="btn-shape-change-transform">
            🐾 Shape Change
          </button>
          <button type="button" class="btn btn-shape-change-cancel" id="btn-shape-change-cancel">
            Cancel
          </button>
        </div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    // Close on cancel
    document.getElementById('btn-shape-change-cancel').addEventListener('click', () => {
      overlay.remove();
    });
    
    // Close on overlay click
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) overlay.remove();
    });
    
    // Transform button
    document.getElementById('btn-shape-change-transform').addEventListener('click', () => {
      overlay.remove();
      this.executeShapeChange();
    });
  },
  
  /**
   * Execute shape change: decrement uses, show animation
   */
  executeShapeChange() {
    if (this.character.shapeChangeUsesRemaining <= 0) return;
    
    // Decrement uses
    this.character.shapeChangeUsesRemaining--;
    this.updateShapeChangeDisplay();
    this.scheduleAutoSave();
    
    // Show transformation animation
    this.showShapeChangeAnimation();
  },
  
  /**
   * Show shape change transformation animation with random phrase
   */
  showShapeChangeAnimation() {
    const phrase = this.SHAPE_CHANGE_PHRASES[Math.floor(Math.random() * this.SHAPE_CHANGE_PHRASES.length)];
    const emojis = [...this.SHAPE_CHANGE_EMOJIS].sort(() => Math.random() - 0.5).slice(0, 8);
    
    const overlay = document.createElement('div');
    overlay.className = 'shape-change-anim-overlay';
    overlay.innerHTML = `
      <div class="shape-change-anim-content">
        <div class="shape-change-anim-burst"></div>
        <div class="shape-change-anim-animals">
          ${emojis.map((e, i) => `<span class="shape-change-anim-emoji" style="--delay:${i * 0.12}s; --angle:${i * 45}deg">${e}</span>`).join('')}
        </div>
        <div class="shape-change-anim-text">${phrase}</div>
      </div>
    `;
    document.body.appendChild(overlay);
    
    // Trigger animation
    requestAnimationFrame(() => {
      overlay.classList.add('active');
    });
    
    // Remove after animation
    setTimeout(() => {
      overlay.classList.add('fade-out');
      setTimeout(() => overlay.remove(), 500);
    }, 3000);
    
    // Click to dismiss early
    overlay.addEventListener('click', () => {
      overlay.classList.add('fade-out');
      setTimeout(() => overlay.remove(), 500);
    });
  },

  // ========================================
  // SYRIN SPECIES ABILITIES SYSTEM
  // ========================================
  
  /**
   * Damage Modifier progression for stepping up/down
   */
  DAMAGE_MOD_PROGRESSION: [
    '-1d8', '-1d6', '-1d4', '-1d2', '+0', '+1d2', '+1d4', '+1d6', '+1d8', '+1d10', '+1d12',
    '+2d6', '+1d8+1d6', '+2d8', '+1d10+1d8', '+2d10', '+2d10+1d2', '+2d10+1d4',
    '+2d10+1d6', '+2d10+1d8', '+2d10+1d10', '+2d10+1d12', '+3d10'
  ],

  /**
   * Check if character is Syrin species and show/hide abilities section
   */
  checkSyrinAbilitiesVisibility() {
    const section = document.getElementById('syrin-abilities-section');
    const divider = document.getElementById('syrin-abilities-divider');
    if (!section) return;
    
    const species = document.getElementById('species')?.value?.toLowerCase().trim() || '';
    const isSyrin = species === 'syrin';
    
    if (isSyrin) {
      section.style.display = '';
      if (divider) divider.style.display = '';
      this.initSyrinAbilities();
    } else {
      section.style.display = 'none';
      if (divider) divider.style.display = 'none';
      // End any active effects if species changes
      if (this.character.isDivingStrikeActive) {
        this.endDivingStrike();
      }
    }
  },
  
  /**
   * Initialize Syrin abilities system
   */
  initSyrinAbilities() {
    this.updateDivingStrikeDisplay();
    this.setupSyrinAbilitiesListeners();
    
    // Restore Diving Strike visual state if it was active
    if (this.character.isDivingStrikeActive) {
      const tooltipText = 'Diving Strike: +1 step Damage Modifier';
      const dmgCurrent = document.getElementById('damage-mod-current');
      const wpDmgCurrent = document.getElementById('wp-damage-mod-current');
      if (dmgCurrent) {
        dmgCurrent.classList.add('damage-boosted');
        dmgCurrent.title = tooltipText;
      }
      if (wpDmgCurrent && wpDmgCurrent.value) {
        wpDmgCurrent.classList.add('damage-boosted');
        wpDmgCurrent.title = tooltipText;
      }
      // Apply to weapons
      this.applyDamageBoostToWeapons(tooltipText);
    }
  },
  
  /**
   * Setup Syrin abilities event listeners
   */
  setupSyrinAbilitiesListeners() {
    // Diving Strike
    const divingStrikeBtn = document.getElementById('btn-diving-strike');
    const endDivingStrikeBtn = document.getElementById('btn-end-diving-strike');
    const resetDivingStrikeBtn = document.getElementById('btn-reset-diving-strike');
    
    if (divingStrikeBtn && !divingStrikeBtn.dataset.listenerAdded) {
      divingStrikeBtn.addEventListener('click', () => this.activateDivingStrike());
      divingStrikeBtn.dataset.listenerAdded = 'true';
    }
    
    if (endDivingStrikeBtn && !endDivingStrikeBtn.dataset.listenerAdded) {
      endDivingStrikeBtn.addEventListener('click', () => this.endDivingStrike());
      endDivingStrikeBtn.dataset.listenerAdded = 'true';
    }
    
    if (resetDivingStrikeBtn && !resetDivingStrikeBtn.dataset.listenerAdded) {
      resetDivingStrikeBtn.addEventListener('click', () => {
        this.character.divingStrikeUsesRemaining = 1;
        this.updateDivingStrikeDisplay();
        this.scheduleAutoSave();
      });
      resetDivingStrikeBtn.dataset.listenerAdded = 'true';
    }
    
    // Radiant Burst
    const radiantBurstBtn = document.getElementById('btn-radiant-burst');
    if (radiantBurstBtn && !radiantBurstBtn.dataset.listenerAdded) {
      radiantBurstBtn.addEventListener('click', () => this.activateRadiantBurst());
      radiantBurstBtn.dataset.listenerAdded = 'true';
    }
  },
  
  /**
   * Update Diving Strike display
   */
  updateDivingStrikeDisplay() {
    // Initialize uses if not set
    if (this.character.divingStrikeUsesRemaining === undefined) {
      this.character.divingStrikeUsesRemaining = 1;
    }
    
    const usesEl = document.getElementById('diving-strike-uses');
    if (usesEl) usesEl.textContent = this.character.divingStrikeUsesRemaining;
    
    const btn = document.getElementById('btn-diving-strike');
    const isActive = this.character.isDivingStrikeActive;
    const noUses = this.character.divingStrikeUsesRemaining <= 0;
    
    if (btn) btn.disabled = noUses || isActive;
    
    // Show/hide active state
    const buttonsRow = document.getElementById('diving-strike-buttons');
    const activeRow = document.getElementById('diving-strike-active');
    
    if (isActive) {
      if (buttonsRow) buttonsRow.style.display = 'none';
      if (activeRow) activeRow.style.display = '';
    } else {
      if (buttonsRow) buttonsRow.style.display = '';
      if (activeRow) activeRow.style.display = 'none';
    }
  },
  
  /**
   * Activate Diving Strike - increase damage modifiers by one step
   */
  activateDivingStrike() {
    if (this.character.isDivingStrikeActive || this.character.divingStrikeUsesRemaining <= 0) return;
    
    // Store original values before modifying
    const dmgCurrent = document.getElementById('damage-mod-current');
    const wpDmgCurrent = document.getElementById('wp-damage-mod-current');
    
    if (dmgCurrent) {
      this.character.divingStrikeOriginalDmg = dmgCurrent.value;
      const steppedUp = this.stepDamageModifier(dmgCurrent.value, 1);
      dmgCurrent.value = steppedUp;
      dmgCurrent.classList.add('damage-boosted');
      dmgCurrent.title = 'Diving Strike: +1 step Damage Modifier';
    }
    
    if (wpDmgCurrent && wpDmgCurrent.value) {
      this.character.divingStrikeOriginalWpDmg = wpDmgCurrent.value;
      const steppedUp = this.stepDamageModifier(wpDmgCurrent.value, 1);
      wpDmgCurrent.value = steppedUp;
      wpDmgCurrent.classList.add('damage-boosted');
      wpDmgCurrent.title = 'Diving Strike: +1 step Damage Modifier';
    }
    
    this.character.isDivingStrikeActive = true;
    this.character.divingStrikeUsesRemaining--;
    
    // Update weapon damage displays and highlight them
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    this.applyDamageBoostToWeapons('Diving Strike: +1 step Damage Modifier');
    
    this.updateDivingStrikeDisplay();
    this.scheduleAutoSave();
  },
  
  /**
   * End Diving Strike - restore original damage modifiers
   */
  endDivingStrike() {
    if (!this.character.isDivingStrikeActive) return;
    
    const dmgCurrent = document.getElementById('damage-mod-current');
    const wpDmgCurrent = document.getElementById('wp-damage-mod-current');
    
    // Restore original values
    if (dmgCurrent && this.character.divingStrikeOriginalDmg !== undefined) {
      dmgCurrent.value = this.character.divingStrikeOriginalDmg;
      dmgCurrent.classList.remove('damage-boosted');
      dmgCurrent.title = '';
    }
    
    if (wpDmgCurrent && this.character.divingStrikeOriginalWpDmg !== undefined) {
      wpDmgCurrent.value = this.character.divingStrikeOriginalWpDmg;
      wpDmgCurrent.classList.remove('damage-boosted');
      wpDmgCurrent.title = '';
    }
    
    this.character.isDivingStrikeActive = false;
    delete this.character.divingStrikeOriginalDmg;
    delete this.character.divingStrikeOriginalWpDmg;
    
    // Update weapon damage displays and remove highlighting
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
    this.removeDamageBoostFromWeapons();
    
    this.updateDivingStrikeDisplay();
    this.scheduleAutoSave();
    
    // Ensure DM current matches original now that Diving Strike is over
    this.resetDamageModToOriginalIfClean();
  },
  
  /**
   * Apply damage boost styling to all weapon damage fields
   * @param {string} tooltipText - Hover text explaining the boost
   */
  applyDamageBoostToWeapons(tooltipText) {
    const weaponDamageFields = document.querySelectorAll('.weapon-damage');
    weaponDamageFields.forEach(field => {
      if (field.value.trim()) {
        field.classList.add('damage-boosted');
        field.title = tooltipText;
      }
    });
  },
  
  /**
   * Remove damage boost styling from all weapon damage fields
   */
  removeDamageBoostFromWeapons() {
    const weaponDamageFields = document.querySelectorAll('.weapon-damage');
    weaponDamageFields.forEach(field => {
      field.classList.remove('damage-boosted');
      field.title = '';
    });
  },

  /**
   * Apply damage boost styling ONLY to a specific weapon by name
   * Used for Weapon Master which only affects the mastered weapon
   */
  applyDamageBoostToSpecificWeapon(weaponName, tooltipText) {
    if (!weaponName) return;
    const targetName = weaponName.toLowerCase().trim();
    
    // Check melee weapons
    const meleeBody = document.getElementById('melee-weapons-body');
    if (meleeBody) {
      meleeBody.querySelectorAll('tr').forEach(row => {
        const nameInput = row.querySelector('.weapon-name');
        if (!nameInput) return;
        const rowName = nameInput.value.trim().toLowerCase();
        if (this._weaponNameMatches(rowName, targetName)) {
          const damageField = row.querySelector('.weapon-damage');
          if (damageField && damageField.value.trim()) {
            damageField.classList.add('damage-boosted');
            damageField.title = tooltipText;
          }
        }
      });
    }
    
    // Check ranged weapons
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (rangedBody) {
      rangedBody.querySelectorAll('tr').forEach(row => {
        const nameInput = row.querySelector('.weapon-name');
        if (!nameInput) return;
        const rowName = nameInput.value.trim().toLowerCase();
        if (this._weaponNameMatches(rowName, targetName)) {
          const damageField = row.querySelector('.weapon-damage');
          if (damageField && damageField.value.trim()) {
            damageField.classList.add('damage-boosted');
            damageField.title = tooltipText;
          }
        }
      });
    }
  },

  /**
   * Remove damage boost styling ONLY from a specific weapon by name
   */
  removeDamageBoostFromSpecificWeapon(weaponName) {
    if (!weaponName) return;
    const targetName = weaponName.toLowerCase().trim();
    
    ['melee-weapons-body', 'ranged-weapons-body'].forEach(bodyId => {
      const body = document.getElementById(bodyId);
      if (!body) return;
      body.querySelectorAll('tr').forEach(row => {
        const nameInput = row.querySelector('.weapon-name');
        if (!nameInput) return;
        const rowName = nameInput.value.trim().toLowerCase();
        if (this._weaponNameMatches(rowName, targetName)) {
          const damageField = row.querySelector('.weapon-damage');
          if (damageField) {
            damageField.classList.remove('damage-boosted');
            damageField.title = '';
          }
        }
      });
    });
  },
  
  /**
   * Re-apply damage boost styling if any damage-boosting ability is active
   * Called when switching to Combat page to ensure weapons are highlighted
   */
  reapplyDamageBoostStyling() {
    // Check for Holy Smite
    if (this.character.isHolySmiteActive) {
      const { tier, steps } = this.getHolySmiteTier();
      const tooltipText = `${tier}: +${steps} step${steps > 1 ? 's' : ''} vs undead/demons/devils`;
      this.applyDamageBoostToWeapons(tooltipText);
      return;
    }
    
    // Check for Diving Strike
    if (this.character.isDivingStrikeActive) {
      this.applyDamageBoostToWeapons('Diving Strike: +1 step Damage Modifier');
      return;
    }
    
    // Check for Berserk Rage
    if (this.character.isRaging) {
      this.applyDamageBoostToWeapons('Increased damage modifier due to Rage');
      return;
    }
    
    // Check for Forceful Strike (all weapons)
    if (this.character.isForcefulStrikeActive) {
      const weaponDamageFields = document.querySelectorAll('.weapon-damage');
      weaponDamageFields.forEach(field => {
        if (field.value.trim()) {
          field.classList.add('forceful-boosted');
          field.title = 'Increased damage modifier with Forceful Strike';
        }
      });
    }
    
    // Check for Weapon Master (targeted to specific weapon only, on top of forceful)
    const activeSpecs = this.character.activeWeaponSpecs || [];
    if (activeSpecs.length > 0 && this.character.weaponMaster) {
      const wm = this.character.weaponMaster;
      // Check if the mastered weapon is among active specs
      const masteredSpecActive = activeSpecs.some(key => {
        const [w, t] = key.split('|');
        return wm.weapon && wm.weapon.toLowerCase() === w.toLowerCase() && wm.type === t;
      });
      const isMeleeOrShield = wm.type === 'Melee' || wm.type === 'Shield';
      if (masteredSpecActive && isMeleeOrShield) {
        const tierData = this.WEAPON_MASTER_TIERS[wm.tier] || this.WEAPON_MASTER_TIERS.master;
        const tierOrder = ['master', 'high', 'grand', 'legendary'];
        const dmSteps = tierOrder.indexOf(wm.tier) >= 2 ? 2 : 1;
        this.applyDamageBoostToSpecificWeapon(wm.weapon, `${tierData.label}: +${dmSteps} step${dmSteps > 1 ? 's' : ''} DM`);
      }
    }
  },
  
  /**
   * Check if any damage-modifier-stepping ability is currently active.
   * If none are active, reset damage-mod-current (and WP variant) to match their originals.
   * This prevents stale captured values from leaving current out of sync with original
   * after abilities deactivate while characteristics may have changed.
   */
  resetDamageModToOriginalIfClean() {
    // Check all abilities that step the global damage modifier
    const isRaging = !!this.character.isRaging;
    const isForceful = !!this.character.isForcefulStrikeActive;
    const isHolySmite = !!this.character.isHolySmiteActive;
    const isDivingStrike = !!this.character.isDivingStrikeActive;
    const isSpeciesEnemy = !!this.character.speciesEnemyActive;
    
    // If any DM-stepping ability is still active, don't reset
    if (isRaging || isForceful || isHolySmite || isDivingStrike || isSpeciesEnemy) {
      return;
    }
    
    // No DM-stepping ability is active — sync current to original
    const dmgOrigField = document.getElementById('damage-mod-original');
    const dmgCurrField = document.getElementById('damage-mod-current');
    if (dmgOrigField && dmgCurrField) {
      const origVal = dmgOrigField.value.trim();
      if (origVal && dmgCurrField.value.trim() !== origVal) {
        dmgCurrField.value = origVal;
        this.character.derived.damageModCurrent = origVal;
      }
    }
    
    // WP Damage Mod
    const wpOrigField = document.getElementById('wp-damage-mod-original');
    const wpCurrField = document.getElementById('wp-damage-mod-current');
    if (wpOrigField && wpCurrField) {
      const origVal = wpOrigField.value.trim();
      const currVal = wpCurrField.value.trim();
      // Only sync if WP row is visible/active (has a value in original)
      if (origVal && currVal !== origVal) {
        wpCurrField.value = origVal;
      }
    }
    
    // Update weapon damage displays
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
  },
  
  /**
   * Step a damage modifier up or down by a number of steps
   * @param {string} currentMod - Current damage modifier value
   * @param {number} steps - Number of steps (positive = up, negative = down)
   * @returns {string} - New damage modifier value
   */
  stepDamageModifier(currentMod, steps) {
    const normalized = currentMod.trim().toLowerCase();
    let currentIndex = this.DAMAGE_MOD_PROGRESSION.findIndex(
      mod => mod.toLowerCase() === normalized
    );
    
    // If not found, try to find closest match
    if (currentIndex === -1) {
      // Default to +0 if we can't find it
      currentIndex = this.DAMAGE_MOD_PROGRESSION.indexOf('+0');
    }
    
    const newIndex = Math.max(0, Math.min(this.DAMAGE_MOD_PROGRESSION.length - 1, currentIndex + steps));
    return this.DAMAGE_MOD_PROGRESSION[newIndex];
  },
  
  /**
   * Activate Radiant Burst - costs 1 AP and 1 MP, opens modal
   */
  activateRadiantBurst() {
    const apCurrent = document.getElementById('action-points-current');
    const mpCurrent = document.getElementById('magic-points-current');
    
    const currentAP = parseInt(apCurrent?.value, 10) || 0;
    const currentMP = parseInt(mpCurrent?.value, 10) || 0;
    
    // Check if enough resources
    if (currentAP < 1 || currentMP < 1) {
      alert('Radiant Burst requires 1 Action Point and 1 Magic Point.\n\nYou have: ' + currentAP + ' AP, ' + currentMP + ' MP');
      return;
    }
    
    // Deduct costs
    if (apCurrent) apCurrent.value = currentAP - 1;
    if (mpCurrent) mpCurrent.value = currentMP - 1;
    
    this.updateMagicMPDisplay();
    this.scheduleAutoSave();
    
    // Open the modal
    this.openRadiantBurstModal();
  },
  
  /**
   * Open Radiant Burst modal for rolling
   */
  openRadiantBurstModal() {
    let modal = document.getElementById('radiant-burst-modal');
    
    // Get POW value
    const pow = parseInt(document.getElementById('pow-total')?.value, 10) || 
                parseInt(document.getElementById('pow-base')?.value, 10) || 10;
    const powX2 = pow * 2;
    
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'radiant-burst-modal';
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content radiant-burst-modal-content">
          <div class="modal-header radiant-burst-modal-header">
            <h3>💫 Radiant Burst</h3>
            <button class="modal-close" id="radiant-burst-modal-close">&times;</button>
          </div>
          <div class="modal-body radiant-burst-modal-body">
            <div class="radiant-burst-effect">
              <div class="radiant-burst-effect-title">✨ Luminous Energy Burst</div>
              <div class="radiant-burst-effect-text">
                You burst in luminous energy. Your enemies must Oppose your <strong>POW × 2</strong> 
                <span class="radiant-burst-stat" id="radiant-pow-display">(${powX2})</span> 
                vs their <strong>Willpower</strong>.
              </div>
              <div class="radiant-burst-effect-text">
                <strong>Failure:</strong> They lose one Difficulty Grade for 
                <span class="radiant-burst-roll-row">
                  <button type="button" class="btn btn-roll-radiant" id="btn-roll-duration">🎲 1d4</button>
                  <span class="radiant-burst-roll-result" id="radiant-duration-result"></span>
                </span>
                Rounds.
              </div>
            </div>
            
            <div class="radiant-burst-effect radiant-damage-section">
              <div class="radiant-burst-effect-title">🔥 Infernal/Evil Damage</div>
              <div class="radiant-burst-effect-text">
                Any infernal or Evil creatures also take 
                <span class="radiant-burst-roll-row">
                  <button type="button" class="btn btn-roll-radiant" id="btn-roll-damage">🎲 1d3</button>
                  <span class="radiant-burst-roll-result" id="radiant-damage-result"></span>
                </span>
                points of damage, ignoring any non-magical armor.
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="radiant-burst-modal-done">Done</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Setup event listeners
      document.getElementById('radiant-burst-modal-close').addEventListener('click', () => {
        this.closeRadiantBurstModal();
      });
      
      document.getElementById('radiant-burst-modal-done').addEventListener('click', () => {
        this.closeRadiantBurstModal();
      });
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeRadiantBurstModal();
        }
      });
      
      document.getElementById('btn-roll-duration').addEventListener('click', () => {
        const roll = Math.floor(Math.random() * 4) + 1;
        const resultEl = document.getElementById('radiant-duration-result');
        resultEl.innerHTML = `= <strong>${roll} Round${roll !== 1 ? 's' : ''}</strong>`;
        document.getElementById('btn-roll-duration').disabled = true;
      });
      
      document.getElementById('btn-roll-damage').addEventListener('click', () => {
        const roll = Math.floor(Math.random() * 3) + 1;
        const resultEl = document.getElementById('radiant-damage-result');
        resultEl.innerHTML = `= <strong>${roll} damage</strong>`;
        document.getElementById('btn-roll-damage').disabled = true;
      });
    }
    
    // Reset modal state
    document.getElementById('radiant-duration-result').textContent = '';
    document.getElementById('radiant-damage-result').textContent = '';
    document.getElementById('btn-roll-duration').disabled = false;
    document.getElementById('btn-roll-damage').disabled = false;
    
    // Update POW display
    document.getElementById('radiant-pow-display').textContent = `(${powX2})`;
    
    // Show modal
    modal.classList.remove('hidden');
  },
  
  /**
   * Close Radiant Burst modal
   */
  closeRadiantBurstModal() {
    const modal = document.getElementById('radiant-burst-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Setup tooltips for ability cards showing ability descriptions
   */
  setupAbilityCardTooltips() {
    // Helper to strip HTML and format for tooltip
    const stripHtml = (html) => {
      if (!html) return '';
      return html
        .replace(/<strong>/g, '')
        .replace(/<\/strong>/g, '')
        .replace(/<br>/g, '\n')
        .replace(/<[^>]*>/g, '')
        .replace(/\n\n/g, '\n')
        .trim();
    };
    
    // Use the global AbilityDescriptions object
    const getDesc = (name) => {
      if (window.AbilityDescriptions && window.AbilityDescriptions.getDescription) {
        return window.AbilityDescriptions.getDescription(name);
      }
      return null;
    };
    
    // Berserk Rage
    const rageSection = document.getElementById('berserk-rage-section');
    if (rageSection) {
      const rageDesc = getDesc('berserk rage');
      if (rageDesc) {
        const tooltip = stripHtml(rageDesc);
        rageSection.title = tooltip;
        const rageBtn = document.getElementById('btn-rage-toggle');
        if (rageBtn) rageBtn.title = tooltip;
      }
    }
    
    // Brute Strength
    const bruteSection = document.getElementById('brute-strength-section');
    if (bruteSection) {
      const bruteDesc = getDesc('brute strength');
      if (bruteDesc) {
        const tooltip = stripHtml(bruteDesc);
        bruteSection.title = tooltip;
        const bruteBtn = document.getElementById('btn-brute-toggle');
        if (bruteBtn) bruteBtn.title = tooltip;
      }
    }
    
    // Just a Scratch
    const scratchSection = document.getElementById('just-a-scratch-section');
    if (scratchSection) {
      const scratchDesc = getDesc('just a scratch');
      if (scratchDesc) {
        const tooltip = stripHtml(scratchDesc);
        scratchSection.title = tooltip;
        const scratchBtn = document.getElementById('btn-scratch-use');
        if (scratchBtn) scratchBtn.title = tooltip;
      }
    }
    
    // Forceful Strike
    const forcefulSection = document.getElementById('forceful-strike-section');
    if (forcefulSection) {
      const forcefulDesc = getDesc('forceful strike');
      if (forcefulDesc) {
        const tooltip = stripHtml(forcefulDesc);
        forcefulSection.title = tooltip;
        const forcefulBtn = document.getElementById('btn-forceful-toggle');
        if (forcefulBtn) forcefulBtn.title = tooltip;
      }
    }
  },

  /**
   * Check if character has a specific ability
   */
  hasAbility(abilityName) {
    const normalizedName = abilityName.toLowerCase().trim();
    
    // Check class abilities
    const classAbilities = document.getElementById('class-abilities-list');
    if (classAbilities) {
      const inputs = classAbilities.querySelectorAll('.class-ability-input');
      for (const input of inputs) {
        if (input.value.toLowerCase().trim() === normalizedName) {
          return true;
        }
      }
    }
    
    // Check species abilities
    const speciesAbilities = document.getElementById('species-abilities-list');
    if (speciesAbilities) {
      const inputs = speciesAbilities.querySelectorAll('.species-ability-input');
      for (const input of inputs) {
        if (input.value.toLowerCase().trim() === normalizedName) {
          return true;
        }
      }
    }
    
    // Check acquired abilities array
    if (this.character.acquiredAbilities) {
      if (this.character.acquiredAbilities.some(a => a.toLowerCase().trim() === normalizedName)) {
        return true;
      }
    }
    
    return false;
  },

  /**
   * Check if character has spellcasting ability (based on class selection)
   */
  hasSpellcastingAbility() {
    const MAGIC_CLASSES = ['cleric', 'ranger', 'paladin', 'anti-paladin', 'druid', 'mage', 'sorcerer', 'bard'];
    
    const classes = [
      document.getElementById('class-primary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-secondary')?.value?.trim().toLowerCase() || '',
      document.getElementById('class-tertiary')?.value?.trim().toLowerCase() || ''
    ].filter(c => c);
    
    return classes.some(c => MAGIC_CLASSES.includes(c));
  },

  // ============================================
  // SPELL-LIKE ABILITIES SYSTEM
  // ============================================
  
  /**
   * Spell data for Spell-Like Abilities (Abyssar species)
   */
  SPELL_LIKE_ABILITIES_DATA: {
    'Affect Normal Fires': {
      name: 'Affect Normal Fires',
      resist: null,
      description: `The caster may command small fires to reduce in Size to that of a candle flame or grow as large as a bonfire (3' diameter maximum). This spell alters all fires within the Area of Effect. Reducing the Size of the fire will reduce fuel consumption to half normal, while increasing the fire doubles the rate of consumption. The light given off is appropriate to that of the flames' new Size, as is any damage from the flames.`
    },
    'Charm Being': {
      name: 'Charm Being',
      resist: 'Willpower',
      description: `When this spell is cast, one sapient humanoid target will cease all hostilities against the mage and the mage's allies, and instead offer to help and protect them, upon failing a roll to resist. Note that helping/protecting can have an unintended or even negative effect for the caster, as the subject acts based on what it feels is the best course of action to protect/help. Regarding commands, a target will never obey suicidal or obviously harmful actions, but might be convinced that something very dangerous is worth doing.

See the Master Spellbook for more information.`
    },
    'Detect Magic': {
      name: 'Detect Magic',
      resist: null,
      description: `When successfully cast, the mage sees a glowing blue aura surrounding any magic item or spell effect within a 10' wide and 60' long path.`
    },
    'Fear (by Touch)': {
      name: 'Fear (by Touch)',
      resist: 'Willpower',
      description: `Cause Fear requires physical contact in combat. A Failed Willpower Resistance Roll causes the victim to flee in terror at a Sprint for 1d4 Rounds, moving away from the caster. Cause Fear can be countered by Remove Fear, and vice versa.`
    },
    'Know Passions': {
      name: 'Know Passions',
      resist: 'Willpower',
      description: `This spell allows the caster to discern the Passions and Alignment of one creature. The target may make a Willpower Resistance Roll to negate the effect. On a Failed roll, the caster immediately learns the target's Alignment (Good, Neutral, or Evil). Each additional Round of Concentration reveals one more random Passion or defining trait.

The strength of any revealed Passion is determined by the Games Master using the following scale:

<table>
<tr><th>Percentage</th><th>Strength</th></tr>
<tr><td>01-29%</td><td>Weak</td></tr>
<tr><td>30-69%</td><td>Average</td></tr>
<tr><td>70-99%</td><td>Strong</td></tr>
<tr><td>100%+</td><td>Very Strong</td></tr>
</table>`
    },
    'Produce Flame': {
      name: 'Produce Flame',
      resist: 'Evade',
      description: `When cast, a bright flame appears in the caster's palm, equal in brightness to a torch. It does not harm the caster but produces heat and can ignite combustible materials such as cloth, paper, oil, and wood. At any point during the Duration, the caster may hurl the flame up to 40 feet. On impact, it bursts, igniting flammable materials within a 5-foot diameter. If the Duration continues, a new flame forms in the caster's hand. The caster may also end the Duration at will. Any fires started by the spell continue to burn naturally.

Throwing the flame requires a Successful Throw (Athletics) skill roll, and the attack may be Evaded. If the attack misses, it lands in a random direction.

Damage depends on the target's SIZ:
<ul>
<li>SIZ ≤ 20: 1d6 damage to 1d3+1 random Hit Locations.</li>
<li>SIZ 21–40: 1d6 damage to 1d2+1 contiguous Hit Locations.</li>
<li>SIZ > 40: 1d6 damage to a single Hit Location.</li>
</ul>

A successful Resistance roll halves the damage. Armor Points count as half, but magical armor applies its full Magic Bonus.

The flame may ignite flammable materials.`
    },
    'Pyrotechnics': {
      name: 'Pyrotechnics',
      resist: null,
      description: `When cast in the presence of an existing flame, this spell allows the caster to create one of two effects:

<ul>
<li><strong>Cloud of Choking Smoke:</strong> Thick, black smoke billows from the source, lasting 1 minute per point of Intensity. The smoke fills a radius equal to 100 times that of the original flame source. Example: A campfire with a 3-foot radius produces a 300-foot-radius smoke cloud. Natural vision, including Darkvision, is reduced to 2 feet. Creatures within the cloud are subject to Asphyxiation. The smoke rises freely unless confined and may be visible from far away.</li>
<li><strong>Blinding Fireworks:</strong> Colorful fireworks explode overhead, blinding those within 120 feet who fail an Evade roll. Affected creatures are blinded for 1d4+1 Rounds. The effect covers a radius equal to 10 times the original flame's radius.</li>
</ul>

The spell typically consumes the original fire source. Larger flames may be partially extinguished; magical fires are unaffected.

Flame-based entities (e.g., fire elementals) take 2d6 x Intensity damage and must pass a Willpower Resistance Roll or flee the caster for 2d4 minutes. Elemental Protection offers no defense. Pyrotechnics has no effect underwater.`
    },
    'Suggestion': {
      name: 'Suggestion',
      resist: 'Willpower',
      description: `This spell allows the caster to influence the actions of a single individual for up to 1 hour, provided the target Fails a Resistance Roll. The caster must speak a language the target understands, and the suggestion must be phrased as a sentence or two proposing a course of action desirable to the caster.

The target will not follow any suggestion that would lead to obvious harm. However, indirect or misleading suggestions – such as describing a stagnant pool of poison as a crystal-clear spring to a thirsty target – may succeed. The suggestion must be clearly stated at the time of casting. If the course of action seems especially reasonable, the Games Master may rule that the Resistance Roll is one Difficulty Grade harder.`
    }
  },

  /**
   * Get available spell-like ability choices
   */
  getSpellLikeAbilityChoices() {
    return Object.keys(this.SPELL_LIKE_ABILITIES_DATA);
  },

  /**
   * Prompt user to select their Spell-Like Ability
   */
  promptSpellLikeAbilitySelection() {
    const choices = this.getSpellLikeAbilityChoices();
    
    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay spell-like-modal-overlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
    `;
    
    const modal = document.createElement('div');
    modal.className = 'spell-like-modal';
    modal.style.cssText = `
      background: linear-gradient(135deg, #1a1a2a 0%, #2d203d 100%);
      border: 2px solid #8b4a8b;
      border-radius: 12px;
      padding: 1.5rem;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 0 30px rgba(139, 74, 139, 0.5);
    `;
    
    modal.innerHTML = `
      <h3 style="color: #d8a8d8; margin: 0 0 1rem 0; text-align: center; text-shadow: 0 0 10px rgba(187, 102, 187, 0.5);">
        Choose Your Spell-Like Ability
      </h3>
      <p style="color: #aaa; margin-bottom: 1rem; text-align: center; font-size: 0.9rem;">
        As an Abyssar, you have an innate magical ability. Choose wisely!
      </p>
      <div class="spell-choices" style="display: flex; flex-direction: column; gap: 0.5rem;">
        ${choices.map(spell => `
          <button type="button" class="spell-choice-btn" data-spell="${spell}" style="
            background: linear-gradient(135deg, #2a2a3a 0%, #3d2d4d 100%);
            border: 1px solid #6b4a6b;
            color: #ddd;
            padding: 0.75rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            text-align: left;
            transition: all 0.2s ease;
          ">${spell}</button>
        `).join('')}
      </div>
    `;
    
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    
    // Add hover effects and click handlers
    const buttons = modal.querySelectorAll('.spell-choice-btn');
    buttons.forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.background = 'linear-gradient(135deg, #3a3a4a 0%, #4d3d5d 100%)';
        btn.style.borderColor = '#8b6a8b';
        btn.style.transform = 'translateX(5px)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = 'linear-gradient(135deg, #2a2a3a 0%, #3d2d4d 100%)';
        btn.style.borderColor = '#6b4a6b';
        btn.style.transform = 'translateX(0)';
      });
      btn.addEventListener('click', () => {
        const selectedSpell = btn.dataset.spell;
        this.setSpellLikeAbility(selectedSpell);
        document.body.removeChild(overlay);
      });
    });
    
    // Close on overlay click (outside modal)
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        // Don't close - force selection
      }
    });
  },

  /**
   * Set the selected Spell-Like Ability
   */
  setSpellLikeAbility(spellName) {
    // Find the Spell-Like Abilities input in species abilities
    const container = document.getElementById('species-abilities-list');
    if (!container) return;
    
    const inputs = container.querySelectorAll('.species-ability-input');
    for (const input of inputs) {
      const baseName = input.value.split('(')[0].trim().toLowerCase();
      if (baseName === 'spell-like abilities') {
        // Update the input value with the selected spell
        input.value = `Spell-Like Abilities (${spellName})`;
        input.dataset.abilityName = `Spell-Like Abilities (${spellName})`;
        break;
      }
    }
    
    // Update the spell info section
    this.updateSpellLikeSection(spellName);
    
    this.scheduleAutoSave();
  },

  /**
   * Check if character has Spell-Like Abilities and show/hide section
   */
  checkSpellLikeAbilitiesVisibility() {
    const section = document.getElementById('spell-like-section');
    const divider = document.getElementById('spell-like-divider');
    if (!section) return;
    
    // Check species abilities for Spell-Like Abilities
    const container = document.getElementById('species-abilities-list');
    if (!container) {
      section.style.display = 'none';
      if (divider) divider.style.display = 'none';
      return;
    }
    
    let spellName = null;
    const inputs = container.querySelectorAll('.species-ability-input');
    for (const input of inputs) {
      const value = input.value.trim();
      if (value.toLowerCase().startsWith('spell-like abilities')) {
        // Extract spell name from parentheses if present
        const match = value.match(/\(([^)]+)\)/);
        if (match) {
          spellName = match[1];
        }
        break;
      }
    }
    
    if (spellName && this.SPELL_LIKE_ABILITIES_DATA[spellName]) {
      section.style.display = '';
      if (divider) divider.style.display = '';
      this.updateSpellLikeSection(spellName);
    } else {
      section.style.display = 'none';
      if (divider) divider.style.display = 'none';
    }
  },

  /**
   * Update the Spell-Like Abilities info section
   */
  updateSpellLikeSection(spellName) {
    const section = document.getElementById('spell-like-section');
    const divider = document.getElementById('spell-like-divider');
    const titleEl = document.getElementById('spell-like-title');
    const descEl = document.getElementById('spell-like-description');
    
    if (!section || !titleEl || !descEl) return;
    
    const spellData = this.SPELL_LIKE_ABILITIES_DATA[spellName];
    if (!spellData) {
      section.style.display = 'none';
      if (divider) divider.style.display = 'none';
      return;
    }
    
    section.style.display = '';
    if (divider) divider.style.display = '';
    titleEl.textContent = spellData.name;
    
    let html = `<span class="spell-name">${spellData.name}</span>`;
    if (spellData.resist) {
      html += `<span class="spell-resist">Resist: ${spellData.resist}</span>`;
    }
    html += `<div class="spell-text">${spellData.description.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>')}</div>`;
    
    descEl.innerHTML = html;
    
    // Setup toggle if not already done
    this.setupSpellLikeToggle();
  },

  /**
   * Setup the spell-like abilities collapse/expand toggle
   */
  setupSpellLikeToggle() {
    const toggleBtn = document.getElementById('spell-like-toggle');
    const content = document.getElementById('spell-like-content');
    
    if (!toggleBtn || !content) return;
    
    // Only add listener once
    if (toggleBtn.dataset.listenerAdded) return;
    toggleBtn.dataset.listenerAdded = 'true';
    
    // Restore collapsed state from character data
    if (this.character.spellLikeCollapsed) {
      toggleBtn.classList.add('collapsed');
      content.classList.add('collapsed');
    }
    
    toggleBtn.addEventListener('click', () => {
      const isCollapsed = toggleBtn.classList.toggle('collapsed');
      content.classList.toggle('collapsed');
      
      // Save state
      this.character.spellLikeCollapsed = isCollapsed;
      this.scheduleAutoSave();
    });
  },

  // ============================================
  // WEAPON SPECIALIZATION SYSTEM
  // ============================================

  /**
   * Curated weapon lists for specialization selection
   */
  WEAPON_SPEC_MELEE_WEAPONS: [
    'Ball & Chain', 'Bastard Sword', 'Battle Axe', 'Bo Stick', 'Broadsword',
    'Chain', 'Club', 'Dagger', 'Falchion', 'Flail', 'Heavy Flail',
    'Garrote', 'Glaive', 'Great Axe', 'Great Club', 'Great Hammer',
    'Great Sword', 'Halberd', 'Hand Axe', 'Hatchet',
    "Horseman's Flail", "Horseman's Mace", "Horseman's Military Pick",
    'Jo Stick', 'Knife', 'Lance', 'Long Spear', 'Longsword',
    'Main Gauche', 'Mace', 'Heavy Mace', 'Military Flail',
    'Military Pick', 'Heavy Military Pick', 'Morning Star',
    'Net', 'Pike', 'Polearm', 'Quarterstaff', 'Rapier',
    'Rhomphaia', 'Sabre', 'Sarissa', 'Scimitar',
    'Short Spear', 'Shortsword', 'Sickle', 'Trident',
    'War Hammer', 'Whip', 'Xyston'
  ],

  WEAPON_SPEC_RANGED_WEAPONS: [
    'Arbalest', 'Atlatl', 'Blowgun', 'Bolas',
    'Composite Long Bow', 'Composite Short Bow',
    'Dagger (Thrown)', 'Dart', 'Discus',
    'Hand Crossbow', 'Hatchet (Thrown)', 'Heavy Crossbow',
    'Repeating Heavy Crossbow', 'Javelin',
    'Light Crossbow', 'Repeating Light Crossbow',
    'Long Bow', 'Net', 'Recurve Bow',
    'Short Bow', 'Sling', 'Staff Sling',
    'Throwing Axe', 'Throwing Knife', 'Trident (Thrown)'
  ],

  /**
   * Get the benefit description for a weapon specialization type
   */
  getWeaponSpecBenefits(type) {
    switch (type) {
      case 'Melee':
        return {
          icon: '⚔️',
          benefits: [
            { label: 'Combat Skill Bonus', text: 'Your Combat Skill is improved by +5% when using your weapon of specialization. This bonus will not aid in Rank advancement.' },
            { label: 'Parry Bonus', text: 'You gain +1 Action Point for the purposes of Parrying only when wielding this weapon.' }
          ]
        };
      case 'Ranged':
        return {
          icon: '🏹',
          benefits: [
            { label: 'Quick Shot', text: 'If you are not surprised, you may automatically fire first at the start of combat (before rolling for Initiative), provided your weapon and ammunition are readied.' },
            { label: 'Improved Aim', text: "When targeting an enemy within the weapon's Close Range, aiming requires only 1 Turn to steady the weapon instead of a full Round. The next attack is one Difficulty Grade easier." },
            { label: 'Reduced Reload Time', text: "You reduce the Reload time of your specialized weapon by 1. If the weapon's Reload time is reduced to 0, it can be readied as a Free Action." }
          ]
        };
      case 'Shield':
        return {
          icon: '🛡️',
          benefits: [
            { label: 'Improved Combat Skill', text: 'Your Combat Skill when using any shield is increased by +5%. This bonus does not contribute to Rank advancement.' },
            { label: 'Enhanced Parrying', text: 'All shields you wield count as one Size category larger for the purpose of Parrying damage. For example, a Large shield counts as Huge, a Huge shield counts as Enormous, and an Enormous shield counts as Colossal.' }
          ]
        };
      case 'Dual Weapon':
        return {
          icon: '⚔️',
          benefits: [
            { label: 'Dual Wield Without Penalty', text: 'You may wield a melee weapon in each hand without penalty. The usual restriction that the offhand weapon must be shorter does not apply, though many rangers prefer a shorter offhand weapon for versatility. Alternatively, your offhand "weapon" may be a shield.' },
            { label: 'Extra Action Point', text: 'When wielding two weapons, you gain an extra Action Point, which may be used in one of two ways:' },
            { label: '• Parry', text: 'Use the extra Action Point to Parry one additional attack.' },
            { label: '• Bonus Attack', text: 'Use the extra Action Point to make one additional attack with your offhand weapon. This attack suffers no penalty and may achieve any Special Effect allowed by your main hand weapon.' }
          ]
        };
      case 'Ranger Ranged':
        return {
          icon: '🏹',
          benefits: [
            { label: 'Quick Shot', text: 'If you are not surprised, you may automatically fire first at the beginning of combat, before rolling for Initiative, provided your weapon and ammo are readied.' },
            { label: 'Improved Aim', text: "When attacking a target within the weapon's Effective Range, Aiming requires only 1 Turn to steady the weapon, rather than a full Round, and makes the following attack 1 Difficulty Grade easier. Attacks beyond Effective Range follow the standard aiming rules." },
            { label: 'Critical Strike', text: 'Your Critical chance is improved to 1/5th of your final modified skill (20%, or Skill ×0.2) instead of the usual 1/10th.' },
            { label: 'Faster Reload', text: 'You may reduce the Reload time of any ranged weapon by 2. If the weapon\'s Reload time is reduced to 0, it can be readied as a Free Action.' }
          ]
        };
      default:
        return null;
    }
  },

  /**
   * Prompt ranger to select Dual Weapon or Ranged specialization
   * Unlike the normal weapon spec, this doesn't require choosing a specific weapon
   */
  promptRangerWeaponSpecialization(abilityInput) {
    if (this._weaponSpecPromptOpen) return;
    if (this._weaponSpecPromptCooldown && Date.now() - this._weaponSpecPromptCooldown < 500) return;
    this._weaponSpecPromptOpen = true;

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay weapon-spec-modal-overlay';
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8); display: flex; justify-content: center;
      align-items: center; z-index: 10000;
    `;

    const modal = document.createElement('div');
    modal.className = 'weapon-spec-modal';
    modal.style.cssText = `
      background: linear-gradient(135deg, #1a2a1a 0%, #2d3a1d 100%);
      border: 2px solid #5a8a3a; border-radius: 12px;
      padding: 1.5rem; max-width: 460px; width: 90%;
      box-shadow: 0 0 30px rgba(90, 138, 58, 0.3); max-height: 85vh; overflow-y: auto;
    `;

    modal.innerHTML = `
      <h3 style="color: #7dcc7d; margin: 0 0 0.5rem 0; text-align: center;">
        🏹 Ranger Weapon Specialization
      </h3>
      <p style="color: #aaa; margin-bottom: 0.75rem; text-align: center; font-size: 0.82rem;">
        This choice defines the rest of your career. Choose carefully:
      </p>
      <div style="display: flex; flex-direction: column; gap: 0.6rem;">
        <button type="button" class="ranger-spec-btn" data-type="Dual Weapon" style="
          background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
          border: 1px solid rgba(90, 138, 58, 0.3); color: #ddd;
          padding: 0.75rem 1rem; border-radius: 6px; cursor: pointer;
          text-align: left; transition: all 0.2s ease; font-size: 0.85rem;
        ">
          <strong style="color:#c9a55a;">⚔️ Dual Weapon Specialization</strong><br>
          <span style="font-size:0.75rem;color:#999;">Wield two weapons without penalty. Gain +1 AP for Parry or bonus offhand attack.</span>
        </button>
        <button type="button" class="ranger-spec-btn" data-type="Ranger Ranged" style="
          background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
          border: 1px solid rgba(90, 138, 58, 0.3); color: #ddd;
          padding: 0.75rem 1rem; border-radius: 6px; cursor: pointer;
          text-align: left; transition: all 0.2s ease; font-size: 0.85rem;
        ">
          <strong style="color:#c9a55a;">🏹 Ranged Weapon Specialization</strong><br>
          <span style="font-size:0.75rem;color:#999;">Quick Shot, Improved Aim, Critical Strike (1/5th skill), Faster Reload (−2). All ranged weapons.</span>
        </button>
      </div>
      <div style="text-align: center; margin-top: 0.75rem;">
        <button type="button" class="spec-cancel-btn" style="
          background: transparent; border: 1px solid #666; color: #999;
          padding: 0.4rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;
        ">Cancel</button>
      </div>
    `;

    // Hover effects
    modal.querySelectorAll('.ranger-spec-btn').forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.borderColor = 'rgba(90, 138, 58, 0.6)';
        btn.style.transform = 'translateX(5px)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.borderColor = 'rgba(90, 138, 58, 0.3)';
        btn.style.transform = 'translateX(0)';
      });
      btn.addEventListener('click', () => {
        const type = btn.dataset.type;
        this._finalizeRangerWeaponSpec(overlay, abilityInput, type);
      });
    });

    // Cancel
    modal.querySelector('.spec-cancel-btn').addEventListener('click', () => {
      this._weaponSpecPromptOpen = false;
      this._weaponSpecPromptCooldown = Date.now();
      if (abilityInput) {
        const row = abilityInput.closest('.class-ability-row');
        if (row) row.remove();
        this.reindexClassAbilityRows();
        this.syncClassAbilitiesToCharacter();
      }
      document.body.removeChild(overlay);
    });

    overlay.appendChild(modal);
    document.body.appendChild(overlay);
  },

  /**
   * Finalize the ranger weapon specialization choice
   */
  _finalizeRangerWeaponSpec(overlay, abilityInput, type) {
    this._weaponSpecPromptOpen = false;
    this._weaponSpecPromptCooldown = Date.now();

    const displayName = type === 'Dual Weapon'
      ? 'Weapon Specialization (Dual Weapon)'
      : 'Weapon Specialization (Ranged)';
    const weaponName = type === 'Dual Weapon' ? 'Dual Weapon' : 'All Ranged Weapons';

    // Update the ability input
    if (abilityInput) {
      abilityInput.value = displayName;
      abilityInput.dataset.previousValue = displayName;
      const row = abilityInput.closest('.class-ability-row');
      if (row) {
        const infoBtn = row.querySelector('.class-ability-info-btn');
        if (infoBtn) infoBtn.style.display = '';
      }
    }

    // Save to character data
    if (!this.character.weaponSpecializations) {
      this.character.weaponSpecializations = [];
    }
    const exists = this.character.weaponSpecializations.some(
      s => s.type === type && s.weapon === weaponName
    );
    if (!exists) {
      this.character.weaponSpecializations.push({ type, weapon: weaponName });
    }

    // Store the ranger-specific choice
    this.character.rangerWeaponSpecType = type;

    // Close overlay
    document.body.removeChild(overlay);

    // Update UI
    this.checkWeaponSpecVisibility();
    this.syncClassAbilitiesToCharacter();
    this.scheduleAutoSave();
  },

  /**
   * Prompt user to select their Weapon Specialization
   * Two-step modal: 1) Choose type (Melee/Ranged/Shield) 2) Choose specific weapon
   * @param {HTMLElement} abilityInput - The class ability input that triggered this
   */
  promptWeaponSpecialization(abilityInput) {
    // Prevent double-prompting with cooldown
    if (this._weaponSpecPromptOpen) return;
    if (this._weaponSpecPromptCooldown && Date.now() - this._weaponSpecPromptCooldown < 500) return;
    this._weaponSpecPromptOpen = true;
    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay weapon-spec-modal-overlay';
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8); display: flex; justify-content: center;
      align-items: center; z-index: 10000;
    `;

    const modal = document.createElement('div');
    modal.className = 'weapon-spec-modal';
    modal.style.cssText = `
      background: linear-gradient(135deg, #1a1a2a 0%, #2d2a1d 100%);
      border: 2px solid var(--accent-color, #c9a55a); border-radius: 12px;
      padding: 1.5rem; max-width: 420px; width: 90%;
      box-shadow: 0 0 30px rgba(201, 165, 90, 0.3); max-height: 80vh; overflow-y: auto;
    `;

    // Step 1: Choose type
    this._renderWeaponSpecStep1(modal, overlay, abilityInput);

    overlay.appendChild(modal);
    document.body.appendChild(overlay);
  },

  /**
   * Render Step 1: Choose specialization type
   */
  _renderWeaponSpecStep1(modal, overlay, abilityInput) {
    modal.innerHTML = `
      <h3 style="color: var(--accent-color, #c9a55a); margin: 0 0 0.5rem 0; text-align: center;">
        Weapon Specialization
      </h3>
      <p style="color: #aaa; margin-bottom: 1rem; text-align: center; font-size: 0.85rem;">
        Choose your specialization type:
      </p>
      <div class="spec-type-choices" style="display: flex; flex-direction: column; gap: 0.5rem;">
        <button type="button" class="spec-type-btn" data-type="Melee" style="
          background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
          border: 1px solid rgba(201, 165, 90, 0.3); color: #ddd;
          padding: 0.75rem 1rem; border-radius: 6px; cursor: pointer;
          text-align: left; transition: all 0.2s ease; font-size: 0.9rem;
        ">⚔️ <strong>Melee Weapon</strong><br><span style="font-size:0.75rem;color:#999;">+5% Combat Skill &amp; +1 AP for Parrying with chosen weapon</span></button>
        <button type="button" class="spec-type-btn" data-type="Ranged" style="
          background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
          border: 1px solid rgba(201, 165, 90, 0.3); color: #ddd;
          padding: 0.75rem 1rem; border-radius: 6px; cursor: pointer;
          text-align: left; transition: all 0.2s ease; font-size: 0.9rem;
        ">🏹 <strong>Ranged Weapon</strong><br><span style="font-size:0.75rem;color:#999;">Quick Shot, Improved Aim, &amp; Reduced Reload Time</span></button>
        <button type="button" class="spec-type-btn" data-type="Shield" style="
          background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
          border: 1px solid rgba(201, 165, 90, 0.3); color: #ddd;
          padding: 0.75rem 1rem; border-radius: 6px; cursor: pointer;
          text-align: left; transition: all 0.2s ease; font-size: 0.9rem;
        ">🛡️ <strong>Shield</strong><br><span style="font-size:0.75rem;color:#999;">+5% Combat Skill &amp; shields count as one Size larger for Parrying</span></button>
      </div>
      <div style="text-align: center; margin-top: 0.75rem;">
        <button type="button" class="spec-cancel-btn" style="
          background: transparent; border: 1px solid #666; color: #999;
          padding: 0.4rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;
        ">Cancel</button>
      </div>
    `;

    // Add hover effects
    modal.querySelectorAll('.spec-type-btn').forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.borderColor = 'rgba(201, 165, 90, 0.6)';
        btn.style.transform = 'translateX(5px)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.borderColor = 'rgba(201, 165, 90, 0.3)';
        btn.style.transform = 'translateX(0)';
      });
      btn.addEventListener('click', () => {
        const type = btn.dataset.type;
        if (type === 'Shield') {
          // Shield applies to all shields — no specific weapon choice needed
          this._finalizeWeaponSpec(overlay, abilityInput, 'Shield', 'Shield');
        } else {
          this._renderWeaponSpecStep2(modal, overlay, abilityInput, type);
        }
      });
    });

    // Cancel button
    modal.querySelector('.spec-cancel-btn').addEventListener('click', () => {
      this._weaponSpecPromptOpen = false;
      this._weaponSpecPromptCooldown = Date.now();
      // Remove the ability row if it was just added
      if (abilityInput) {
        const row = abilityInput.closest('.class-ability-row');
        if (row) row.remove();
        this.reindexClassAbilityRows();
        this.syncClassAbilitiesToCharacter();
      }
      document.body.removeChild(overlay);
    });
  },

  /**
   * Render Step 2: Choose specific weapon
   */
  _renderWeaponSpecStep2(modal, overlay, abilityInput, type) {
    const weapons = type === 'Melee' ? this.WEAPON_SPEC_MELEE_WEAPONS : this.WEAPON_SPEC_RANGED_WEAPONS;
    const icon = type === 'Melee' ? '⚔️' : '🏹';

    // Check already-specialized weapons to prevent duplicates
    const existingSpecs = (this.character.weaponSpecializations || [])
      .filter(s => s.type === type)
      .map(s => s.weapon.toLowerCase());

    const availableWeapons = weapons.filter(w => !existingSpecs.includes(w.toLowerCase()));

    modal.innerHTML = `
      <h3 style="color: var(--accent-color, #c9a55a); margin: 0 0 0.5rem 0; text-align: center;">
        ${icon} Choose ${type} Weapon
      </h3>
      <p style="color: #aaa; margin-bottom: 0.75rem; text-align: center; font-size: 0.85rem;">
        Select a weapon to specialize in:
      </p>
      <div class="weapon-search-wrapper" style="margin-bottom: 0.5rem;">
        <input type="text" class="weapon-spec-search" placeholder="Search weapons..." style="
          width: 100%; padding: 0.5rem; background: rgba(255,255,255,0.05);
          border: 1px solid rgba(201, 165, 90, 0.3); border-radius: 4px;
          color: #ddd; font-size: 0.85rem; box-sizing: border-box;
        ">
      </div>
      <div class="weapon-list" style="
        display: flex; flex-direction: column; gap: 0.25rem;
        max-height: 45vh; overflow-y: auto; padding-right: 0.25rem;
      ">
        ${availableWeapons.map(weapon => `
          <button type="button" class="weapon-choice-btn" data-weapon="${weapon}" style="
            background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
            border: 1px solid rgba(201, 165, 90, 0.15); color: #ddd;
            padding: 0.5rem 0.75rem; border-radius: 4px; cursor: pointer;
            text-align: left; transition: all 0.2s ease; font-size: 0.85rem;
          ">${weapon}</button>
        `).join('')}
      </div>
      <div style="text-align: center; margin-top: 0.75rem;">
        <button type="button" class="spec-back-btn" style="
          background: transparent; border: 1px solid #666; color: #999;
          padding: 0.4rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;
          margin-right: 0.5rem;
        ">← Back</button>
        <button type="button" class="spec-cancel-btn" style="
          background: transparent; border: 1px solid #666; color: #999;
          padding: 0.4rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;
        ">Cancel</button>
      </div>
    `;

    // Search filter
    const searchInput = modal.querySelector('.weapon-spec-search');
    const weaponBtns = modal.querySelectorAll('.weapon-choice-btn');
    searchInput.addEventListener('input', () => {
      const filter = searchInput.value.toLowerCase();
      weaponBtns.forEach(btn => {
        btn.style.display = btn.dataset.weapon.toLowerCase().includes(filter) ? '' : 'none';
      });
    });
    searchInput.focus();

    // Weapon hover + click
    weaponBtns.forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.borderColor = 'rgba(201, 165, 90, 0.5)';
        btn.style.background = 'linear-gradient(135deg, #3a3a4a 0%, #4d4a3d 100%)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.borderColor = 'rgba(201, 165, 90, 0.15)';
        btn.style.background = 'linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%)';
      });
      btn.addEventListener('click', () => {
        this._finalizeWeaponSpec(overlay, abilityInput, type, btn.dataset.weapon);
      });
    });

    // Back button
    modal.querySelector('.spec-back-btn').addEventListener('click', () => {
      this._renderWeaponSpecStep1(modal, overlay, abilityInput);
    });

    // Cancel button
    modal.querySelector('.spec-cancel-btn').addEventListener('click', () => {
      this._weaponSpecPromptOpen = false;
      this._weaponSpecPromptCooldown = Date.now();
      if (abilityInput) {
        const row = abilityInput.closest('.class-ability-row');
        if (row) row.remove();
        this.reindexClassAbilityRows();
        this.syncClassAbilitiesToCharacter();
      }
      document.body.removeChild(overlay);
    });
  },

  /**
   * Finalize the weapon specialization selection
   */
  _finalizeWeaponSpec(overlay, abilityInput, type, weapon) {
    this._weaponSpecPromptOpen = false;
    this._weaponSpecPromptCooldown = Date.now();
    // Build the display name
    const displayName = type === 'Shield'
      ? 'Weapon Specialization (Shield)'
      : `Weapon Specialization (${weapon})`;

    // Update the ability input
    if (abilityInput) {
      abilityInput.value = displayName;
      abilityInput.dataset.previousValue = displayName;
      // Show info button
      const row = abilityInput.closest('.class-ability-row');
      if (row) {
        const infoBtn = row.querySelector('.class-ability-info-btn');
        if (infoBtn) infoBtn.style.display = '';
      }
    }

    // Save to character data
    if (!this.character.weaponSpecializations) {
      this.character.weaponSpecializations = [];
    }

    // Check for duplicate
    const exists = this.character.weaponSpecializations.some(
      s => s.type === type && s.weapon.toLowerCase() === weapon.toLowerCase()
    );
    if (!exists) {
      this.character.weaponSpecializations.push({ type, weapon });
    }

    // Close overlay
    document.body.removeChild(overlay);

    // Update UI
    this.checkWeaponSpecVisibility();
    this.highlightSpecializedWeapons();
    this.syncClassAbilitiesToCharacter();
    
    this.scheduleAutoSave();
  },

  /**
   * Check if character has any Weapon Specialization and show/hide the section
   */
  checkWeaponSpecVisibility() {
    const section = document.getElementById('weapon-spec-section');
    const divider = document.getElementById('weapon-spec-divider');
    if (!section) return;

    // Scan class abilities for any "Weapon Specialization (...)" entries
    const specs = this._getWeaponSpecsFromAbilities();

    if (specs.length > 0) {
      section.style.display = '';
      if (divider) divider.style.display = '';
      // Sync to character data
      this.character.weaponSpecializations = specs;
      this.updateWeaponSpecDisplay();
      this.setupWeaponSpecToggle();
    } else {
      section.style.display = 'none';
      if (divider) divider.style.display = 'none';
      // Clean up active weapon spec if specs removed
      if ((this.character.activeWeaponSpecs || []).length > 0) {
        this.deactivateWeaponSpec();
      }
      // Restore ranged load values
      this.restoreRangedLoadValues();
      this.character.weaponSpecializations = [];
    }

    this.highlightSpecializedWeapons();
  },

  /**
   * Parse weapon specializations from the class abilities list
   */
  _getWeaponSpecsFromAbilities() {
    const specs = [];
    const container = document.getElementById('class-abilities-list');
    if (!container) return specs;

    const inputs = container.querySelectorAll('.class-ability-input');
    for (const input of inputs) {
      const value = input.value.trim();
      const match = value.match(/^Weapon Specialization\s*\(([^)]+)\)/i);
      if (match) {
        const innerVal = match[1].trim();
        const innerLower = innerVal.toLowerCase();
        if (innerLower === 'shield') {
          specs.push({ type: 'Shield', weapon: 'Shield' });
        } else if (innerLower === 'dual weapon') {
          specs.push({ type: 'Dual Weapon', weapon: 'Dual Weapon' });
        } else if (innerLower === 'ranged' && this.getCurrentClasses().includes('ranger')) {
          // Ranger's broad ranged spec (all ranged weapons)
          specs.push({ type: 'Ranger Ranged', weapon: 'All Ranged Weapons' });
        } else if (this.WEAPON_SPEC_RANGED_WEAPONS.some(w => w.toLowerCase() === innerLower)) {
          specs.push({ type: 'Ranged', weapon: innerVal });
        } else {
          specs.push({ type: 'Melee', weapon: innerVal });
        }
      }
    }
    return specs;
  },

  /**
   * Render the weapon specialization info cards
   */
  updateWeaponSpecDisplay() {
    const cardsContainer = document.getElementById('weapon-spec-cards');
    if (!cardsContainer) return;

    const specs = this.character.weaponSpecializations || [];
    if (specs.length === 0) {
      cardsContainer.innerHTML = '';
      return;
    }

    const wm = this.character.weaponMaster;
    const activeSpecs = this.character.activeWeaponSpecs || [];

    // Validate active specs still exist
    if (activeSpecs.length > 0) {
      const validSpecs = activeSpecs.filter(key => {
        const [bonusWeapon, bonusType] = key.split('|');
        return specs.some(s => s.weapon === bonusWeapon && s.type === bonusType);
      });
      if (validSpecs.length !== activeSpecs.length) {
        this.character.activeWeaponSpecs = validSpecs;
        if (validSpecs.length === 0) {
          this.deactivateWeaponSpec();
        }
      }
    }

    let html = '';
    for (const spec of specs) {
      const benefitData = this.getWeaponSpecBenefits(spec.type);
      if (!benefitData) continue;

      const title = spec.type === 'Shield' ? 'Shield Specialization'
        : spec.type === 'Dual Weapon' ? 'Dual Weapon Specialization'
        : spec.type === 'Ranger Ranged' ? 'Ranged Weapon Specialization'
        : spec.weapon;
      const isMeleeOrShield = spec.type === 'Melee' || spec.type === 'Shield';
      const isRangerSpec = spec.type === 'Dual Weapon' || spec.type === 'Ranger Ranged';

      // Determine if this weapon is the mastered weapon
      const isMastered = wm && wm.weapon &&
        wm.weapon.toLowerCase() === spec.weapon.toLowerCase() &&
        wm.type === spec.type;

      // Determine button tier data
      const tierData = (isMastered && wm.tier) ? (this.WEAPON_MASTER_TIERS[wm.tier] || this.WEAPON_MASTER_TIERS.master) : null;

      // Show button for melee/shield always, ranged only if mastered
      // Ranger specs (Dual Weapon/Ranger Ranged) are always-on passives — no toggle
      const showButton = !isRangerSpec && (isMeleeOrShield || isMastered);

      // Button label and icon
      let btnLabel, btnIcon, btnColor, btnGlow;
      if (isMastered && tierData) {
        btnLabel = tierData.label;
        btnIcon = tierData.icon;
        btnColor = tierData.color;
        btnGlow = tierData.glowColor;
      } else {
        btnLabel = 'Weapon Specialization';
        btnIcon = isMeleeOrShield ? '\u2694\uFE0F' : '\uD83C\uDFF9';
        btnColor = '#c9a55a';
        btnGlow = 'rgba(201, 165, 90, 0.6)';
      }

      const specKey = `${spec.weapon}|${spec.type}`;
      const isActive = activeSpecs.includes(specKey);

      const buttonHtml = showButton ? `
        <button type="button" class="weapon-spec-activate-btn${isActive ? ' ws-active' : ''}"
          data-action="toggle-spec" data-weapon="${spec.weapon}" data-type="${spec.type}"
          title="${isActive ? 'Click to deactivate' : 'Click to activate: ' + btnLabel}"
          style="
            padding: 0.25rem 0.55rem; border-radius: 4px; cursor: pointer;
            font-size: 0.72rem; transition: all 0.3s ease; font-weight: 600;
            letter-spacing: 0.3px; white-space: nowrap;
            background: ${isActive ? `linear-gradient(135deg, ${btnColor}22, ${btnColor}44)` : 'linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%)'};
            border: 1px solid ${isActive ? btnColor : 'rgba(201, 165, 90, 0.25)'};
            color: ${isActive ? btnColor : '#888'};
            box-shadow: ${isActive ? `0 0 10px ${btnGlow}` : 'none'};
          ">
          ${btnIcon} ${btnLabel}${isActive ? ' \u2726' : ''}
        </button>
      ` : '';

      const masteredClass = isMastered ? ' weapon-mastered' : '';
      const masteredBorder = (isMastered && tierData) ? `border-color: ${tierData.color}; box-shadow: 0 0 8px ${tierData.glowColor};` : '';

      // Build cumulative benefits text for mastered weapons
      let masteryBenefitsHtml = '';
      if (isMastered && tierData) {
        const weaponType = spec.type === 'Ranged' ? 'ranged' : 'melee';
        // Show benefits for current tier and all below
        const tierOrder = ['master', 'high', 'grand', 'legendary'];
        const currentTierIdx = tierOrder.indexOf(wm.tier);
        const benefitLines = [];
        for (let i = 0; i <= currentTierIdx; i++) {
          const t = this.WEAPON_MASTER_TIERS[tierOrder[i]];
          let benefitText = t.benefits[weaponType];
          
          // Weapon-specific text for Legendary ranged
          if (tierOrder[i] === 'legendary' && weaponType === 'ranged') {
            const wmCategory = this._getWeaponMasterCategory(spec.weapon);
            if (wmCategory === 'crossbow') {
              benefitText = '+ Reduce Reload by 1 additional point. If Reload reaches 0, weapon readied as Free Action.';
            } else if (wmCategory === 'bow') {
              benefitText = '+ Fire 2 arrows at 1 Grade harder (−20% CS), or 3 arrows at 2 Grades harder (−40% CS). Close Range only. Targets within 5 ft of each other.';
            } else if (wmCategory === 'slinger') {
              const projName = spec.weapon.toLowerCase().includes('sling') ? 'stones/bullets' : 'knives/daggers';
              benefitText = `+ Hurl 2 ${projName} at 1 Grade harder (−20% CS), or 3 at 2 Grades harder (−40% CS). Close Range only. Targets within 5 ft of each other.`;
            }
          }
          
          // Weapon-specific text for Grand Master ranged
          if (tierOrder[i] === 'grand' && weaponType === 'ranged') {
            benefitText = '+ Reduce Reload time by 1 additional point. If Reload reaches 0, weapon readied as Free Action.';
          }
          
          benefitLines.push(`<strong>${t.label}:</strong> ${benefitText}`);
        }

        // Show active multi-shot status if applicable
        const multiShot = this.character.legendaryMultiShot;
        if (multiShot && multiShot.count > 1 && wm.tier === 'legendary' && weaponType === 'ranged') {
          const wmCategory = this._getWeaponMasterCategory(spec.weapon);
          if (wmCategory === 'bow' || wmCategory === 'slinger') {
            benefitLines.push(`<span style="color: #ff6b6b;">⚡ Active: ${multiShot.count} projectiles (CS ${multiShot.csPenalty}%)</span>`);
          }
        }

        masteryBenefitsHtml = `
          <div class="benefit-item wm-benefit" style="color: ${tierData.color}; margin-top: 0.3rem; border-top: 1px solid ${tierData.color}33; padding-top: 0.3rem; font-size: 0.78rem;">
            ${benefitLines.join('<br>')}
          </div>
        `;
      }

      html += `
        <div class="weapon-spec-card${masteredClass}" style="${masteredBorder}">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">${benefitData.icon}</span>
            <span class="weapon-spec-card-title">${title}</span>
            <span class="weapon-spec-card-buttons">
              ${buttonHtml}
            </span>
            <span class="weapon-spec-card-type">${spec.type}</span>
          </div>
          <div class="weapon-spec-card-benefits">
            ${benefitData.benefits.map(b => `
              <div class="benefit-item">
                <strong>${b.label}:</strong> ${b.text}
              </div>
            `).join('')}
            ${masteryBenefitsHtml}
          </div>
        </div>
      `;
    }

    cardsContainer.innerHTML = html;

    // Show "Choose Weapon Master" prompt if they have the ability but haven't chosen
    const hasWmAbility = this.hasAbility('Weapon Master');
    const nonShieldSpecs = specs.filter(s => s.type !== 'Shield');
    if (hasWmAbility && (!wm || !wm.weapon) && nonShieldSpecs.length > 0) {
      const promptDiv = document.createElement('div');
      promptDiv.style.cssText = `
        text-align: center; padding: 0.6rem; margin-top: 0.5rem;
        background: linear-gradient(135deg, rgba(201, 165, 90, 0.08), rgba(201, 165, 90, 0.15));
        border: 1px dashed rgba(201, 165, 90, 0.4); border-radius: 6px;
      `;
      promptDiv.innerHTML = `
        <div style="color: #c9a55a; font-size: 0.85rem; margin-bottom: 0.3rem;">
          \u2694\uFE0F You've earned <strong>Weapon Master</strong>!
        </div>
        <button type="button" id="wm-choose-btn" style="
          background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
          border: 1px solid #c9a55a; color: #c9a55a; padding: 0.4rem 0.8rem;
          border-radius: 4px; cursor: pointer; font-size: 0.8rem;
          transition: all 0.2s ease;
        ">Choose Your Weapon Master</button>
      `;
      cardsContainer.appendChild(promptDiv);

      const chooseBtn = document.getElementById('wm-choose-btn');
      if (chooseBtn) {
        chooseBtn.addEventListener('mouseenter', () => {
          chooseBtn.style.background = 'linear-gradient(135deg, #3a3a4a 0%, #4d4a3d 100%)';
          chooseBtn.style.boxShadow = '0 0 10px rgba(201, 165, 90, 0.3)';
        });
        chooseBtn.addEventListener('mouseleave', () => {
          chooseBtn.style.background = 'linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%)';
          chooseBtn.style.boxShadow = 'none';
        });
        chooseBtn.addEventListener('click', () => this.promptWeaponMasterSelection());
      }
    }

    // Wire up all unified toggle buttons
    cardsContainer.querySelectorAll('[data-action="toggle-spec"]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.toggleWeaponSpec(btn.dataset.weapon, btn.dataset.type);
      });
    });

    // Apply ranged spec load reductions (always automatic)
    this.applyRangedSpecLoadReduction();
  },

  /**
   * Setup the weapon spec collapse/expand toggle
   */
  setupWeaponSpecToggle() {
    const toggleBtn = document.getElementById('weapon-spec-toggle');
    const content = document.getElementById('weapon-spec-content');

    if (!toggleBtn || !content) return;

    // Only add listener once
    if (toggleBtn.dataset.listenerAdded) return;
    toggleBtn.dataset.listenerAdded = 'true';

    // Restore collapsed state
    if (this.character.weaponSpecCollapsed) {
      toggleBtn.classList.add('collapsed');
      content.classList.add('collapsed');
    }

    toggleBtn.addEventListener('click', () => {
      const isCollapsed = toggleBtn.classList.toggle('collapsed');
      content.classList.toggle('collapsed');
      this.character.weaponSpecCollapsed = isCollapsed;
      this.scheduleAutoSave();
    });
  },

  /**
   * Highlight specialized weapons on the Combat page
   * Adds a visual indicator to weapon name inputs that match a specialization
   */
  highlightSpecializedWeapons() {
    const specs = this.character.weaponSpecializations || [];

    // Build lookup sets
    const meleeSpecs = new Set();
    const rangedSpecs = new Set();
    let hasShieldSpec = false;

    for (const s of specs) {
      if (s.type === 'Shield') {
        hasShieldSpec = true;
      } else if (s.type === 'Melee') {
        meleeSpecs.add(s.weapon.toLowerCase().replace(/\s*\(.*\)/, ''));
      } else if (s.type === 'Ranged') {
        rangedSpecs.add(s.weapon.toLowerCase().replace(/\s*\(.*\)/, ''));
      }
    }

    // Known shield names for matching
    const shieldNames = new Set([
      'buckler', 'heater', 'hoplite', 'kite', 'peltast', 'round',
      'scutum', 'target', 'tower', 'viking',
      'buckler shield', 'heater shield', 'hoplite shield', 'kite shield',
      'peltast shield', 'round shield', 'scutum shield', 'target shield',
      'tower shield', 'viking shield'
    ]);

    // Process melee weapon rows
    const meleeBody = document.getElementById('melee-weapons-body');
    if (meleeBody) {
      meleeBody.querySelectorAll('tr').forEach(row => {
        const nameInput = row.querySelector('.weapon-name');
        if (!nameInput) return;
        const weaponName = nameInput.value.trim().toLowerCase();
        row.classList.remove('weapon-specialized');
        nameInput.title = '';

        if (!weaponName) return;

        // Check if it's a shield
        if (hasShieldSpec && shieldNames.has(weaponName)) {
          row.classList.add('weapon-specialized');
          nameInput.title = '🛡️ Weapon Specialization (Shield)';
          return;
        }

        // Check melee specs - match by normalizing
        for (const specWeapon of meleeSpecs) {
          if (this._weaponNameMatches(weaponName, specWeapon)) {
            row.classList.add('weapon-specialized');
            nameInput.title = `⚔️ Weapon Specialization`;
            break;
          }
        }
      });
    }

    // Process ranged weapon rows
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (rangedBody) {
      rangedBody.querySelectorAll('tr').forEach(row => {
        const nameInput = row.querySelector('.weapon-name');
        if (!nameInput) return;
        const weaponName = nameInput.value.trim().toLowerCase();
        row.classList.remove('weapon-specialized');
        nameInput.title = '';

        if (!weaponName) return;

        for (const specWeapon of rangedSpecs) {
          if (this._weaponNameMatches(weaponName, specWeapon)) {
            row.classList.add('weapon-specialized');
            nameInput.title = `🏹 Weapon Specialization`;
            break;
          }
        }
      });
    }
  },

  /**
   * Check if a weapon name from the combat page matches a specialization weapon name
   * Handles variants like "1H Bastard Sword" matching "Bastard Sword"
   */
  _weaponNameMatches(combatName, specName) {
    // Direct match
    if (combatName === specName) return true;

    // Strip leading "1h " or "2h " prefix
    const stripped = combatName.replace(/^[12]h\s+/i, '');
    if (stripped === specName) return true;

    // Handle "(Thrown)" suffix - match base name
    const baseSpec = specName.replace(/\s*\(thrown\)/i, '');
    if (combatName === baseSpec || stripped === baseSpec) return true;

    return false;
  },


  // ============================================
  // MONK ABILITIES SYSTEM
  // Handles: Flurry of Blows, Graceful Strike,
  // Lightning Reflexes, Quick
  // ============================================

  /**
   * Check if current character has Monk class
   */
  isMonkClass() {
    const classes = ['class-primary', 'class-secondary', 'class-tertiary'];
    return classes.some(id => {
      const el = document.getElementById(id);
      return el && el.value.trim().toLowerCase() === 'monk';
    });
  },

  /**
   * Get the monk's current rank
   */
  getMonkRank() {
    const classFields = [
      { cls: 'class-primary', rank: 'rank-primary' },
      { cls: 'class-secondary', rank: 'rank-secondary' },
      { cls: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    for (const { cls, rank } of classFields) {
      const classEl = document.getElementById(cls);
      const rankEl = document.getElementById(rank);
      if (classEl && classEl.value.trim().toLowerCase() === 'monk') {
        return parseInt(rankEl?.value, 10) || 0;
      }
    }
    return 0;
  },

  /**
   * Check if monk is Extremely Unburdened (ENC < 1/2 STR) and wearing no armor
   */
  isMonkExtremelyUnburdened() {
    const statusEl = document.getElementById('enc-status');
    const statusName = statusEl?.textContent?.trim() || '';
    return statusName === 'Extremely Unburdened';
  },

  /**
   * Check if monk is wearing no armor (all AP fields are 0)
   */
  isMonkUnarmored() {
    // Check all hit location AP fields (loc-0-ap through loc-9-ap)
    const apInputs = document.querySelectorAll('.ap-input');
    for (const field of apInputs) {
      if (parseInt(field.value, 10) > 0) return false;
    }
    return true;
  },

  /**
   * Show/hide monk abilities section and update display
   */
  checkMonkAbilitiesVisibility() {
    const section = document.getElementById('monk-abilities-section');
    const divider = document.getElementById('monk-abilities-divider');
    if (!section || !divider) return;

    const isMonk = this.isMonkClass();
    const hasMonkAbility = this.hasAbility('Flurry of Blows') || 
                           this.hasAbility('Graceful Strike') || 
                           this.hasAbility('Lightning Reflexes') ||
                           this.hasAbility('Quick') ||
                           this.hasAbility('Ki Strike') ||
                           this.hasAbility('Slow Fall') ||
                           this.hasAbility('Very Agile') ||
                           this.hasAbility('Arrowcut');

    if (isMonk && hasMonkAbility) {
      section.style.display = '';
      divider.style.display = '';
      this.setupMonkAbilitiesToggle();
      this.updateMonkAbilitiesDisplay();
    } else {
      section.style.display = 'none';
      divider.style.display = 'none';
      // Remove Quick movement bonus if no longer monk
      this._removeQuickMovementBonus();
      // Remove Graceful Strike DM override if no longer monk
      this._applyGracefulStrikeDM(false, 0);
      // Remove Ki Strike trait if no longer monk
      this._applyKiStrikeTrait(false);
    }
  },

  /**
   * Build and render all monk ability info cards
   */
  updateMonkAbilitiesDisplay() {
    const container = document.getElementById('monk-abilities-cards');
    if (!container) return;

    const monkRank = this.getMonkRank();
    const isEU = this.isMonkExtremelyUnburdened();
    const isUnarmored = this.isMonkUnarmored();
    const meetsConditions = isEU && isUnarmored;

    // Get Mysticism skill value
    const mysticismVal = this.getSkillValueByName('Mysticism') || 0;
    const mysticismBonus = Math.ceil(mysticismVal / 10);

    // Get DEX, POW, STR, SIZ for Graceful Strike calc
    const DEX = parseInt(this.character.attributes.DEX) || 0;
    const POW = parseInt(this.character.attributes.POW) || 0;
    const STR = parseInt(this.character.attributes.STR) || 0;
    const SIZ = parseInt(this.character.attributes.SIZ) || 0;
    const dexPowTotal = DEX + POW;
    const strSizTotal = STR + SIZ;

    // Calculate DM from DEX+POW vs STR+SIZ
    const gracefulBetter = dexPowTotal > strSizTotal;

    const statusColor = meetsConditions ? '#4fc3f7' : '#ff6b6b';
    const statusIcon = meetsConditions ? '✅' : '❌';
    const statusText = meetsConditions ? 'Active (Extremely Unburdened, No Armor)' : 'Inactive (requires Extremely Unburdened + No Armor)';

    let html = '';

    // Status indicator (spans full width of grid)
    html += `
      <div class="weapon-spec-card monk-status-card" style="border-color: ${statusColor}; background: linear-gradient(135deg, #1a1a2a 0%, #1a2a2a 100%);">
        <div style="display: flex; align-items: center; gap: 0.4rem; padding: 0.15rem;">
          <span style="font-size: 0.9rem;">${statusIcon}</span>
          <span style="color: ${statusColor}; font-size: 0.75rem; font-weight: 600;">Monk: ${statusText}</span>
        </div>
      </div>
    `;

    // Flurry of Blows
    if (this.hasAbility('Flurry of Blows')) {
      html += `
        <div class="weapon-spec-card" style="border-color: #c9a55a;">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">👊</span>
            <span class="weapon-spec-card-title">Flurry of Blows</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            Make an immediate follow-up Unarmed attack using a different limb/body part without waiting for next Turn. 
            Costs 1 Action Point. Chains attacks before defender can respond offensively. 
            <em>Similar to Flurry Special Effect but does not count as one.</em>
          </div>
        </div>
      `;
    }

    // Graceful Strike
    if (this.hasAbility('Graceful Strike')) {
      const gsActive = meetsConditions && gracefulBetter;
      const gsColor = gsActive ? '#4fc3f7' : (meetsConditions ? '#999' : '#666');
      
      // Calculate both DMs for display
      const normalDM = this.getDamageModifierForSum(strSizTotal);
      const gracefulDM = this.getDamageModifierForSum(dexPowTotal);
      const activeDM = gsActive ? gracefulDM : normalDM;
      
      const gsNote = meetsConditions 
        ? (gracefulBetter 
          ? `Using DEX+POW (${dexPowTotal}) → ${gracefulDM} — better than STR+SIZ (${strSizTotal}) → ${normalDM}`
          : `STR+SIZ (${strSizTotal}) → ${normalDM} is equal or better than DEX+POW (${dexPowTotal}) → ${gracefulDM} — using normal DM`)
        : 'Requires Extremely Unburdened + No Armor';

      html += `
        <div class="weapon-spec-card" style="border-color: ${gsColor};">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">🌊</span>
            <span class="weapon-spec-card-title">Graceful Strike</span>
            <span style="font-size: 0.7rem; color: ${gsColor}; margin-left: auto;">${gsActive ? '⚡ ACTIVE' : ''}</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            <strong>Unarmed DM:</strong> <span style="color: ${gsColor};"><strong>${activeDM}</strong></span> (${gsActive ? 'DEX+POW' : 'STR+SIZ'})<br>
            <span style="color: ${gsColor}; font-size: 0.75rem;">${gsNote}</span><br>
            <span style="color: #c9a55a; font-size: 0.75rem;">Hands and feet count as <strong>Large</strong> for Attacking and Parrying.</span>
          </div>
        </div>
      `;
    }

    // Lightning Reflexes
    if (this.hasAbility('Lightning Reflexes')) {
      const lrBonus = 10 + mysticismBonus;
      const lrColor = meetsConditions ? '#4fc3f7' : '#666';
      const lrStatus = meetsConditions ? `+${lrBonus}% to Parry & Evade rolls` : 'Inactive';

      html += `
        <div class="weapon-spec-card" style="border-color: ${lrColor};">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">⚡</span>
            <span class="weapon-spec-card-title">Lightning Reflexes</span>
            <span style="font-size: 0.7rem; color: ${lrColor}; margin-left: auto;">${meetsConditions ? '⚡ ACTIVE' : ''}</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            <strong>Parry (Combat Skill):</strong> <span style="color: ${lrColor};">+10% + 1/10 Mysticism (${mysticismVal}%) = <strong>+${lrBonus}%</strong></span>
            <span style="color: #999; font-size: 0.72rem;"> — not noted in Combat Skill field</span><br>
            <strong>Evade:</strong> <span style="color: ${lrColor};"><strong>+${lrBonus}%</strong></span>
            <span style="color: ${meetsConditions ? '#4fc3f7' : '#999'}; font-size: 0.72rem;"> — ${meetsConditions ? 'applied to Evade field (hover to see)' : 'applied when active'}</span><br>
            <span style="color: #c9a55a; font-size: 0.75rem;">May dodge any attack (melee or ranged) without falling prone.</span><br>
            <span style="color: #888; font-size: 0.72rem;">Bonuses do not count toward skill advancement.</span>
          </div>
        </div>
      `;
    }

    // Quick
    if (this.hasAbility('Quick')) {
      const quickBonus = monkRank * 5;
      const qColor = meetsConditions ? '#4fc3f7' : '#666';

      html += `
        <div class="weapon-spec-card" style="border-color: ${qColor};">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">💨</span>
            <span class="weapon-spec-card-title">Quick</span>
            <span style="font-size: 0.7rem; color: ${qColor}; margin-left: auto;">${meetsConditions ? '⚡ ACTIVE' : ''}</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            <strong>Movement Rate:</strong> <span style="color: ${qColor};"><strong>+${quickBonus} ft</strong></span> (+5 ft × Rank ${monkRank})<br>
            <span style="color: ${meetsConditions ? '#4fc3f7' : '#888'}; font-size: 0.75rem;">${meetsConditions ? 'Bonus applied to Movement Rate' : 'Requires Extremely Unburdened + No Armor'}</span>
          </div>
        </div>
      `;

      // Apply or remove movement bonus
      this._applyQuickMovementBonus(meetsConditions ? quickBonus : 0);
    }

    // Ki Strike
    if (this.hasAbility('Ki Strike')) {
      const kiRankBonus = monkRank; // +1 at Rank 1, +2 at Rank 2, etc.
      const kiColor = '#c9a55a';
      const kiRank4Note = monkRank >= 4 ? '<br><span style="color: #4fc3f7; font-size: 0.72rem;">Rank 4+: Ignore half of target\'s armor on Unarmed attacks (magic bonus never halved)</span>' : '';

      html += `
        <div class="weapon-spec-card" style="border-color: ${kiColor};">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">✊</span>
            <span class="weapon-spec-card-title">Ki Strike</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            <strong>Unarmed = +${kiRankBonus} magical weapon</strong> (Rank ${monkRank})${kiRank4Note}
          </div>
        </div>
      `;
    }

    // Slow Fall
    if (this.hasAbility('Slow Fall')) {
      const sfDistance = Math.ceil(mysticismVal / 2);
      const sfColor = meetsConditions ? '#4fc3f7' : '#666';

      html += `
        <div class="weapon-spec-card" style="border-color: ${sfColor};">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">🍃</span>
            <span class="weapon-spec-card-title">Slow Fall</span>
            <span style="font-size: 0.7rem; color: ${sfColor}; margin-left: auto;">${meetsConditions ? '⚡ ACTIVE' : ''}</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            <strong>Safe fall distance:</strong> <span style="color: ${sfColor};"><strong>${sfDistance} ft</strong></span> (⌈${mysticismVal}/2⌉)<br>
            <span style="color: ${meetsConditions ? '#4fc3f7' : '#888'}; font-size: 0.72rem;">${meetsConditions ? 'Must be near a wall, cliff, tree, or similar surface' : 'Requires Extremely Unburdened + No Armor'}</span>
          </div>
        </div>
      `;
    }

    // Very Agile
    if (this.hasAbility('Very Agile')) {
      const vaBonus = Math.max(5, Math.ceil(mysticismVal / 10));
      const vaColor = meetsConditions ? '#4fc3f7' : '#666';

      html += `
        <div class="weapon-spec-card" style="border-color: ${vaColor};">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">🌀</span>
            <span class="weapon-spec-card-title">Very Agile</span>
            <span style="font-size: 0.7rem; color: ${vaColor}; margin-left: auto;">${meetsConditions ? '⚡ ACTIVE' : ''}</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            <strong>Initiative:</strong> <span style="color: ${vaColor};"><strong>+${vaBonus}</strong></span> (⌈${mysticismVal}/10⌉, min 5)<br>
            <span style="color: ${meetsConditions ? '#4fc3f7' : '#888'}; font-size: 0.72rem;">${meetsConditions ? 'Applied to Initiative field (hover to see)' : 'Requires Extremely Unburdened + No Armor'}</span>
          </div>
        </div>
      `;
    }

    // Arrowcut
    if (this.hasAbility('Arrowcut')) {
      const acColor = meetsConditions ? '#4fc3f7' : '#666';

      html += `
        <div class="weapon-spec-card" style="border-color: ${acColor};">
          <div class="weapon-spec-card-header">
            <span class="weapon-spec-card-icon">🏹</span>
            <span class="weapon-spec-card-title">Arrowcut</span>
            <span style="font-size: 0.7rem; color: ${acColor}; margin-left: auto;">${meetsConditions ? '⚡ ACTIVE' : ''}</span>
          </div>
          <div class="benefit-item" style="font-size: 0.78rem; color: #ccc;">
            <strong>Parry</strong> arrows, darts, & spears at <strong>Standard Difficulty</strong><br>
            <span style="color: ${meetsConditions ? '#4fc3f7' : '#888'}; font-size: 0.72rem;">${meetsConditions ? 'Can deflect projectiles bare-handed or with any weapon' : 'Requires Extremely Unburdened + No Armor'}</span>
          </div>
        </div>
      `;
    }

    container.innerHTML = html;
    
    // Apply Graceful Strike DM override to Unarmed weapon
    if (this.hasAbility('Graceful Strike')) {
      this._applyGracefulStrikeDM(meetsConditions && gracefulBetter, dexPowTotal);
    } else {
      this._applyGracefulStrikeDM(false, 0);
    }
    
    // Apply Ki Strike "Magical" trait to Unarmed weapon
    if (this.hasAbility('Ki Strike')) {
      this._applyKiStrikeTrait(true);
    }
  },
  
  /**
   * Apply or remove Graceful Strike DM row
   * When active, populates the GS Damage Mod row so composeDamage uses DEX+POW DM for unarmed
   */
  _applyGracefulStrikeDM(active, dexPowTotal) {
    const gsRow = document.getElementById('gs-damage-row');
    const gsOrigField = document.getElementById('gs-damage-mod-original');
    const gsCurrField = document.getElementById('gs-damage-mod-current');
    
    if (active && gsRow && gsOrigField && gsCurrField) {
      const gracefulDM = this.getDamageModifierForSum(dexPowTotal);
      gsRow.style.display = '';
      gsOrigField.value = gracefulDM;
      gsCurrField.value = gracefulDM;
    } else if (gsRow) {
      gsRow.style.display = 'none';
      if (gsOrigField) gsOrigField.value = '';
      if (gsCurrField) gsCurrField.value = '';
    }
    
    // Let composeDamage handle the DM selection for unarmed
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }
  },

  /**
   * Apply Quick movement bonus to the movement-current field
   */
  _applyQuickMovementBonus(bonus) {
    const movField = document.getElementById('movement-current');
    if (!movField) return;

    const prevBonus = this._monkQuickBonus || 0;
    if (bonus === prevBonus) return; // No change

    const currentVal = parseInt(movField.value, 10) || 0;
    // Remove old bonus, add new
    const newVal = currentVal - prevBonus + bonus;
    movField.value = newVal;
    this._monkQuickBonus = bonus;

    if (bonus > 0) {
      movField.classList.add('artful-dodger-bonus');
      movField.title = `Quick: +${bonus} ft (Monk Rank ${this.getMonkRank()})`;
    } else {
      movField.classList.remove('artful-dodger-bonus');
      if (movField.title && movField.title.includes('Quick:')) {
        movField.title = '';
      }
    }

    // Recalculate movement display
    this.updateMovementDisplay();
  },

  /**
   * Remove Quick movement bonus (when no longer monk or conditions not met)
   */
  _removeQuickMovementBonus() {
    if (this._monkQuickBonus && this._monkQuickBonus > 0) {
      this._applyQuickMovementBonus(0);
    }
  },

  /**
   * Setup monk abilities collapse/expand toggle
   */
  setupMonkAbilitiesToggle() {
    const toggleBtn = document.getElementById('monk-abilities-toggle');
    const content = document.getElementById('monk-abilities-content');
    if (!toggleBtn || !content) return;
    if (toggleBtn.dataset.listenerAdded) return;
    toggleBtn.dataset.listenerAdded = 'true';

    if (this.character.monkAbilitiesCollapsed) {
      toggleBtn.classList.add('collapsed');
      content.classList.add('collapsed');
    }

    toggleBtn.addEventListener('click', () => {
      const isCollapsed = toggleBtn.classList.toggle('collapsed');
      content.classList.toggle('collapsed');
      this.character.monkAbilitiesCollapsed = isCollapsed;
      this.scheduleAutoSave();
    });
  },

  // ============================================
  // COMBAT BUFF BASELINE SYSTEM
  // Tracks true original values before any combat buffs
  // (Weapon Spec, Weapon Master, Forceful Strike)
  // ============================================

  /**
   * Capture the baseline (unbuffed) combat values if not already captured.
   * Called before any buff is applied.
   */
  captureBaselineIfNeeded() {
    if (this.character.combatBuffBaseline) return;

    this.character.combatBuffBaseline = {
      combatSkill: document.getElementById('combat-skill-1-percent')?.value || '0',
      damageMod: document.getElementById('damage-mod-current')?.value || '+0',
      damageModOrig: document.getElementById('damage-mod-original')?.value || '+0',
      wpDamageMod: document.getElementById('wp-damage-mod-current')?.value || '',
      wpDamageModOrig: document.getElementById('wp-damage-mod-original')?.value || ''
    };
  },

  /**
   * Check if any combat buff is still active. If none, release baseline.
   */
  releaseBaselineIfClean() {
    const specs = this.character.activeWeaponSpecs || [];
    if (!this.character.isForcefulStrikeActive && specs.length === 0) {
      delete this.character.combatBuffBaseline;
    }
  },

  /**
   * Recalculate all buffed values from baseline.
   * Called after any combat buff activates or deactivates.
   */
  recalculateCombatBuffs() {
    const baseline = this.character.combatBuffBaseline;
    if (!baseline) return;

    const activeSpecs = this.character.activeWeaponSpecs || [];
    const isWeaponSpecActive = activeSpecs.length > 0;
    const isForcefulActive = !!this.character.isForcefulStrikeActive;
    const wm = this.character.weaponMaster;

    // Check if any active spec is melee/shield (for CS +5, non-stacking)
    const hasAnyMeleeOrShield = activeSpecs.some(key => {
      const [, t] = key.split('|');
      return t === 'Melee' || t === 'Shield';
    });

    // Check if ANY active spec is the mastered weapon
    let anyMastered = false;
    let masteredTierData = null;
    if (wm && wm.weapon) {
      for (const key of activeSpecs) {
        const [w, t] = key.split('|');
        if (wm.weapon.toLowerCase() === w.toLowerCase() && wm.type === t) {
          anyMastered = true;
          masteredTierData = this.WEAPON_MASTER_TIERS[wm.tier] || this.WEAPON_MASTER_TIERS.master;
          break;
        }
      }
    }

    // --- Combat Skill (non-stacking +5 if any melee/shield active) ---
    const skillInput = document.getElementById('combat-skill-1-percent');
    if (skillInput) {
      let cs = parseInt(baseline.combatSkill, 10) || 0;
      if (isWeaponSpecActive && hasAnyMeleeOrShield) cs += 5;
      if (isForcefulActive) cs -= 20;
      skillInput.value = cs;

      // Styling
      skillInput.classList.remove('damage-boosted', 'forceful-penalized');
      skillInput.title = '';
      const row = skillInput.closest('.combat-skill-row');
      if (row) row.classList.remove('weapon-spec-active-row');

      if (isWeaponSpecActive) {
        skillInput.classList.add('damage-boosted');
        if (anyMastered && masteredTierData) {
          skillInput.title = 'Critical doubled (' + masteredTierData.label + ')';
        } else {
          skillInput.title = 'Weapon Specialization: +5% Combat Skill';
        }
        if (row) row.classList.add('weapon-spec-active-row');
      }
      if (isForcefulActive) {
        skillInput.classList.add('forceful-penalized');
        const existing = skillInput.title;
        skillInput.title = existing
          ? existing + ' | Forceful Strike: -20%'
          : 'Forceful Strike: -20% (one grade harder)';
      }
    }

    // --- Global Damage Modifier (only Forceful Strike touches these) ---
    const dmgCurrField = document.getElementById('damage-mod-current');
    const dmgOrigField = document.getElementById('damage-mod-original');
    const wpDmgCurrField = document.getElementById('wp-damage-mod-current');
    const wpDmgOrigField = document.getElementById('wp-damage-mod-original');

    if (isForcefulActive) {
      if (dmgCurrField) {
        dmgCurrField.value = this.stepDamageModifier(baseline.damageMod, 2);
        dmgCurrField.classList.add('forceful-boosted');
        dmgCurrField.title = 'Forceful Strike: +2 steps';
      }
      if (dmgOrigField) {
        dmgOrigField.value = this.stepDamageModifier(baseline.damageModOrig, 2);
        dmgOrigField.classList.add('forceful-boosted');
      }
      if (wpDmgCurrField && baseline.wpDamageMod.trim()) {
        wpDmgCurrField.value = this.stepDamageModifier(baseline.wpDamageMod, 2);
        wpDmgCurrField.classList.add('forceful-boosted');
        wpDmgCurrField.title = 'Forceful Strike: +2 steps';
      }
      if (wpDmgOrigField && baseline.wpDamageModOrig.trim()) {
        wpDmgOrigField.value = this.stepDamageModifier(baseline.wpDamageModOrig, 2);
        wpDmgOrigField.classList.add('forceful-boosted');
      }
    } else {
      if (dmgCurrField) {
        dmgCurrField.value = baseline.damageMod;
        dmgCurrField.classList.remove('forceful-boosted');
        dmgCurrField.title = '';
      }
      if (dmgOrigField) {
        dmgOrigField.value = baseline.damageModOrig;
        dmgOrigField.classList.remove('forceful-boosted');
      }
      if (wpDmgCurrField) {
        wpDmgCurrField.value = baseline.wpDamageMod;
        wpDmgCurrField.classList.remove('forceful-boosted');
        wpDmgCurrField.title = '';
      }
      if (wpDmgOrigField) {
        wpDmgOrigField.value = baseline.wpDamageModOrig;
        wpDmgOrigField.classList.remove('forceful-boosted');
      }
    }

    // --- Recalculate all weapon damage from global DM ---
    if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
      window.WeaponData.updateAllWeaponDamage();
    }

    // --- Forceful Strike weapon styling (all weapons) ---
    const weaponDamageFields = document.querySelectorAll('.weapon-damage');
    if (isForcefulActive) {
      weaponDamageFields.forEach(field => {
        if (field.value.trim()) {
          field.classList.add('forceful-boosted');
          field.title = 'Increased damage modifier with Forceful Strike';
        }
      });
    } else {
      weaponDamageFields.forEach(field => {
        field.classList.remove('forceful-boosted');
        if (!field.classList.contains('damage-boosted')) field.title = '';
      });
    }

    // --- Weapon Master: step ONLY mastered weapon's damage on top ---
    this._clearWeaponMasterDamageBoost();

    if (anyMastered && wm && wm.tier) {
      const isMeleeOrShieldMaster = wm.type === 'Melee' || wm.type === 'Shield';
      if (isMeleeOrShieldMaster) {
        const tierOrder = ['master', 'high', 'grand', 'legendary'];
        const tierIdx = tierOrder.indexOf(wm.tier);
        const dmSteps = tierIdx >= 2 ? 2 : 1;
        const tooltipText = `${masteredTierData.label}: +${dmSteps} step${dmSteps > 1 ? 's' : ''} DM`;

        const currentGlobalDM = dmgCurrField ? dmgCurrField.value.trim() : '+0';
        const masteredDM = this.stepDamageModifier(currentGlobalDM, dmSteps);

        this._applyWeaponMasterDamageStep(wm.weapon, currentGlobalDM, masteredDM, tooltipText);
      }
    }

    // Set doubled crit flag
    this.character.weaponSpecCritDoubled = anyMastered;

    // --- Grand Master / Legendary Master Ranged: Reload reduction ---
    this._clearWeaponMasterReloadReduction();
    if (anyMastered && wm && wm.type === 'Ranged') {
      const tierOrder = ['master', 'high', 'grand', 'legendary'];
      const tierIdx = tierOrder.indexOf(wm.tier);
      if (tierIdx >= 2) { // Grand or higher
        const wmCategory = this._getWeaponMasterCategory(wm.weapon);
        let reloadReduction = 0;
        if (tierIdx >= 2) reloadReduction += 1; // Grand: -1
        if (tierIdx >= 3 && wmCategory === 'crossbow') reloadReduction += 1; // Legendary crossbow: -1 more
        if (reloadReduction > 0) {
          this._applyWeaponMasterReloadReduction(wm.weapon, reloadReduction, wm.tier);
        }
      }
    }

    // --- Legendary Master Multi-shot CS penalty ---
    if (anyMastered && wm && wm.type === 'Ranged' && wm.tier === 'legendary') {
      const wmCategory = this._getWeaponMasterCategory(wm.weapon);
      if (wmCategory === 'bow' || wmCategory === 'slinger') {
        const multiShot = this.character.legendaryMultiShot || null;
        if (multiShot && multiShot.count > 1 && skillInput) {
          const csPenalty = multiShot.count === 3 ? -40 : -20;
          let cs = parseInt(skillInput.value, 10) || 0;
          cs += csPenalty;
          skillInput.value = cs;
          const existing = skillInput.title || '';
          skillInput.title = existing
            ? existing + ` | Multi-shot (${multiShot.count}): ${csPenalty}%`
            : `Legendary Master Multi-shot (${multiShot.count}): ${csPenalty}%`;
          skillInput.classList.add('forceful-penalized');
        }
      }
    }

    this.refreshSummaryWidgets();
    this.updateCombatQuickRef();
    
    // After all combat buffs are recalculated, ensure DM current matches original if nothing is active
    this.resetDamageModToOriginalIfClean();
  },

  /**
   * Apply Weapon Master's DM step to a specific weapon's damage field.
   */
  _applyWeaponMasterDamageStep(weaponName, currentDM, steppedDM, tooltipText) {
    const targetName = weaponName.toLowerCase().trim();

    ['melee-weapons-body', 'ranged-weapons-body'].forEach(bodyId => {
      const body = document.getElementById(bodyId);
      if (!body) return;
      body.querySelectorAll('tr').forEach(row => {
        const nameInput = row.querySelector('.weapon-name');
        if (!nameInput) return;
        const rowName = nameInput.value.trim().toLowerCase();
        if (!this._weaponNameMatches(rowName, targetName)) return;

        const damageField = row.querySelector('.weapon-damage');
        if (!damageField || !damageField.value.trim()) return;

        damageField.dataset.wmOriginalDamage = damageField.value;

        let newDamage = damageField.value;
        if (currentDM && currentDM !== '+0') {
          const dmSuffix = currentDM.startsWith('+') ? currentDM : '+' + currentDM;
          const steppedSuffix = steppedDM.startsWith('+') ? steppedDM : '+' + steppedDM;
          const idx = newDamage.lastIndexOf(dmSuffix.replace(/^\+/, ''));
          if (idx > 0) {
            const prefix = newDamage.substring(0, idx);
            const cleanPrefix = prefix.endsWith('+') ? prefix.slice(0, -1) : prefix;
            newDamage = cleanPrefix + steppedSuffix;
          }
        } else if (!currentDM || currentDM === '+0') {
          if (steppedDM && steppedDM !== '+0') {
            newDamage = damageField.value + steppedDM;
          }
        }

        damageField.value = newDamage;
        damageField.classList.add('damage-boosted');
        damageField.title = tooltipText;
      });
    });
  },

  /**
   * Clear Weapon Master damage boost from all weapons, restoring originals.
   */
  _clearWeaponMasterDamageBoost() {
    ['melee-weapons-body', 'ranged-weapons-body'].forEach(bodyId => {
      const body = document.getElementById(bodyId);
      if (!body) return;
      body.querySelectorAll('tr').forEach(row => {
        const damageField = row.querySelector('.weapon-damage');
        if (!damageField) return;
        if (damageField.dataset.wmOriginalDamage) {
          damageField.value = damageField.dataset.wmOriginalDamage;
          delete damageField.dataset.wmOriginalDamage;
          damageField.classList.remove('damage-boosted');
          if (!damageField.classList.contains('forceful-boosted')) {
            damageField.title = '';
          }
        }
      });
    });
  },

  /**
   * Apply Weapon Master Reload reduction to a specific ranged weapon
   */
  _applyWeaponMasterReloadReduction(weaponName, reductionAmount, tierKey) {
    const targetName = weaponName.toLowerCase().trim();
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (!rangedBody) return;

    const tierData = this.WEAPON_MASTER_TIERS[tierKey] || this.WEAPON_MASTER_TIERS.master;

    rangedBody.querySelectorAll('tr').forEach(row => {
      const nameInput = row.querySelector('.weapon-name');
      if (!nameInput) return;
      const rowName = nameInput.value.trim().toLowerCase();
      if (!this._weaponNameMatches(rowName, targetName)) return;

      let loadInput = null;
      for (const input of row.querySelectorAll('input')) {
        if (input.id && input.id.includes('-load')) {
          loadInput = input;
          break;
        }
      }
      if (!loadInput) return;

      const currentLoad = loadInput.value.trim();
      if (currentLoad === '-' || currentLoad === '\u2013' || currentLoad === '') return;

      // Store original before weapon master reduction
      if (!loadInput.dataset.wmOriginalLoad) {
        loadInput.dataset.wmOriginalLoad = currentLoad;
      }

      const loadNum = parseInt(currentLoad, 10);
      if (isNaN(loadNum)) return;

      const newLoad = Math.max(0, loadNum - reductionAmount);
      loadInput.value = String(newLoad);
      loadInput.dataset.wmReloadReduced = 'true';
      loadInput.classList.add('damage-boosted');
      const freeNote = newLoad === 0 ? ' (Free Action!)' : '';
      loadInput.title = `${tierData.label}: -${reductionAmount} Reload${freeNote}. Original: ${loadInput.dataset.wmOriginalLoad}`;
    });
  },

  /**
   * Clear Weapon Master Reload reductions, restoring originals
   */
  _clearWeaponMasterReloadReduction() {
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (!rangedBody) return;

    rangedBody.querySelectorAll('tr').forEach(row => {
      for (const input of row.querySelectorAll('input')) {
        if (input.id && input.id.includes('-load') && input.dataset.wmReloadReduced === 'true') {
          if (input.dataset.wmOriginalLoad) {
            input.value = input.dataset.wmOriginalLoad;
          }
          delete input.dataset.wmReloadReduced;
          delete input.dataset.wmOriginalLoad;
          input.classList.remove('damage-boosted');
          // Preserve spec-load-reduced title if present
          if (!input.classList.contains('spec-load-reduced')) {
            input.title = '';
          }
        }
      }
    });
  },

  /**
   * Show Legendary Master multi-shot selection modal
   */
  _showLegendaryMultiShotModal(weaponName, category) {
    const projectileType = category === 'bow' ? 'arrows'
      : category === 'slinger' ? (weaponName.toLowerCase().includes('sling') ? 'stones/bullets' : 'knives/daggers')
      : 'projectiles';

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay';
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8); display: flex; justify-content: center;
      align-items: center; z-index: 10000;
    `;

    const tierData = this.WEAPON_MASTER_TIERS.legendary;

    overlay.innerHTML = `
      <div style="
        background: linear-gradient(135deg, #1a1a2a 0%, #2d2a1d 100%);
        border: 2px solid ${tierData.color}; border-radius: 12px;
        padding: 1.5rem; max-width: 400px; width: 90%;
        box-shadow: 0 0 30px ${tierData.glowColor};
      ">
        <h3 style="color: ${tierData.color}; margin: 0 0 0.5rem 0; text-align: center;">
          ${tierData.icon} Legendary Master: Multi-Shot
        </h3>
        <p style="color: #ccc; margin-bottom: 1rem; text-align: center; font-size: 0.85rem;">
          <strong>${weaponName}</strong> — How many ${projectileType} will you fire?<br>
          <span style="color: #999; font-size: 0.8rem;">Targets must be within Close Range and within 5 feet of each other.</span>
        </p>
        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
          <button type="button" class="lm-multishot-btn" data-count="1" style="
            background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
            border: 1px solid rgba(201, 165, 90, 0.3); color: #ddd;
            padding: 0.6rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;
            text-align: left; transition: all 0.2s ease;
          ">🎯 <strong>Single shot</strong> — No penalty</button>
          <button type="button" class="lm-multishot-btn" data-count="2" style="
            background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
            border: 1px solid rgba(255, 107, 107, 0.3); color: #ddd;
            padding: 0.6rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;
            text-align: left; transition: all 0.2s ease;
          ">🏹🏹 <strong>2 ${projectileType}</strong> — Combat Skill −20% (1 Grade harder)</button>
          <button type="button" class="lm-multishot-btn" data-count="3" style="
            background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
            border: 1px solid rgba(255, 50, 50, 0.4); color: #ddd;
            padding: 0.6rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;
            text-align: left; transition: all 0.2s ease;
          ">🏹🏹🏹 <strong>3 ${projectileType}</strong> — Combat Skill −40% (2 Grades harder)</button>
        </div>
      </div>
    `;

    document.body.appendChild(overlay);

    // Hover effects
    overlay.querySelectorAll('.lm-multishot-btn').forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.background = 'linear-gradient(135deg, #3a3a4a 0%, #4d4a3d 100%)';
        btn.style.boxShadow = `0 0 8px ${tierData.glowColor}`;
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.background = 'linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%)';
        btn.style.boxShadow = 'none';
      });
      btn.addEventListener('click', () => {
        const count = parseInt(btn.dataset.count, 10);
        if (count === 1) {
          delete this.character.legendaryMultiShot;
        } else {
          this.character.legendaryMultiShot = {
            count: count,
            csPenalty: count === 3 ? -40 : -20,
            weapon: weaponName
          };
        }
        document.body.removeChild(overlay);
        // Recalculate to apply the CS penalty
        this.recalculateCombatBuffs();
        this.updateWeaponSpecDisplay();
        this.scheduleAutoSave();
      });
    });
  },

  // ============================================
  // WEAPON MASTER SYSTEM & SPEC ACTIVATION
  // ============================================

  /**
   * Weapon Master tier definitions
   * Each tier adds cumulative benefits on top of previous tiers
   */
  WEAPON_MASTER_TIERS: {
    master: {
      rank: 2,
      label: 'Weapon Master',
      icon: '\u2694\uFE0F',
      prereqSkill: 70,
      color: '#c9a55a',
      glowColor: 'rgba(201, 165, 90, 0.6)',
      benefits: {
        melee: 'Double Critical range. +1 step Damage Modifier.',
        ranged: 'Double Critical range. DM bonus applies at Close Range.'
      }
    },
    high: {
      rank: 3,
      label: 'High Master',
      icon: '\uD83D\uDDE1\uFE0F',
      prereqSkill: 90,
      color: '#7fb8e0',
      glowColor: 'rgba(127, 184, 224, 0.6)',
      benefits: {
        melee: '+ Riposte: free follow-up thrust after Successful Parry (1 Grade harder). Weapon counts as 1 Size category larger for Parrying.',
        ranged: '+ Marksman: at Close Range, shift Hit Location roll to an adjacent location.'
      }
    },
    grand: {
      rank: 4,
      label: 'Grand Master',
      icon: '\uD83D\uDC51',
      prereqSkill: 110,
      color: '#d4a0e0',
      glowColor: 'rgba(212, 160, 224, 0.6)',
      benefits: {
        melee: '+ Additional +1 step Damage Modifier (total +2 steps including Weapon Master).',
        ranged: '+ Reduce Reload time by 1. If 0, weapon readied as Free Action.'
      }
    },
    legendary: {
      rank: 5,
      label: 'Legendary Master',
      icon: '\uD83C\uDF1F',
      prereqSkill: 130,
      color: '#ff6b6b',
      glowColor: 'rgba(255, 107, 107, 0.6)',
      benefits: {
        melee: '+ Weapon counts as 2 Size categories larger for Parrying (Large→Enormous, Huge→Colossal, etc.).',
        ranged: '+ Bows/Slings/Blades: Multi-shot (2 at -1 Grade, 3 at -2 Grades, Close Range). Crossbows: -1 additional Reload.'
      }
    }
  },

  // Weapon categories for mastery effects
  WM_CROSSBOWS: ['arbalest', 'hand crossbow', 'heavy crossbow', 'repeating heavy crossbow', 'light crossbow', 'repeating light crossbow'],
  WM_BOWS: ['composite long bow', 'composite short bow', 'long bow', 'recurve bow', 'short bow'],
  WM_SLINGS_BLADES: ['sling', 'staff sling', 'dagger (thrown)', 'throwing knife', 'dart'],

  /**
   * Determine the mastered weapon's category for tier effects
   */
  _getWeaponMasterCategory(weaponName) {
    const name = (weaponName || '').toLowerCase().trim();
    if (this.WM_CROSSBOWS.some(w => name.includes(w) || w.includes(name))) return 'crossbow';
    if (this.WM_BOWS.some(w => name.includes(w) || w.includes(name))) return 'bow';
    if (this.WM_SLINGS_BLADES.some(w => name.includes(w) || w.includes(name))) return 'slinger';
    return 'other';
  },

  /**
   * Get the current Weapon Master tier based on rank and combat skill
   */
  getWeaponMasterTier() {
    if (!this.character.weaponMaster) return null;

    const fighterRank = this.getFighterRank();
    if (fighterRank < 2) return null;

    // Tier is determined purely by rank — rank advancement already requires
    // the Combat Skill prereqs (70%/90%/110%/130%), so no need to double-check
    const tiers = ['legendary', 'grand', 'high', 'master'];
    for (const tierKey of tiers) {
      const tier = this.WEAPON_MASTER_TIERS[tierKey];
      if (fighterRank >= tier.rank) {
        return tierKey;
      }
    }
    return null;
  },

  /**
   * Get fighter rank from current classes
   */
  getFighterRank() {
    const classFields = [
      { cls: 'class-primary', rank: 'rank-primary' },
      { cls: 'class-secondary', rank: 'rank-secondary' },
      { cls: 'class-tertiary', rank: 'rank-tertiary' }
    ];
    for (const { cls, rank } of classFields) {
      const classEl = document.getElementById(cls);
      const rankEl = document.getElementById(rank);
      if (classEl && classEl.value.trim().toLowerCase() === 'fighter') {
        return parseInt(rankEl?.value, 10) || 0;
      }
    }
    return 0;
  },

  /**
   * Check if Weapon Master should be prompted or updated
   */
  checkWeaponMasterProgression(abilityName) {
    const normalized = abilityName.toLowerCase().trim();
    const masterAbilities = ['weapon master', 'high master', 'grand master', 'legendary master'];
    if (!masterAbilities.includes(normalized)) return;

    if (!this.character.weaponMaster || !this.character.weaponMaster.weapon) {
      if (normalized === 'weapon master') {
        const specs = this.character.weaponSpecializations || [];
        if (specs.length > 0 && !this.isInitializing) {
          setTimeout(() => this.promptWeaponMasterSelection(), 200);
        }
      }
      return;
    }

    this.updateWeaponMasterTier();
    this.updateWeaponSpecDisplay();
  },

  /**
   * Update the stored tier based on current rank/skill
   */
  updateWeaponMasterTier() {
    if (!this.character.weaponMaster) return;
    const newTier = this.getWeaponMasterTier();
    if (newTier && newTier !== this.character.weaponMaster.tier) {
      this.character.weaponMaster.tier = newTier;
      this.scheduleAutoSave();
    }
  },

  /**
   * Prompt user to select which weapon to master
   */
  promptWeaponMasterSelection() {
    const specs = (this.character.weaponSpecializations || []).filter(s => s.type !== 'Shield');
    if (specs.length === 0) return;
    if (this.character.weaponMaster && this.character.weaponMaster.weapon) return;

    const overlay = document.createElement('div');
    overlay.className = 'modal-overlay weapon-master-modal-overlay';
    overlay.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85); display: flex; justify-content: center;
      align-items: center; z-index: 10001; animation: fadeIn 0.3s ease;
    `;

    const modal = document.createElement('div');
    modal.style.cssText = `
      background: linear-gradient(135deg, #1a1a2a 0%, #2d2a1d 100%);
      border: 2px solid #c9a55a; border-radius: 12px;
      padding: 1.5rem; max-width: 460px; width: 90%;
      box-shadow: 0 0 40px rgba(201, 165, 90, 0.4), inset 0 0 20px rgba(201, 165, 90, 0.05);
      animation: scaleIn 0.3s ease;
    `;

    let weaponButtons = '';
    for (const spec of specs) {
      const icon = spec.type === 'Ranged' ? '\uD83C\uDFF9' : '\u2694\uFE0F';
      weaponButtons += `
        <button type="button" class="wm-weapon-btn" data-weapon="${spec.weapon}" data-type="${spec.type}" style="
          background: linear-gradient(135deg, #2a2a3a 0%, #3d3a2d 100%);
          border: 1px solid rgba(201, 165, 90, 0.3); color: #ddd;
          padding: 0.75rem 1rem; border-radius: 6px; cursor: pointer;
          text-align: left; transition: all 0.2s ease; font-size: 0.9rem;
          width: 100%;
        ">${icon} <strong>${spec.weapon}</strong> <span style="color:#999;font-size:0.8rem;">(${spec.type})</span></button>
      `;
    }

    modal.innerHTML = `
      <div style="text-align:center; margin-bottom: 0.5rem;">
        <span style="font-size: 2rem;">\u2694\uFE0F</span>
      </div>
      <h3 style="color: #c9a55a; margin: 0 0 0.5rem 0; text-align: center; font-size: 1.1rem;">
        Weapon Master
      </h3>
      <p style="color: #ccc; margin-bottom: 0.5rem; text-align: center; font-size: 0.85rem;">
        Choose <strong>one weapon</strong> to master. This choice is permanent \u2014 you may only have Weapon Master in a single weapon.
      </p>
      <p style="color: #999; margin-bottom: 1rem; text-align: center; font-size: 0.75rem; font-style: italic;">
        Doubles your Critical range when using this weapon. Melee weapons also gain a Damage Modifier improvement.
      </p>
      <div style="display: flex; flex-direction: column; gap: 0.5rem;">
        ${weaponButtons}
      </div>
      <div style="text-align: center; margin-top: 0.75rem;">
        <button type="button" class="wm-cancel-btn" style="
          background: transparent; border: 1px solid #666; color: #999;
          padding: 0.4rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;
        ">Decide Later</button>
      </div>
    `;

    modal.querySelectorAll('.wm-weapon-btn').forEach(btn => {
      btn.addEventListener('mouseenter', () => {
        btn.style.borderColor = '#c9a55a';
        btn.style.transform = 'translateX(5px)';
        btn.style.boxShadow = '0 0 10px rgba(201, 165, 90, 0.3)';
      });
      btn.addEventListener('mouseleave', () => {
        btn.style.borderColor = 'rgba(201, 165, 90, 0.3)';
        btn.style.transform = 'translateX(0)';
        btn.style.boxShadow = 'none';
      });
      btn.addEventListener('click', () => {
        this.finalizeWeaponMasterSelection(btn.dataset.weapon, btn.dataset.type);
        overlay.remove();
      });
    });

    modal.querySelector('.wm-cancel-btn').addEventListener('click', () => overlay.remove());

    overlay.appendChild(modal);
    document.body.appendChild(overlay);
  },

  /**
   * Finalize weapon master selection
   */
  finalizeWeaponMasterSelection(weapon, type) {
    const tier = this.getWeaponMasterTier() || 'master';
    this.character.weaponMaster = { weapon, type, tier };
    this.updateWeaponSpecDisplay();
    this.scheduleAutoSave();
  },

  // ============================================
  // UNIFIED WEAPON SPEC ACTIVATION
  // ============================================

  toggleWeaponSpec(weapon, type) {
    const specKey = `${weapon}|${type}`;
    if (!this.character.activeWeaponSpecs) this.character.activeWeaponSpecs = [];
    const idx = this.character.activeWeaponSpecs.indexOf(specKey);
    const wasActive = idx !== -1;

    // Capture baseline before any changes
    this.captureBaselineIfNeeded();

    if (wasActive) {
      // Remove from array
      this.character.activeWeaponSpecs.splice(idx, 1);
      // Clear multi-shot if deactivating the mastered weapon
      const wm = this.character.weaponMaster;
      if (wm && wm.weapon && wm.weapon.toLowerCase() === weapon.toLowerCase() && wm.type === type) {
        delete this.character.legendaryMultiShot;
      }
    } else {
      // Add to array
      this.character.activeWeaponSpecs.push(specKey);

      // Play animation for mastered weapons
      const wm = this.character.weaponMaster;
      const isMastered = wm && wm.weapon &&
        wm.weapon.toLowerCase() === weapon.toLowerCase() &&
        wm.type === type;
      if (isMastered && wm.tier) {
        const tierData = this.WEAPON_MASTER_TIERS[wm.tier] || this.WEAPON_MASTER_TIERS.master;
        this.playWeaponMasterAnimation(weapon, type, tierData);

        // Legendary Master multi-shot prompt for bows/slings/blades
        if (wm.tier === 'legendary' && wm.type === 'Ranged') {
          const wmCategory = this._getWeaponMasterCategory(wm.weapon);
          if (wmCategory === 'bow' || wmCategory === 'slinger') {
            // Defer prompt to after recalculation
            setTimeout(() => this._showLegendaryMultiShotModal(wm.weapon, wmCategory), 400);
          }
        }
      }
    }

    // Recalculate everything from baseline
    this.recalculateCombatBuffs();
    this.releaseBaselineIfClean();
    this.updateWeaponSpecDisplay();
    this.scheduleAutoSave();
  },

  /**
   * Deactivate all weapon specs via the baseline system
   */
  deactivateWeaponSpec() {
    const specs = this.character.activeWeaponSpecs || [];
    if (specs.length === 0) return;
    this.captureBaselineIfNeeded();
    this.character.activeWeaponSpecs = [];
    this.character.weaponSpecCritDoubled = false;
    delete this.character.legendaryMultiShot;
    this.recalculateCombatBuffs();
    this.releaseBaselineIfClean();
  },

  /**
   * Restore weapon spec visual state on page load.
   * Values are already baked into saved data. Re-apply CSS/titles and crit flag.
   * The baseline should also already be saved.
   */
  restoreWeaponSpecVisuals() {
    const activeSpecs = this.character.activeWeaponSpecs || [];
    if (activeSpecs.length === 0) return;

    const wm = this.character.weaponMaster;

    // Check if any active spec is mastered
    let anyMastered = false;
    let masteredTierData = null;
    if (wm && wm.weapon) {
      for (const key of activeSpecs) {
        const [w, t] = key.split('|');
        if (wm.weapon.toLowerCase() === w.toLowerCase() && wm.type === t) {
          anyMastered = true;
          masteredTierData = this.WEAPON_MASTER_TIERS[wm.tier] || this.WEAPON_MASTER_TIERS.master;
          break;
        }
      }
    }

    // Green styling on Combat Skill
    const skillInput = document.getElementById('combat-skill-1-percent');
    if (skillInput) {
      skillInput.classList.add('damage-boosted');
      if (anyMastered && masteredTierData) {
        skillInput.title = 'Critical doubled (' + masteredTierData.label + ')';
      } else {
        skillInput.title = 'Weapon Specialization: +5% Combat Skill';
      }
      // If Forceful Strike is also active, add its class too
      if (this.character.isForcefulStrikeActive) {
        skillInput.classList.add('forceful-penalized');
        skillInput.title += ' | Forceful Strike: -20%';
      }
    }

    const row = skillInput ? skillInput.closest('.combat-skill-row') : null;
    if (row) row.classList.add('weapon-spec-active-row');

    // Weapon Master specific weapon damage boost (if mastered weapon is active)
    if (anyMastered && wm && wm.tier) {
      const isMeleeOrShieldMaster = wm.type === 'Melee' || wm.type === 'Shield';
      if (isMeleeOrShieldMaster && masteredTierData) {
        const tierOrder = ['master', 'high', 'grand', 'legendary'];
        const tierIdx = tierOrder.indexOf(wm.tier);
        const dmSteps = tierIdx >= 2 ? 2 : 1;
        const tooltipText = `${masteredTierData.label}: +${dmSteps} step${dmSteps > 1 ? 's' : ''} DM`;
        this.applyDamageBoostToSpecificWeapon(wm.weapon, tooltipText);
      }
    }

    this.character.weaponSpecCritDoubled = anyMastered;

    // Restore Grand/Legendary reload reduction visuals
    if (anyMastered && wm && wm.type === 'Ranged') {
      const tierOrder = ['master', 'high', 'grand', 'legendary'];
      const tierIdx = tierOrder.indexOf(wm.tier);
      if (tierIdx >= 2) {
        const wmCategory = this._getWeaponMasterCategory(wm.weapon);
        let reloadReduction = 0;
        if (tierIdx >= 2) reloadReduction += 1;
        if (tierIdx >= 3 && wmCategory === 'crossbow') reloadReduction += 1;
        if (reloadReduction > 0) {
          // Re-apply visual tooltip to reload fields
          const rangedBody = document.getElementById('ranged-weapons-body');
          if (rangedBody) {
            const targetName = wm.weapon.toLowerCase().trim();
            rangedBody.querySelectorAll('tr').forEach(row => {
              const nameInput = row.querySelector('.weapon-name');
              if (!nameInput) return;
              if (!this._weaponNameMatches(nameInput.value.trim().toLowerCase(), targetName)) return;
              for (const input of row.querySelectorAll('input')) {
                if (input.id && input.id.includes('-load')) {
                  input.classList.add('damage-boosted');
                  const loadVal = parseInt(input.value, 10);
                  const freeNote = loadVal === 0 ? ' (Free Action!)' : '';
                  input.title = `${masteredTierData.label}: -${reloadReduction} Reload${freeNote}`;
                }
              }
            });
          }
        }
      }
    }

    // Restore multi-shot CS penalty visual
    const multiShot = this.character.legendaryMultiShot;
    if (multiShot && multiShot.count > 1 && anyMastered && wm && wm.tier === 'legendary' && wm.type === 'Ranged') {
      if (skillInput) {
        const existing = skillInput.title || '';
        skillInput.title = existing
          ? existing + ` | Multi-shot (${multiShot.count}): ${multiShot.csPenalty}%`
          : `Legendary Master Multi-shot (${multiShot.count}): ${multiShot.csPenalty}%`;
        skillInput.classList.add('forceful-penalized');
      }
    }
  },

  /**
   * Play activation animation based on tier
   */
  playWeaponMasterAnimation(weapon, type, tierData) {
    const flash = document.createElement('div');
    flash.style.cssText = `
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      z-index: 10002; pointer-events: none;
      background: radial-gradient(circle at center, ${tierData.glowColor} 0%, transparent 70%);
      animation: wmFlash 0.8s ease-out forwards;
    `;

    const weaponType = type === 'Ranged' ? 'ranged' : 'melee';
    const textPopup = document.createElement('div');
    textPopup.style.cssText = `
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 10003; pointer-events: none; text-align: center;
      animation: wmTextReveal 1.2s ease-out forwards;
    `;
    textPopup.innerHTML = `
      <div style="font-size: 2.5rem; margin-bottom: 0.3rem;">${tierData.icon}</div>
      <div style="font-size: 1.4rem; font-weight: bold; color: ${tierData.color};
        text-shadow: 0 0 20px ${tierData.glowColor}, 0 0 40px ${tierData.glowColor};
        letter-spacing: 2px; text-transform: uppercase;">
        ${tierData.label}
      </div>
      <div style="font-size: 0.95rem; color: #fff; margin-top: 0.3rem;
        text-shadow: 0 0 10px rgba(0,0,0,0.8);">
        ${weapon}
      </div>
      <div style="font-size: 0.75rem; color: #ccc; margin-top: 0.5rem; max-width: 300px;
        text-shadow: 0 0 10px rgba(0,0,0,0.8);">
        ${tierData.benefits[weaponType]}
      </div>
    `;

    document.body.appendChild(flash);
    document.body.appendChild(textPopup);

    setTimeout(() => {
      flash.remove();
      textPopup.remove();
    }, 1500);
  },

  /**
   * Calculate critical range for a skill value
   * Mythras: Critical = ceil(skill / 10)
   */
  calculateCriticalRange(skillValue) {
    if (!skillValue || skillValue <= 0) return 0;
    return Math.ceil(skillValue / 10);
  },

  // ============================================
  // RANGED SPEC LOAD REDUCTION (AUTOMATIC)
  // ============================================

  /**
   * Apply Load reduction (-1) to all ranged weapons that have a specialization
   */
  applyRangedSpecLoadReduction() {
    const specs = this.character.weaponSpecializations || [];
    const rangedSpecs = specs
      .filter(s => s.type === 'Ranged')
      .map(s => s.weapon.toLowerCase().replace(/\s*\(thrown\)/i, '').trim());

    // Check for Ranger Ranged spec (applies to ALL ranged weapons)
    const hasRangerRangedSpec = specs.some(s => s.type === 'Ranger Ranged');

    if (rangedSpecs.length === 0 && !hasRangerRangedSpec) return;

    const rangedBody = document.getElementById('ranged-weapons-body');
    if (!rangedBody) return;

    rangedBody.querySelectorAll('tr').forEach(row => {
      const nameInput = row.querySelector('.weapon-name');
      if (!nameInput || !nameInput.value.trim()) return;

      const weaponName = nameInput.value.trim().toLowerCase();
      
      // Ranger Ranged applies to ALL ranged weapons; regular spec matches specific weapon
      const isSpecialized = hasRangerRangedSpec || rangedSpecs.some(specName =>
        this._weaponNameMatches(weaponName, specName)
      );
      if (!isSpecialized) return;

      let loadInput = null;
      for (const input of row.querySelectorAll('input')) {
        if (input.id && input.id.includes('-load')) {
          loadInput = input;
          break;
        }
      }
      if (!loadInput) return;

      const currentLoad = loadInput.value.trim();
      if (currentLoad === '-' || currentLoad === '\u2013' || currentLoad === '') return;
      if (!loadInput.dataset.originalLoad) {
        loadInput.dataset.originalLoad = currentLoad;
      }
      if (loadInput.dataset.specReduced === 'true') return;

      const loadNum = parseInt(currentLoad, 10);
      if (isNaN(loadNum)) return;

      // Ranger Ranged Specialization: Faster Reload reduces by 2
      // Regular ranged weapon spec reduces by 1
      const reduction = hasRangerRangedSpec ? 2 : 1;
      loadInput.value = String(Math.max(0, loadNum - reduction));
      loadInput.dataset.specReduced = 'true';
      loadInput.classList.add('spec-load-reduced');
      const specLabel = hasRangerRangedSpec ? 'Ranger Ranged Specialization' : 'Weapon Specialization';
      loadInput.title = `Load reduced by ${reduction} (${specLabel}). Original: ${currentLoad}`;
    });
  },

  /**
   * Restore original Load values for ranged weapons
   */
  restoreRangedLoadValues() {
    const rangedBody = document.getElementById('ranged-weapons-body');
    if (!rangedBody) return;

    rangedBody.querySelectorAll('tr').forEach(row => {
      for (const input of row.querySelectorAll('input')) {
        if (input.id && input.id.includes('-load') && input.dataset.specReduced === 'true') {
          if (input.dataset.originalLoad) input.value = input.dataset.originalLoad;
          delete input.dataset.specReduced;
          delete input.dataset.originalLoad;
          input.classList.remove('spec-load-reduced');
          input.title = '';
        }
      }
    });
  },

  // ============================================
  // WEAPON ↔ EQUIPMENT BIDIRECTIONAL SYNC
  // ============================================

  /** Flag to prevent recursive sync loops */
  _weaponSyncing: false,

  /**
   * Determine if an item name is a weapon and what type it is.
   * Returns { isWeapon: true, type: 'melee'|'ranged'|'shield'|'dual', lookupKey: '...' } or { isWeapon: false }
   * 'dual' means the weapon exists in both melee and ranged databases (e.g., dagger, net, trident)
   */
  classifyWeaponByName(itemName) {
    if (!itemName) return { isWeapon: false };
    const lower = itemName.toLowerCase().trim();
    if (!lower || lower === 'unarmed') return { isWeapon: false };

    // Shield names
    const shieldNames = new Set([
      'buckler', 'buckler shield', 'heater', 'heater shield',
      'hoplite', 'hoplite shield', 'kite', 'kite shield',
      'peltast', 'peltast shield', 'round', 'round shield',
      'scutum', 'scutum shield', 'target', 'target shield',
      'tower', 'tower shield', 'viking', 'viking shield',
      'wooden shield'
    ]);

    // Check shields first (shields are melee weapons on the combat sheet)
    if (shieldNames.has(lower)) {
      return { isWeapon: true, type: 'shield', lookupKey: lower };
    }

    // Check both databases
    let meleeKey = null;
    let rangedKey = null;

    if (window.WeaponData && window.WeaponData.findWeaponKey) {
      meleeKey = window.WeaponData.findWeaponKey(lower);
      if (meleeKey && shieldNames.has(meleeKey)) {
        return { isWeapon: true, type: 'shield', lookupKey: meleeKey };
      }
    }

    if (window.WeaponData && window.WeaponData.findRangedWeaponKey) {
      rangedKey = window.WeaponData.findRangedWeaponKey(lower);
    }

    // Dual-category weapon (exists in both)
    if (meleeKey && rangedKey) {
      return { isWeapon: true, type: 'dual', lookupKey: meleeKey, rangedKey: rangedKey };
    }

    if (meleeKey) {
      return { isWeapon: true, type: 'melee', lookupKey: meleeKey };
    }

    if (rangedKey) {
      return { isWeapon: true, type: 'ranged', lookupKey: rangedKey };
    }

    return { isWeapon: false };
  },

  /**
   * Check if a weapon already exists on the combat page
   * @param {string} weaponName - Name to check
   * @param {string} type - 'melee' or 'ranged' (shields count as melee)
   * @returns {boolean}
   */
  weaponExistsOnCombatPage(weaponName, type) {
    const lower = weaponName.toLowerCase().trim();
    const bodyId = (type === 'melee' || type === 'shield') ? 'melee-weapons-body' : 'ranged-weapons-body';
    const body = document.getElementById(bodyId);
    if (!body) return false;

    const rows = body.querySelectorAll('tr');
    for (const row of rows) {
      const nameInput = row.querySelector('.weapon-name');
      if (nameInput && nameInput.value.trim()) {
        const existing = nameInput.value.toLowerCase().trim();
        if (existing === lower) return true;
        // Also match without 1H/2H prefix
        if (existing.replace(/^[12]h\s+/i, '') === lower) return true;
        if (lower.replace(/^[12]h\s+/i, '') === existing) return true;
      }
    }
    return false;
  },

  /**
   * Check if an item already exists in equipment
   * @param {string} itemName - Name to check
   * @returns {boolean}
   */
  itemExistsInEquipment(itemName) {
    const lower = itemName.toLowerCase().trim();
    const container = document.getElementById('equipment-container');
    if (!container) return false;

    const rows = container.querySelectorAll('.equipment-row');
    for (const row of rows) {
      const nameInput = row.querySelector('.equipment-name');
      if (nameInput && nameInput.value.trim()) {
        const existing = nameInput.value.toLowerCase().trim();
        if (existing === lower) return true;
        // Match with/without "shield" suffix
        if (existing.replace(/\s*shield$/i, '') === lower.replace(/\s*shield$/i, '')) return true;
      }
    }
    return false;
  },

  /**
   * Add a weapon to the combat page (melee or ranged) with autofill
   * @param {string} weaponName - Display name of the weapon
   * @param {string} type - 'melee', 'ranged', or 'shield'
   */
  addWeaponToCombatPage(weaponName, type) {
    if (!weaponName) return;
    const combatType = (type === 'shield') ? 'melee' : type;

    // Check if already exists
    if (this.weaponExistsOnCombatPage(weaponName, type)) return;

    if (combatType === 'melee') {
      this.addMeleeWeaponRow();
      const meleeBody = document.getElementById('melee-weapons-body');
      if (!meleeBody) return;
      const newIndex = meleeBody.querySelectorAll('tr').length - 1;
      const nameInput = document.getElementById(`melee-${newIndex}-name`);
      if (nameInput) {
        nameInput.value = this.toTitleCase(weaponName);
        if (window.WeaponData && window.WeaponData.autofillMeleeWeapon) {
          window.WeaponData.autofillMeleeWeapon(newIndex, nameInput.value);
        }
      }
    } else {
      this.addRangedWeaponRow();
      const rangedBody = document.getElementById('ranged-weapons-body');
      if (!rangedBody) return;
      const newIndex = rangedBody.querySelectorAll('tr').length - 1;
      const nameInput = document.getElementById(`ranged-${newIndex}-name`);
      if (nameInput) {
        nameInput.value = this.toTitleCase(weaponName);
        if (window.WeaponData && window.WeaponData.autofillRangedWeapon) {
          window.WeaponData.autofillRangedWeapon(newIndex, nameInput.value);
        }
      }
    }

    this.highlightSpecializedWeapons();
    // Apply load reduction after weapon sync
    this.applyRangedSpecLoadReduction();
    this.scheduleAutoSave();
  },

  /**
   * Add a weapon to the equipment list with ENC autofill
   * @param {string} weaponName - Display name of the weapon
   */
  addWeaponToEquipment(weaponName) {
    if (!weaponName) return;

    // Check if already exists
    if (this.itemExistsInEquipment(weaponName)) return;

    // Add new equipment row
    this.addEquipmentRow();
    const container = document.getElementById('equipment-container');
    if (!container) return;

    const rows = container.querySelectorAll('.equipment-row');
    const lastRow = rows[rows.length - 1];
    const nameInput = lastRow?.querySelector('.equipment-name');
    const rowIndex = rows.length - 1;

    if (nameInput) {
      nameInput.value = this.toTitleCase(weaponName);
      nameInput.dataset.previousValue = weaponName.toLowerCase();
      // Autofill ENC
      if (window.EncumbranceData) {
        window.EncumbranceData.autofillEquipmentEnc('equip', rowIndex, nameInput.value);
      }
      this.updateTotalEnc();
      this.updateContainerButtons();
    }

    this.scheduleAutoSave();
  },

  /**
   * Sync: Equipment → Combat page
   * Called when an equipment item is finalized (blur)
   * @param {string} itemName - The equipment item name
   */
  syncEquipmentToCombat(itemName) {
    if (this._weaponSyncing || this.isInitializing) return;
    this._weaponSyncing = true;

    try {
      const classification = this.classifyWeaponByName(itemName);
      if (classification.isWeapon) {
        if (classification.type === 'dual') {
          // Add to both melee and ranged
          this.addWeaponToCombatPage(itemName, 'melee');
          this.addWeaponToCombatPage(itemName, 'ranged');
        } else {
          this.addWeaponToCombatPage(itemName, classification.type);
        }
      }
    } finally {
      this._weaponSyncing = false;
    }
  },

  /**
   * Sync: Combat page → Equipment (and other combat section for dual weapons)
   * Called when a weapon name is finalized on the combat page (blur)
   * @param {string} weaponName - The weapon name
   * @param {string} sourceType - 'melee' or 'ranged' (which combat section triggered this)
   */
  syncCombatToEquipment(weaponName, sourceType) {
    if (this._weaponSyncing || this.isInitializing) return;
    if (!weaponName || weaponName.toLowerCase().trim() === 'unarmed') return;

    this._weaponSyncing = true;
    try {
      // Always add to equipment
      this.addWeaponToEquipment(weaponName);
      
      // Check if dual-category — if so, add to the OTHER combat section
      const classification = this.classifyWeaponByName(weaponName);
      if (classification.type === 'dual' && sourceType) {
        if (sourceType === 'melee') {
          this.addWeaponToCombatPage(weaponName, 'ranged');
        } else if (sourceType === 'ranged') {
          this.addWeaponToCombatPage(weaponName, 'melee');
        }
      }
    } finally {
      this._weaponSyncing = false;
    }
  },

  /**
   * Sync: Weapon Specialization → Equipment + Combat
   * Called when a weapon spec is finalized
   * @param {string} weaponName - The weapon name chosen
   * @param {string} type - 'Melee', 'Ranged', or 'Shield'
   */
  syncWeaponSpecToAll(weaponName, type) {
    if (type === 'Shield') return; // Shield spec applies to ALL shields, don't add a generic "shield"

    this._weaponSyncing = true;
    try {
      // Strip "(Thrown)" for equipment name
      const equipName = weaponName.replace(/\s*\(thrown\)/i, '');

      // Check if this is actually a dual-category weapon
      const classification = this.classifyWeaponByName(equipName);
      if (classification.type === 'dual') {
        this.addWeaponToCombatPage(equipName, 'melee');
        this.addWeaponToCombatPage(equipName, 'ranged');
      } else {
        this.addWeaponToCombatPage(equipName, type.toLowerCase());
      }
      
      this.addWeaponToEquipment(equipName);
    } finally {
      this._weaponSyncing = false;
    }
  },

  /**
   * Check if an item name is a weapon (used to block weapons from containers)
   */
  isWeaponItem(itemName) {
    if (!itemName) return false;
    return this.classifyWeaponByName(itemName).isWeapon;
  },

  /**
   * Show a brief warning when trying to put a weapon in a container
   */
  _showContainerWeaponWarning() {
    // Remove any existing warning
    const existing = document.querySelector('.container-weapon-warning');
    if (existing) existing.remove();

    const warning = document.createElement('div');
    warning.className = 'container-weapon-warning';
    warning.textContent = '⚔️ Weapons cannot be stored in containers — add them to Equipment instead.';
    warning.style.cssText = `
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      background: linear-gradient(135deg, #5a2d0c, #8b4513); color: #f5e6d3;
      padding: 10px 20px; border-radius: 8px; border: 1px solid #d4a574;
      font-family: 'Palatino Linotype', 'Book Antiqua', serif;
      font-size: 14px; z-index: 10000; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      animation: fadeInOut 3s ease-in-out forwards;
    `;

    // Add animation if not present
    if (!document.getElementById('container-weapon-warning-style')) {
      const style = document.createElement('style');
      style.id = 'container-weapon-warning-style';
      style.textContent = `
        @keyframes fadeInOut {
          0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
          15% { opacity: 1; transform: translateX(-50%) translateY(0); }
          75% { opacity: 1; }
          100% { opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }

    document.body.appendChild(warning);
    setTimeout(() => warning.remove(), 3000);
  },

  /**
   * Navigate to a specific page
   */
  navigateToPage(pageId) {
    const targetPage = document.getElementById(pageId);
    if (targetPage) {
      // Save scroll position of current page before switching
      if (this.currentPageId) {
        this.pageScrollPositions[this.currentPageId] = window.scrollY;
      }
      
      // Hide all pages
      document.querySelectorAll('.sheet-page').forEach(page => {
        page.classList.remove('active');
      });
      // Show target page
      targetPage.classList.add('active');
      // Update nav
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.page === pageId) {
          btn.classList.add('active');
        }
      });
      
      // Extract page name from pageId (e.g., 'page-magic1' -> 'magic1')
      const pageName = pageId.replace('page-', '');
      this.currentPageId = pageName;
      
      // Restore scroll position for target page (or scroll to top if none saved)
      const savedScroll = this.pageScrollPositions[pageName];
      if (savedScroll !== undefined) {
        window.scrollTo(0, savedScroll);
      } else {
        window.scrollTo(0, 0);
      }
      
      // Store current page
      try {
        localStorage.setItem('mythras-current-page', pageName);
      } catch (e) {}
      
      // If navigating to magic pages, sync professional skill values
      if (pageId === 'page-magic1' || pageId === 'page-magic2') {
        this.syncProfessionalSkillsToMagicPage();
      }
      
      // If navigating to combat page, update weapon damages and re-apply damage boost styling
      if (pageId === 'page-combat') {
        if (window.WeaponData && window.WeaponData.updateAllWeaponDamage) {
          window.WeaponData.updateAllWeaponDamage();
        }
        this.reapplyDamageBoostStyling();
        this.highlightSpecializedWeapons();
      }
    }
  },

  /**
   * Ensure all penalty-eligible fields have dataset.originalValue set.
   * Called once on load after populateForm.
   */
  initializeOriginalValues() {
    // Standard skills
    document.querySelectorAll('.skill-input').forEach(input => {
      if (input.value && input.dataset.originalValue === undefined) {
        input.dataset.originalValue = input.value;
      }
    });
    
    // Professional skills
    for (let i = 0; i < PROFESSIONAL_SKILL_SLOTS; i++) {
      const input = document.getElementById(`prof-skill-${i}-current`);
      if (input && input.value && input.dataset.originalValue === undefined) {
        input.dataset.originalValue = input.value;
      }
    }
    
    // Combat skills
    ['combat-skill-1-percent', 'unarmed-percent'].forEach(id => {
      const input = document.getElementById(id);
      if (input && input.value && input.dataset.originalValue === undefined) {
        input.dataset.originalValue = input.value;
      }
    });
    
    // Magic skills
    const magicSkillIds = [
      'channel-percent', 'piety-percent', 
      'arcane-casting-percent', 'arcane-knowledge-percent',
      'arcane-sorcery-percent', 'sorcerous-wisdom-percent',
      'musicianship-percent', 'lyrical-magic-percent'
    ];
    magicSkillIds.forEach(id => {
      const input = document.getElementById(id);
      if (input && input.value && input.dataset.originalValue === undefined) {
        input.dataset.originalValue = input.value;
      }
    });
    
    // Initiative
    const initCurrent = document.getElementById('initiative-current');
    if (initCurrent && initCurrent.value && initCurrent.dataset.originalValue === undefined) {
      initCurrent.dataset.originalValue = initCurrent.value;
    }
    
    // Movement
    const moveCurrent = document.getElementById('movement-current');
    if (moveCurrent && moveCurrent.value && moveCurrent.dataset.originalValue === undefined) {
      moveCurrent.dataset.originalValue = moveCurrent.value;
    }
    
    // Action Points
    const apOriginal = document.getElementById('action-points-original');
    if (apOriginal && apOriginal.value && apOriginal.dataset.originalValue === undefined) {
      apOriginal.dataset.originalValue = apOriginal.value;
    }
    const apCurrent = document.getElementById('action-points-current');
    if (apCurrent && apCurrent.value && apCurrent.dataset.originalValue === undefined) {
      apCurrent.dataset.originalValue = apCurrent.value;
    }
  },

  /**
   * Get current ENC status. Centralized helper.
   */
  getCurrentEncStatus() {
    if (!this.character.encAutomation) {
      return { name: 'Unburdened', penaltyPercent: 0, initiativePenalty: 0, movementPenalty: 0 };
    }
    const totalEnc = parseFloat(document.getElementById('total-enc')?.textContent) || 0;
    const STR = parseInt(this.character.attributes?.STR) || 0;
    return Calculator.getEncStatus(totalEnc, STR);
  },

  /**
   * CENTRAL PENALTY ENGINE
   * Applies both ENC and Fatigue penalties to all affected fields.
   * Called whenever ENC or Fatigue state changes.
   */
  applyAllPenalties() {
    const encStatus = this.getCurrentEncStatus();
    const fatigueState = this.character.fatigueState || 'fresh';
    const fatigue = FATIGUE_PENALTIES[fatigueState] || FATIGUE_PENALTIES.fresh;
    
    const encHasPenalty = (encStatus.name === 'Burdened' || encStatus.name === 'Overburdened');
    const encPenaltyPercent = encHasPenalty ? (encStatus.penaltyPercent || 0) : 0;
    const encIsBurdened = encStatus.name === 'Burdened';
    
    const fatigueHasPenalty = fatigue.skillPenalty > 0;
    const fatigueSevere = fatigue.skillPenalty >= 60; // Herculean or worse
    
    // --- SKILLS ---
    // Reset display bonus flags since penalties restore from base originalValue
    this.artfulDodgerDisplayed = false;
    this.lightningReflexesDisplayed = false;
    this._lightningReflexesBonus = 0;
    this.applySkillPenalties(encPenaltyPercent, encIsBurdened, encHasPenalty, fatigue);
    
    // --- INITIATIVE ---
    this.agileDisplayed = false;
    this.veryAgileDisplayed = false;
    this._veryAgileBonus = 0;
    this.applyInitiativePenalty(encStatus, fatigue);
    
    // --- MOVEMENT ---
    this.applyMovementPenalty(encStatus, fatigue);
    
    // --- ACTION POINTS ---
    this.applyActionPointPenalty(fatigue);
    
    // --- Re-apply display-only ability bonuses (Artful Dodger, Lightning Reflexes, Agile, Very Agile) ---
    // These were reset when penalties restored base values from originalValue
    if (!this.isInitializing) {
      this.updateArtfulDodgerDisplay();
      this.updateLightningReflexesDisplay();
      this.updateAgileDisplay();
      this.updateVeryAgileDisplay();
    }
    
    // --- Update combat quick ref ---
    this.updateCombatQuickRef();
  },

  /**
   * Apply combined ENC + Fatigue penalties to all skill fields
   */
  applySkillPenalties(encPenaltyPercent, encIsBurdened, encHasPenalty, fatigue) {
    const fatigueSkillPenalty = fatigue.skillPenalty || 0;
    const fatigueSevere = fatigueSkillPenalty >= 60;
    const fatigueActive = fatigueSkillPenalty > 0;
    
    // --- Standard Skills ---
    document.querySelectorAll('.skill-row').forEach(row => {
      const hasEncIndicator = row.querySelector('.enc-indicator') !== null;
      const input = row.querySelector('.skill-input');
      if (!input) return;
      
      // Store original if not set
      if (input.dataset.originalValue === undefined && input.value) {
        input.dataset.originalValue = input.value;
      }
      
      const originalValue = parseInt(input.dataset.originalValue) || 0;
      const encPenalty = hasEncIndicator ? encPenaltyPercent : 0;
      const totalPenalty = encPenalty + fatigueSkillPenalty;
      const hasPenalty = totalPenalty > 0 && originalValue > 0;
      
      // Clear previous penalty classes
      input.classList.remove('enc-penalized-value', 'enc-burdened-penalty', 'fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
      
      if (hasPenalty) {
        const penalizedValue = Math.max(0, originalValue - totalPenalty);
        input.value = penalizedValue;
        
        // Build tooltip
        let tooltipParts = [`Original: ${originalValue}%`];
        if (encPenalty > 0) tooltipParts.push(`ENC: -${encPenalty}%`);
        if (fatigueSkillPenalty > 0) tooltipParts.push(`Fatigue (${fatigue.skillGrade}): -${fatigueSkillPenalty}%`);
        tooltipParts.push(`Effective: ${penalizedValue}%`);
        input.title = tooltipParts.join(', ');
        
        // Apply appropriate CSS classes
        if (encPenalty > 0) {
          input.classList.add('enc-penalized-value');
          if (encIsBurdened) input.classList.add('enc-burdened-penalty');
        }
        if (fatigueActive) {
          input.classList.add('fatigue-penalized');
          if (fatigueSevere) input.classList.add('fatigue-severe');
        }
        if (!fatigue.canAct) {
          input.classList.add('fatigue-incapacitated');
        }
      } else if (input.dataset.originalValue !== undefined) {
        input.value = input.dataset.originalValue;
        input.title = '';
      }
    });
    
    // --- Professional Skills ---
    for (let i = 0; i < PROFESSIONAL_SKILL_SLOTS; i++) {
      const encIndicator = document.getElementById(`prof-skill-${i}-enc`);
      const hasEncIndicator = encIndicator && encIndicator.style.display !== 'none';
      const input = document.getElementById(`prof-skill-${i}-current`);
      if (!input) continue;
      
      if (input.dataset.originalValue === undefined && input.value) {
        input.dataset.originalValue = input.value;
      }
      
      const originalValue = parseInt(input.dataset.originalValue) || 0;
      const encPenalty = hasEncIndicator ? encPenaltyPercent : 0;
      const totalPenalty = encPenalty + fatigueSkillPenalty;
      const hasPenalty = totalPenalty > 0 && originalValue > 0;
      
      input.classList.remove('enc-penalized-value', 'enc-burdened-penalty', 'fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
      
      if (hasPenalty) {
        const penalizedValue = Math.max(0, originalValue - totalPenalty);
        input.value = penalizedValue;
        
        let tooltipParts = [`Original: ${originalValue}%`];
        if (encPenalty > 0) tooltipParts.push(`ENC: -${encPenalty}%`);
        if (fatigueSkillPenalty > 0) tooltipParts.push(`Fatigue (${fatigue.skillGrade}): -${fatigueSkillPenalty}%`);
        tooltipParts.push(`Effective: ${penalizedValue}%`);
        input.title = tooltipParts.join(', ');
        
        if (encPenalty > 0) {
          input.classList.add('enc-penalized-value');
          if (encIsBurdened) input.classList.add('enc-burdened-penalty');
        }
        if (fatigueActive) {
          input.classList.add('fatigue-penalized');
          if (fatigueSevere) input.classList.add('fatigue-severe');
        }
        if (!fatigue.canAct) input.classList.add('fatigue-incapacitated');
      } else if (input.dataset.originalValue !== undefined) {
        input.value = input.dataset.originalValue;
        input.title = '';
      }
    }
    
    // --- Combat Skills (STR+DEX based, always ENC-affected; fatigue affects all) ---
    const combatSkillInputs = document.querySelectorAll('.enc-affected-combat');
    combatSkillInputs.forEach(input => {
      if (input.dataset.originalValue === undefined && input.value) {
        input.dataset.originalValue = input.value;
      }
      
      const originalValue = parseInt(input.dataset.originalValue) || 0;
      const totalPenalty = encPenaltyPercent + fatigueSkillPenalty;
      const hasPenalty = totalPenalty > 0 && originalValue > 0;
      
      input.classList.remove('enc-penalized-value', 'enc-burdened-penalty', 'fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
      
      if (hasPenalty) {
        const penalizedValue = Math.max(0, originalValue - totalPenalty);
        input.value = penalizedValue;
        
        let tooltipParts = [`Original: ${originalValue}%`];
        if (encPenaltyPercent > 0) tooltipParts.push(`ENC: -${encPenaltyPercent}%`);
        if (fatigueSkillPenalty > 0) tooltipParts.push(`Fatigue (${fatigue.skillGrade}): -${fatigueSkillPenalty}%`);
        tooltipParts.push(`Effective: ${penalizedValue}%`);
        input.title = tooltipParts.join(', ');
        
        if (encPenaltyPercent > 0) {
          input.classList.add('enc-penalized-value');
          if (encIsBurdened) input.classList.add('enc-burdened-penalty');
        }
        if (fatigueActive) {
          input.classList.add('fatigue-penalized');
          if (fatigueSevere) input.classList.add('fatigue-severe');
        }
        if (!fatigue.canAct) input.classList.add('fatigue-incapacitated');
      } else if (input.dataset.originalValue !== undefined) {
        input.value = input.dataset.originalValue;
        input.title = '';
      }
    });
    
    // --- Magic Skills (ENC + Fatigue penalties apply) ---
    const magicSkillIds = [
      'channel-percent', 'piety-percent', 
      'arcane-casting-percent', 'arcane-knowledge-percent',
      'arcane-sorcery-percent', 'sorcerous-wisdom-percent',
      'musicianship-percent', 'lyrical-magic-percent'
    ];
    
    magicSkillIds.forEach(id => {
      const input = document.getElementById(id);
      if (!input) return;
      
      if (input.dataset.originalValue === undefined && input.value) {
        input.dataset.originalValue = input.value;
      }
      
      const originalValue = parseInt(input.dataset.originalValue) || 0;
      const encPenalty = encHasPenalty ? encPenaltyPercent : 0;
      const totalPenalty = encPenalty + fatigueSkillPenalty;
      const hasPenalty = totalPenalty > 0 && originalValue > 0;
      
      input.classList.remove('enc-penalized-value', 'enc-burdened-penalty', 'fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
      
      if (hasPenalty) {
        const penalizedValue = Math.max(0, originalValue - totalPenalty);
        input.value = penalizedValue;
        
        let tooltipParts = [`Original: ${originalValue}%`];
        if (encPenalty > 0) tooltipParts.push(`ENC: -${encPenalty}%`);
        if (fatigueSkillPenalty > 0) tooltipParts.push(`Fatigue (${fatigue.skillGrade}): -${fatigueSkillPenalty}%`);
        tooltipParts.push(`Effective: ${penalizedValue}%`);
        input.title = tooltipParts.join(', ');
        
        if (encPenalty > 0) {
          input.classList.add('enc-penalized-value');
          if (encIsBurdened) input.classList.add('enc-burdened-penalty');
        }
        if (fatigueActive) {
          input.classList.add('fatigue-penalized');
          if (fatigueSevere) input.classList.add('fatigue-severe');
        }
        if (!fatigue.canAct) input.classList.add('fatigue-incapacitated');
      } else if (input.dataset.originalValue !== undefined) {
        input.value = input.dataset.originalValue;
        input.title = '';
      }
    });
  },

  /**
   * Apply combined ENC + Fatigue penalty to Initiative
   */
  // ============================================
  // INITIATIVE D10 ROLL
  // ============================================
  
  openInitiativeRollModal() {
    let modal = document.getElementById('init-roll-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'init-roll-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    const currentInit = parseInt(document.getElementById('initiative-current')?.value, 10) || 0;
    
    modal.innerHTML = `
      <div class="modal-content scratch-modal-content" style="max-width: 320px; text-align: center;">
        <div class="modal-header">
          <h3>🎲 Initiative Roll</h3>
          <button class="modal-close" id="init-roll-close">&times;</button>
        </div>
        <div class="modal-body">
          <p style="font-size: 0.9rem;">Ready to roll for Initiative?</p>
          <p style="font-size: 0.8rem; color: #999;">Current Initiative bonus: <strong>${currentInit}</strong></p>
        </div>
        <div class="modal-footer" style="justify-content: center; gap: 0.75rem;">
          <button type="button" class="btn btn-secondary" id="init-roll-cancel">Cancel</button>
          <button type="button" class="btn btn-primary" id="init-roll-yes">Roll!</button>
        </div>
      </div>
    `;
    
    document.getElementById('init-roll-close').addEventListener('click', () => modal.classList.add('hidden'));
    document.getElementById('init-roll-cancel').addEventListener('click', () => modal.classList.add('hidden'));
    modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.add('hidden'); });
    
    document.getElementById('init-roll-yes').addEventListener('click', () => {
      modal.classList.add('hidden');
      this.rollInitiativeD10();
    });
    
    modal.classList.remove('hidden');
  },
  
  rollInitiativeD10() {
    const d10 = Math.floor(Math.random() * 10) + 1;
    const currentInit = parseInt(document.getElementById('initiative-current')?.value, 10) || 0;
    const total = currentInit + d10;
    
    // Show result modal
    let modal = document.getElementById('init-result-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'init-result-modal';
      modal.className = 'modal-overlay hidden';
      document.body.appendChild(modal);
    }
    
    modal.innerHTML = `
      <div class="modal-content scratch-modal-content" style="max-width: 320px; text-align: center;">
        <div class="modal-header">
          <h3>🎲 Initiative Result</h3>
          <button class="modal-close" id="init-result-close">&times;</button>
        </div>
        <div class="modal-body" style="padding: 1rem;">
          <div style="font-size: 0.8rem; color: #999; margin-bottom: 0.5rem;">
            Base ${currentInit} + d10 roll: ${d10}
          </div>
          <div style="font-size: 2rem; font-weight: bold; color: #4fc3f7; margin: 0.5rem 0;">
            ${total}
          </div>
          <div style="font-size: 0.95rem;">
            Your Initiative for this combat is <strong>${total}</strong>.
          </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
          <button type="button" class="btn btn-primary" id="init-result-ok">OK</button>
        </div>
      </div>
    `;
    
    const closeModal = () => modal.classList.add('hidden');
    document.getElementById('init-result-close').addEventListener('click', closeModal);
    document.getElementById('init-result-ok').addEventListener('click', closeModal);
    modal.addEventListener('click', (e) => { if (e.target === modal) closeModal(); });
    
    modal.classList.remove('hidden');
  },
  
  applyInitiativePenalty(encStatus, fatigue) {
    const initCurrent = document.getElementById('initiative-current');
    if (!initCurrent) return;
    
    if (initCurrent.dataset.originalValue === undefined && initCurrent.value) {
      initCurrent.dataset.originalValue = initCurrent.value;
    }
    
    const originalInit = parseInt(initCurrent.dataset.originalValue) || 0;
    const encInitPenalty = encStatus.initiativePenalty || 0;
    const fatigueInitPenalty = fatigue.canAct ? (fatigue.initiativePenalty || 0) : originalInit; // if can't act, zero it
    const totalPenalty = encInitPenalty + fatigueInitPenalty;
    const hasPenalty = totalPenalty > 0;
    
    const encHasPenalty = (encStatus.name === 'Burdened' || encStatus.name === 'Overburdened');
    const penaltyClass = encStatus.name === 'Burdened' ? 'burdened' : 'overburdened';
    
    initCurrent.classList.remove('enc-penalty-init-move', 'burdened', 'overburdened', 'fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
    
    if (hasPenalty) {
      const penalizedInit = fatigue.canAct ? Math.max(0, originalInit - totalPenalty) : 0;
      initCurrent.value = penalizedInit;
      
      let tooltipParts = [`Original: ${originalInit}`];
      if (encInitPenalty > 0) tooltipParts.push(`ENC: -${encInitPenalty}`);
      if (fatigue.initiativePenalty > 0) tooltipParts.push(`Fatigue: -${fatigue.initiativePenalty}`);
      if (!fatigue.canAct) tooltipParts.push('Fatigue: Incapacitated');
      initCurrent.title = tooltipParts.join(', ');
      
      if (encHasPenalty && encInitPenalty > 0) {
        initCurrent.classList.add('enc-penalty-init-move', penaltyClass);
      }
      if (fatigue.initiativePenalty > 0 || !fatigue.canAct) {
        initCurrent.classList.add('fatigue-penalized');
        if (fatigue.skillPenalty >= 60) initCurrent.classList.add('fatigue-severe');
        if (!fatigue.canAct) initCurrent.classList.add('fatigue-incapacitated');
      }
    } else {
      initCurrent.value = initCurrent.dataset.originalValue;
      initCurrent.title = '';
    }
  },

  /**
   * Apply combined ENC + Fatigue penalty to Movement
   * Order: Start with original → subtract ENC → apply fatigue modifier
   */
  applyMovementPenalty(encStatus, fatigue) {
    const moveCurrent = document.getElementById('movement-current');
    if (!moveCurrent) return;
    
    if (moveCurrent.dataset.originalValue === undefined && moveCurrent.value) {
      moveCurrent.dataset.originalValue = moveCurrent.value;
    }
    
    const originalMove = parseInt(moveCurrent.dataset.originalValue) || 0;
    const encMovePenalty = encStatus.movementPenalty || 0;
    
    // Step 1: Apply ENC (flat subtraction)
    const afterEnc = Math.max(0, originalMove - encMovePenalty);
    
    // Step 2: Apply Fatigue on the ENC-adjusted value
    let finalMove = afterEnc;
    switch (fatigue.movementType) {
      case 'none':
        finalMove = afterEnc;
        break;
      case 'flat':
        finalMove = Math.max(0, afterEnc - fatigue.movementFlat);
        break;
      case 'halve':
        finalMove = Math.max(0, Math.floor(afterEnc / 2));
        break;
      case 'zero':
        finalMove = 0;
        break;
    }
    
    const encHasPenalty = (encStatus.name === 'Burdened' || encStatus.name === 'Overburdened');
    const penaltyClass = encStatus.name === 'Burdened' ? 'burdened' : 'overburdened';
    const hasPenalty = (encMovePenalty > 0) || (fatigue.movementType !== 'none');
    
    moveCurrent.classList.remove('enc-penalty-init-move', 'burdened', 'overburdened', 'fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
    
    if (hasPenalty) {
      moveCurrent.value = finalMove;
      
      let tooltipParts = [`Original: ${originalMove}'`];
      if (encMovePenalty > 0) tooltipParts.push(`ENC: -${encMovePenalty}'`);
      if (fatigue.movementType === 'flat') tooltipParts.push(`Fatigue: -${fatigue.movementFlat}'`);
      else if (fatigue.movementType === 'halve') tooltipParts.push('Fatigue: halved');
      else if (fatigue.movementType === 'zero') tooltipParts.push('Fatigue: immobile');
      tooltipParts.push(`Effective: ${finalMove}'`);
      moveCurrent.title = tooltipParts.join(', ');
      
      if (encHasPenalty && encMovePenalty > 0) {
        moveCurrent.classList.add('enc-penalty-init-move', penaltyClass);
      }
      if (fatigue.movementType !== 'none') {
        moveCurrent.classList.add('fatigue-penalized');
        if (fatigue.skillPenalty >= 60) moveCurrent.classList.add('fatigue-severe');
        if (!fatigue.canAct) moveCurrent.classList.add('fatigue-incapacitated');
      }
      
      // Update movement speed display
      this.updateMovementDisplayWithCombinedPenalty(finalMove, encHasPenalty, fatigue);
    } else {
      moveCurrent.value = moveCurrent.dataset.originalValue;
      moveCurrent.title = '';
      this.updateMovementDisplay();
    }
  },

  /**
   * Update movement speed display with combined ENC + Fatigue styling
   */
  updateMovementDisplayWithCombinedPenalty(baseMove, encHasPenalty, fatigue) {
    const speeds = Calculator.calculateMovement(baseMove);
    
    const elements = ['walk-speed', 'run-speed', 'sprint-speed', 'swim-speed', 'climb-speed']
      .map(id => document.getElementById(id))
      .filter(Boolean);
    
    const penaltyClass = encHasPenalty ? 'burdened' : '';
    
    elements.forEach(el => {
      el.classList.remove('enc-penalty-init-move', 'burdened', 'overburdened', 'fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
      if (encHasPenalty) el.classList.add('enc-penalty-init-move', penaltyClass);
      if (fatigue.movementType !== 'none') {
        el.classList.add('fatigue-penalized');
        if (fatigue.skillPenalty >= 60) el.classList.add('fatigue-severe');
        if (!fatigue.canAct) el.classList.add('fatigue-incapacitated');
      }
    });
    
    const walkEl = document.getElementById('walk-speed');
    const runEl = document.getElementById('run-speed');
    const sprintEl = document.getElementById('sprint-speed');
    const swimEl = document.getElementById('swim-speed');
    const climbEl = document.getElementById('climb-speed');
    
    if (walkEl) walkEl.textContent = `${speeds.walk}'`;
    if (runEl) runEl.textContent = `${speeds.run}'`;
    if (sprintEl) sprintEl.textContent = `${speeds.sprint}'`;
    if (swimEl) swimEl.textContent = `${speeds.swim}'`;
    if (climbEl) climbEl.textContent = `${speeds.climb}'`;
  },

  /**
   * Apply Fatigue penalty to Action Points
   */
  applyActionPointPenalty(fatigue) {
    const apOriginal = document.getElementById('action-points-original');
    const apCurrent = document.getElementById('action-points-current');
    if (!apOriginal || !apCurrent) return;
    
    // Store original max AP
    if (apOriginal.dataset.originalValue === undefined && apOriginal.value) {
      apOriginal.dataset.originalValue = apOriginal.value;
    }
    if (apCurrent.dataset.originalValue === undefined && apCurrent.value) {
      apCurrent.dataset.originalValue = apCurrent.value;
    }
    
    const originalMax = parseInt(apOriginal.dataset.originalValue) || 2;
    const originalCurrent = parseInt(apCurrent.dataset.originalValue) || originalMax;
    const apPenalty = fatigue.canAct ? (fatigue.apPenalty || 0) : originalMax;
    
    apOriginal.classList.remove('fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
    apCurrent.classList.remove('fatigue-penalized', 'fatigue-severe', 'fatigue-incapacitated');
    
    if (apPenalty > 0) {
      const newMax = fatigue.canAct ? Math.max(0, originalMax - apPenalty) : 0;
      const newCurrent = Math.min(originalCurrent, newMax);
      
      apOriginal.value = newMax;
      apCurrent.value = newCurrent;
      
      apOriginal.title = `Original Max: ${originalMax}, Fatigue: -${fatigue.canAct ? apPenalty : 'All'}`;
      apOriginal.classList.add('fatigue-penalized');
      apCurrent.classList.add('fatigue-penalized');
      if (fatigue.skillPenalty >= 60) {
        apOriginal.classList.add('fatigue-severe');
        apCurrent.classList.add('fatigue-severe');
      }
      if (!fatigue.canAct) {
        apOriginal.classList.add('fatigue-incapacitated');
        apCurrent.classList.add('fatigue-incapacitated');
      }
    } else {
      // Restore originals
      apOriginal.value = apOriginal.dataset.originalValue;
      apCurrent.value = apCurrent.dataset.originalValue;
      apOriginal.title = '';
    }
  },
  camelCase(str) {
    return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
  },

  /**
   * Utility: Convert camelCase to kebab-case
   */
  kebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
  },
  
  /**
   * Utility: Convert string to Title Case
   * Preserves parenthetical parts and handles special cases like Roman numerals
   */
  toTitleCase(str) {
    if (!str) return '';
    
    // Words that should stay lowercase (unless first word)
    const lowercaseWords = ['a', 'an', 'the', 'and', 'but', 'or', 'for', 'nor', 'on', 'at', 'to', 'from', 'by', 'of', 'in', 'with', 'vs'];
    
    // Words that should stay uppercase (Roman numerals, abbreviations)
    const uppercaseWords = ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x', 'xi', 'xii'];
    
    return str.split(' ').map((word, index) => {
      // Handle parenthetical parts
      if (word.startsWith('(')) {
        const inner = word.slice(1);
        return '(' + this.toTitleCase(inner);
      }
      if (word.endsWith(')')) {
        const inner = word.slice(0, -1);
        return this.toTitleCase(inner) + ')';
      }
      
      const lowerWord = word.toLowerCase();
      
      // Check for Roman numerals
      if (uppercaseWords.includes(lowerWord)) {
        return word.toUpperCase();
      }
      
      // First word is always capitalized
      if (index === 0) {
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      }
      
      // Lowercase words stay lowercase (unless first)
      if (lowercaseWords.includes(lowerWord)) {
        return lowerWord;
      }
      
      // Normal capitalization
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    }).join(' ');
  },
  
  // ==================== SUMMARY PAGE ====================
  
  /**
   * Available widget definitions
   */
  summaryWidgets: {
    'character-info': {
      name: 'Character Info',
      icon: '👤',
      render: () => {
        const name = document.getElementById('character-name')?.value || 'Unnamed';
        const species = document.getElementById('species')?.value || '-';
        const culture = document.getElementById('culture')?.value || '-';
        const primaryClass = document.getElementById('class-primary')?.value || '-';
        const rank = document.getElementById('rank-primary')?.value || '0';
        const rankName = document.getElementById('rank-name')?.value || '-';
        const height = document.getElementById('height')?.value || '-';
        const weight = document.getElementById('weight')?.value || '-';
        const age = document.getElementById('age')?.value || '-';
        const handedness = document.getElementById('handedness')?.value || '-';
        const hair = document.getElementById('hair')?.value || '-';
        const eyes = document.getElementById('eyes')?.value || '-';
        const expRolls = document.getElementById('exp-rolls')?.value || '0';
        const tenacityCurrent = document.getElementById('tenacity-current')?.value || '-';
        const tenacityMax = document.getElementById('tenacity-max')?.value || '-';
        
        return `
          <h4>Character Info</h4>
          <div class="stat-row"><span class="stat-label">Name:</span><span class="stat-value">${name}</span></div>
          <div class="stat-row"><span class="stat-label">Species:</span><span class="stat-value">${species}</span></div>
          <div class="stat-row"><span class="stat-label">Culture:</span><span class="stat-value">${culture}</span></div>
          <div class="stat-row"><span class="stat-label">Class:</span><span class="stat-value">${primaryClass} (Rank ${rank})</span></div>
          <div class="stat-row"><span class="stat-label">Rank Name:</span><span class="stat-value">${rankName}</span></div>
          <div class="stat-row"><span class="stat-label">Height:</span><span class="stat-value">${height}</span></div>
          <div class="stat-row"><span class="stat-label">Weight:</span><span class="stat-value">${weight}</span></div>
          <div class="stat-row"><span class="stat-label">Age:</span><span class="stat-value">${age}</span></div>
          <div class="stat-row"><span class="stat-label">Handedness:</span><span class="stat-value">${handedness}</span></div>
          <div class="stat-row"><span class="stat-label">Hair:</span><span class="stat-value">${hair}</span></div>
          <div class="stat-row"><span class="stat-label">Eyes:</span><span class="stat-value">${eyes}</span></div>
          <hr style="border:none;border-top:1px solid #ccc;margin:8px 0;">
          <div class="stat-row">
            <span class="stat-label">EXP Rolls:</span>
            <span class="stat-value-bold">${expRolls}</span>
            <button type="button" class="btn btn-small widget-exp-btn" style="margin-left:8px;font-size:0.7rem;padding:2px 6px;">Spend EXP</button>
          </div>
          <div class="stat-row"><span class="stat-label">Tenacity:</span><span class="stat-value">${tenacityCurrent} / ${tenacityMax}</span></div>
        `;
      }
    },
    'characteristics': {
      name: 'Characteristics',
      icon: '💪',
      render: () => {
        const chars = ['STR', 'CON', 'SIZ', 'DEX', 'INT', 'POW', 'CHA'];
        let boxes = '';
        chars.forEach(c => {
          const val = document.getElementById(`${c.toLowerCase()}-value`)?.value || '-';
          boxes += `<div class="stat-box"><div class="label">${c}</div><div class="value">${val}</div></div>`;
        });
        return `<h4>Characteristics</h4><div class="stat-grid">${boxes}</div>`;
      }
    },
    'attributes': {
      name: 'Attributes',
      icon: '📊',
      render: () => {
        const ap = document.getElementById('action-points-current')?.value || '-';
        const dmg = document.getElementById('damage-mod-current')?.value || '-';
        const init = document.getElementById('initiative-current')?.value || '-';
        const luck = document.getElementById('luck-current')?.value || '-';
        const mp = document.getElementById('magic-points-current')?.value || '-';
        return `
          <h4>Attributes</h4>
          <div class="stat-row"><span class="stat-label">Action Points:</span><span class="stat-value-bold">${ap}</span></div>
          <div class="stat-row"><span class="stat-label">Damage Modifier:</span><span class="stat-value-bold">${dmg}</span></div>
          <div class="stat-row"><span class="stat-label">Initiative:</span><span class="stat-value-bold">${init}</span></div>
          <div class="stat-row"><span class="stat-label">Luck Points:</span><span class="stat-value-bold">${luck}</span></div>
          <div class="stat-row"><span class="stat-label">Magic Points:</span><span class="stat-value-bold">${mp}</span></div>
        `;
      }
    },
    'hp-overview': {
      name: 'Hit Points',
      icon: '❤️',
      render: () => {
        let html = '<h4>Hit Points</h4><div class="hp-overview">';
        for (let i = 0; i < 7; i++) {
          const hp = document.getElementById(`loc-${i}-hp`)?.value || '-';
          const current = document.getElementById(`loc-${i}-current`)?.value || hp;
          const locNames = ['R.Leg', 'L.Leg', 'Abdom', 'Chest', 'R.Arm', 'L.Arm', 'Head'];
          const damaged = current !== hp && current !== '' && hp !== '';
          html += `<div class="hp-location${damaged ? ' damaged' : ''}">
            <div class="loc-name">${locNames[i] || 'Loc'}</div>
            <div class="loc-hp">${current}/${hp}</div>
          </div>`;
        }
        html += '</div>';
        return html;
      }
    },
    'combat': {
      name: 'Combat',
      icon: '⚔️',
      render: () => {
        // Get combat stats
        const initiative = document.getElementById('initiative-current')?.value || '-';
        const actionPointsMax = document.getElementById('action-points-original')?.value || '2';
        const actionPointsCurrent = document.getElementById('action-points-current')?.value || actionPointsMax;
        const luckPointsMax = document.getElementById('luck-original')?.value || '2';
        const luckPointsCurrent = document.getElementById('luck-current')?.value || luckPointsMax;
        const magicPointsMax = document.getElementById('magic-points-original')?.value || '0';
        const magicPointsCurrent = document.getElementById('magic-points-current')?.value || magicPointsMax;
        
        const combatName = document.getElementById('combat-skill-1-name')?.value || 'Combat Style';
        const combatPct = document.getElementById('combat-skill-1-percent')?.value || '-';
        const unarmedPct = document.getElementById('unarmed-percent')?.value || '-';
        
        let html = `
          <h4>Combat</h4>
          <div class="combat-stats-grid two-col">
            <div class="combat-stat">
              <span class="stat-label">Initiative</span>
              <span class="stat-value">${initiative}</span>
            </div>
            <div class="combat-stat editable">
              <span class="stat-label">Action Pts</span>
              <div class="stat-spinner">
                <button class="spin-btn spin-down" data-target="action-points-current" data-max="${actionPointsMax}">−</button>
                <span class="stat-value" id="summary-ap">${actionPointsCurrent}</span>
                <button class="spin-btn spin-up" data-target="action-points-current" data-max="${actionPointsMax}">+</button>
              </div>
            </div>
            <div class="combat-stat editable">
              <span class="stat-label">Luck Pts</span>
              <div class="stat-spinner">
                <button class="spin-btn spin-down" data-target="luck-current" data-max="${luckPointsMax}">−</button>
                <span class="stat-value" id="summary-luck">${luckPointsCurrent}</span>
                <button class="spin-btn spin-up" data-target="luck-current" data-max="${luckPointsMax}">+</button>
              </div>
            </div>
            <div class="combat-stat editable">
              <span class="stat-label">Magic Pts</span>
              <div class="stat-spinner">
                <button class="spin-btn spin-down" data-target="magic-points-current" data-max="${magicPointsMax}">−</button>
                <span class="stat-value" id="summary-mp">${magicPointsCurrent}</span>
                <button class="spin-btn spin-up" data-target="magic-points-current" data-max="${magicPointsMax}">+</button>
              </div>
            </div>
          </div>
          <div style="border-top:1px solid var(--border-light); margin:8px 0;"></div>
          <div class="combat-skill-header"><span>Combat Skill</span><span>%</span></div>
          <div class="skill-list">
            <div class="skill-item"><span>${combatName}</span><span class="skill-roll">${combatPct}% <button class="d100-btn" data-skill="${combatName}" data-target="${combatPct}" title="Roll a d100!"><img src="images/d10.svg" alt="d10" class="d10-icon"></button></span></div>
            <div class="skill-item"><span>Unarmed</span><span class="skill-roll">${unarmedPct}% <button class="d100-btn" data-skill="Unarmed" data-target="${unarmedPct}" title="Roll a d100!"><img src="images/d10.svg" alt="d10" class="d10-icon"></button></span></div>
          </div>
        `;
        
        // Collect melee weapons
        let meleeWeapons = [];
        for (let i = 0; i < 6; i++) {
          const name = document.getElementById(`melee-${i}-name`)?.value;
          const dmg = document.getElementById(`melee-${i}-damage`)?.value;
          if (name) {
            meleeWeapons.push({ name, dmg });
          }
        }
        
        // Collect ranged weapons
        let rangedWeapons = [];
        for (let i = 0; i < 5; i++) {
          const name = document.getElementById(`ranged-${i}-name`)?.value;
          const dmg = document.getElementById(`ranged-${i}-damage`)?.value;
          if (name) {
            rangedWeapons.push({ name, dmg });
          }
        }
        
        // Unarmed damage
        const unarmedDmg = document.getElementById('unarmed-damage')?.value;
        
        // Melee section
        if (meleeWeapons.length > 0 || unarmedDmg) {
          html += `<div style="margin-top:8px; border-top:1px solid var(--border-light); padding-top:8px;">
            <div class="weapon-section-label">Melee</div>
            <div class="skill-list weapons-list">`;
          
          meleeWeapons.forEach(w => {
            if (w.dmg) {
              html += `<div class="skill-item weapon-row"><span>${w.name}</span><span class="damage-roll">${w.dmg} <button class="dice-btn" data-damage="${w.dmg}" title="Roll damage">🎲</button></span></div>`;
            } else {
              html += `<div class="skill-item"><span>${w.name}</span><span>-</span></div>`;
            }
          });
          
          // Add Unarmed to melee
          if (unarmedDmg) {
            html += `<div class="skill-item weapon-row"><span>Unarmed</span><span class="damage-roll">${unarmedDmg} <button class="dice-btn" data-damage="${unarmedDmg}" title="Roll damage">🎲</button></span></div>`;
          }
          
          html += '</div></div>';
        }
        
        // Ranged section
        if (rangedWeapons.length > 0) {
          html += `<div style="margin-top:8px; border-top:1px solid var(--border-light); padding-top:8px;">
            <div class="weapon-section-label">Ranged</div>
            <div class="skill-list weapons-list">`;
          
          rangedWeapons.forEach(w => {
            if (w.dmg) {
              html += `<div class="skill-item weapon-row"><span>${w.name}</span><span class="damage-roll">${w.dmg} <button class="dice-btn" data-damage="${w.dmg}" title="Roll damage">🎲</button></span></div>`;
            } else {
              html += `<div class="skill-item"><span>${w.name}</span><span>-</span></div>`;
            }
          });
          
          html += '</div></div>';
        }
        
        // No weapons message
        if (meleeWeapons.length === 0 && rangedWeapons.length === 0 && !unarmedDmg) {
          html += `<div style="margin-top:8px; border-top:1px solid var(--border-light); padding-top:8px;">
            <div class="skill-list weapons-list">
              <div class="skill-item"><span style="color:#999;">No weapons</span></div>
            </div>
          </div>`;
        }
        
        return html;
      }
    },
    'key-skills': {
      name: 'Standard Skills',
      icon: '🎯',
      render: () => {
        // All standard skills with their DOM IDs
        const allStandardSkills = [
          ['athletics', 'Athletics'], ['boating', 'Boating'], ['brawn', 'Brawn'],
          ['conceal', 'Conceal'], ['customs', 'Customs'], ['dance', 'Dance'],
          ['deceit', 'Deceit'], ['drive', 'Drive'], ['endurance', 'Endurance'],
          ['evade', 'Evade'], ['first-aid', 'First Aid'], ['influence', 'Influence'],
          ['insight', 'Insight'], ['locale', 'Locale'], ['perception', 'Perception'],
          ['ride', 'Ride'], ['sing', 'Sing'], ['stealth', 'Stealth'],
          ['swim', 'Swim'], ['willpower', 'Willpower']
        ];
        
        const skills = [];
        
        // Add all standard skills
        allStandardSkills.forEach(([id, name]) => {
          const val = parseInt(document.getElementById(`${id}-current`)?.value, 10) || 0;
          skills.push({ name, val });
        });
        
        // Sort alphabetically by name
        skills.sort((a, b) => a.name.localeCompare(b.name));
        
        let html = '<h4>Standard Skills</h4><div class="skill-list">';
        skills.forEach(s => {
          const dimmed = s.val < 50 ? ' color:#999;' : '';
          html += `<div class="skill-item"><span class="skill-name-bold">${s.name}</span><span class="skill-roll" style="${dimmed}">${s.val}% <button class="d100-btn" data-skill="${s.name}" data-target="${s.val}" title="Roll a d100!"><img src="images/d10.svg" alt="d10" class="d10-icon"></button></span></div>`;
        });
        html += '</div>';
        return html;
      }
    },
    'professional-skills': {
      name: 'Professional Skills',
      icon: '📚',
      render: () => {
        const skills = [];
        
        // Check all professional skill slots
        for (let i = 0; i < PROFESSIONAL_SKILL_SLOTS; i++) {
          const name = document.getElementById(`prof-skill-${i}-name`)?.value;
          const val = parseInt(document.getElementById(`prof-skill-${i}-current`)?.value, 10) || 0;
          if (name && name.trim()) {
            skills.push({ name: name.trim(), val });
          }
        }
        
        // Sort alphabetically by name
        skills.sort((a, b) => a.name.localeCompare(b.name));
        
        let html = '<h4>Professional Skills</h4><div class="skill-list">';
        if (skills.length === 0) {
          html += '<div class="skill-item"><span style="color:#999;">No professional skills</span></div>';
        } else {
          skills.forEach(s => {
            html += `<div class="skill-item"><span class="skill-name-bold">${s.name}</span><span class="skill-roll">${s.val}% <button class="d100-btn" data-skill="${s.name}" data-target="${s.val}" title="Roll a d100!"><img src="images/d10.svg" alt="d10" class="d10-icon"></button></span></div>`;
          });
        }
        html += '</div>';
        return html;
      }
    },
    'magic-skills': {
      name: 'Magic Skills',
      icon: '✨',
      hasContent: () => {
        // Check if user has any magic class
        const classes = [
          document.getElementById('class-primary')?.value?.toLowerCase().trim() || '',
          document.getElementById('class-secondary')?.value?.toLowerCase().trim() || '',
          document.getElementById('class-tertiary')?.value?.toLowerCase().trim() || ''
        ].filter(c => c);
        
        const divineClasses = ['cleric', 'druid', 'paladin', 'ranger', 'anti-paladin'];
        const arcaneClasses = ['mage'];
        const sorcererClasses = ['sorcerer'];
        const bardClasses = ['bard'];
        
        return classes.some(c => 
          divineClasses.includes(c) || 
          arcaneClasses.includes(c) || 
          sorcererClasses.includes(c) || 
          bardClasses.includes(c)
        );
      },
      render: () => {
        const classes = [
          document.getElementById('class-primary')?.value?.toLowerCase().trim() || '',
          document.getElementById('class-secondary')?.value?.toLowerCase().trim() || '',
          document.getElementById('class-tertiary')?.value?.toLowerCase().trim() || ''
        ].filter(c => c);
        
        const divineClasses = ['cleric', 'druid', 'paladin', 'ranger', 'anti-paladin'];
        const arcaneClasses = ['mage'];
        const sorcererClasses = ['sorcerer'];
        const bardClasses = ['bard'];
        
        const hasDivine = classes.some(c => divineClasses.includes(c));
        const hasArcane = classes.some(c => arcaneClasses.includes(c));
        const hasSorcerer = classes.some(c => sorcererClasses.includes(c));
        const hasBard = classes.some(c => bardClasses.includes(c));
        
        let html = '<h4>Magic Skills</h4><div class="skill-list">';
        
        if (hasDivine) {
          const channel = document.getElementById('channel-percent')?.value || '-';
          const piety = document.getElementById('piety-percent')?.value || '-';
          html += `<div class="skill-item"><span>Channel</span><span>${channel}%</span></div>`;
          html += `<div class="skill-item"><span>Piety</span><span>${piety}%</span></div>`;
        }
        
        if (hasArcane) {
          const arcCast = document.getElementById('arcane-casting-percent')?.value || '-';
          const arcKnow = document.getElementById('arcane-knowledge-percent')?.value || '-';
          html += `<div class="skill-item"><span>Arcane Casting</span><span>${arcCast}%</span></div>`;
          html += `<div class="skill-item"><span>Arcane Knowledge</span><span>${arcKnow}%</span></div>`;
        }
        
        if (hasSorcerer) {
          const sorcery = document.getElementById('arcane-sorcery-percent')?.value || '-';
          const wisdom = document.getElementById('sorcerous-wisdom-percent')?.value || '-';
          html += `<div class="skill-item"><span>Arcane Sorcery</span><span>${sorcery}%</span></div>`;
          html += `<div class="skill-item"><span>Sorcerous Wisdom</span><span>${wisdom}%</span></div>`;
        }
        
        if (hasBard) {
          const music = document.getElementById('musicianship-percent')?.value || '-';
          const lyrical = document.getElementById('lyrical-magic-percent')?.value || '-';
          html += `<div class="skill-item"><span>Musicianship</span><span>${music}%</span></div>`;
          html += `<div class="skill-item"><span>Lyrical Magic</span><span>${lyrical}%</span></div>`;
        }
        
        if (!hasDivine && !hasArcane && !hasSorcerer && !hasBard) {
          html += '<div class="skill-item"><span>No magic class selected</span></div>';
        }
        
        html += '</div>';
        return html;
      }
    },
    'beliefs': {
      name: 'Beliefs',
      icon: '⚖️',
      render: () => {
        let html = '<h4>Beliefs</h4>';
        
        // Helper to create belief item with d100 button
        const createBeliefItem = (name, current) => {
          return `<div class="skill-item belief-roll-item" data-skill-name="${name}" data-skill-value="${current}">
            <span>${name}</span>
            <span class="belief-roll-group">
              <span class="belief-value">${current}%</span>
              <button type="button" class="btn-belief-roll" title="Roll d100">🎲</button>
            </span>
          </div>`;
        };
        
        // Alignment
        const alignmentContainer = document.getElementById('alignment-container');
        const alignmentEntries = [];
        if (alignmentContainer) {
          const alignmentRows = alignmentContainer.querySelectorAll('.belief-row');
          alignmentRows.forEach((row, idx) => {
            const index = row.dataset.index || (idx + 1);
            const name = document.getElementById(`alignment-${index}-name`)?.value || '';
            const current = document.getElementById(`alignment-${index}-current`)?.value || '-';
            if (name.trim()) {
              alignmentEntries.push({ name: name.trim(), current });
            }
          });
        }
        if (alignmentEntries.length > 0) {
          html += '<div class="beliefs-section"><strong>Alignment</strong>';
          alignmentEntries.forEach(a => {
            html += createBeliefItem(a.name, a.current);
          });
          html += '</div>';
        }
        
        // Passions
        const passionsContainer = document.getElementById('passions-container');
        const passionEntries = [];
        if (passionsContainer) {
          const passionRows = passionsContainer.querySelectorAll('.belief-row');
          passionRows.forEach((row, idx) => {
            const index = row.dataset.index || (idx + 1);
            const name = document.getElementById(`passion-${index}-name`)?.value || '';
            const current = document.getElementById(`passion-${index}-current`)?.value || '-';
            if (name.trim()) {
              passionEntries.push({ name: name.trim(), current });
            }
          });
        }
        if (passionEntries.length > 0) {
          html += '<div class="beliefs-section"><strong>Passions</strong>';
          passionEntries.forEach(p => {
            html += createBeliefItem(p.name, p.current);
          });
          html += '</div>';
        }
        
        // Oaths
        const oathsContainer = document.getElementById('oaths-container');
        const oathEntries = [];
        if (oathsContainer) {
          const oathRows = oathsContainer.querySelectorAll('.belief-row');
          oathRows.forEach((row, idx) => {
            const index = row.dataset.index || (idx + 1);
            const name = document.getElementById(`oath-${index}-name`)?.value || '';
            const current = document.getElementById(`oath-${index}-current`)?.value || '-';
            if (name.trim()) {
              oathEntries.push({ name: name.trim(), current });
            }
          });
        }
        if (oathEntries.length > 0) {
          html += '<div class="beliefs-section"><strong>Oaths</strong>';
          oathEntries.forEach(o => {
            html += createBeliefItem(o.name, o.current);
          });
          html += '</div>';
        }
        
        // If nothing to show
        if (html === '<h4>Beliefs</h4>') {
          html += '<div class="skill-item"><span>No beliefs defined</span></div>';
        }
        
        return html;
      }
    },
    'movement': {
      name: 'Movement',
      icon: '🏃',
      render: () => {
        const walk = document.getElementById('walk-speed')?.textContent || '-';
        const run = document.getElementById('run-speed')?.textContent || '-';
        const sprint = document.getElementById('sprint-speed')?.textContent || '-';
        const swim = document.getElementById('swim-speed')?.textContent || '-';
        const climb = document.getElementById('climb-speed')?.textContent || '-';
        const jumpV = document.getElementById('vertical-jump')?.textContent || '-';
        const jumpH = document.getElementById('horizontal-jump')?.textContent || '-';
        const fly = document.getElementById('flying-speed')?.value || '';
        
        let html = `
          <h4>Movement</h4>
          <div class="stat-row"><span class="stat-label">Walk:</span><span class="stat-value">${walk}</span></div>
          <div class="stat-row"><span class="stat-label">Run:</span><span class="stat-value">${run}</span></div>
          <div class="stat-row"><span class="stat-label">Sprint:</span><span class="stat-value">${sprint}</span></div>
          <div class="stat-row"><span class="stat-label">Swim:</span><span class="stat-value">${swim}</span></div>
          <div class="stat-row"><span class="stat-label">Climb:</span><span class="stat-value">${climb}</span></div>
          <hr style="border:none;border-top:1px solid #ccc;margin:6px 0;">
          <div class="stat-row"><span class="stat-label">Vertical Jump:</span><span class="stat-value">${jumpV}</span></div>
          <div class="stat-row"><span class="stat-label">Horizontal Jump:</span><span class="stat-value">${jumpH}</span></div>
        `;
        
        if (fly && fly.trim()) {
          html += `<div class="stat-row"><span class="stat-label">Fly:</span><span class="stat-value">${fly}</span></div>`;
        }
        
        return html;
      }
    },
    'encumbrance': {
      name: 'Encumbrance',
      icon: '🎒',
      render: () => {
        const totalEnc = document.getElementById('total-enc')?.textContent || '0';
        const statusEl = document.getElementById('enc-status');
        const statusText = statusEl?.textContent || 'Unknown';
        
        // Determine status color
        let statusColor = '#228b22'; // Green for Unburdened
        if (statusText === 'Overburdened') {
          statusColor = '#c41e3a'; // Red
        } else if (statusText === 'Burdened') {
          statusColor = '#1e90ff'; // Blue
        }
        
        return `
          <h4>Encumbrance</h4>
          <div class="stat-row"><span class="stat-label">Current:</span><span class="stat-value-bold">${totalEnc}</span></div>
          <div class="stat-row"><span class="stat-label">Status:</span><span class="stat-value-bold" style="color: ${statusColor};">${statusText}</span></div>
        `;
      }
    },
    'money': {
      name: 'Money',
      icon: '💰',
      render: () => {
        const pp = document.getElementById('money-platinum')?.value || '0';
        const gp = document.getElementById('money-gold')?.value || '0';
        const sp = document.getElementById('money-silver')?.value || '0';
        const cp = document.getElementById('money-copper')?.value || '0';
        const ep = document.getElementById('money-electrum')?.value || '0';
        return `
          <h4>Money</h4>
          <div class="stat-grid">
            <div class="stat-box"><div class="label">PP</div><div class="value">${pp}</div></div>
            <div class="stat-box"><div class="label">GP</div><div class="value">${gp}</div></div>
            <div class="stat-box"><div class="label">EP</div><div class="value">${ep}</div></div>
            <div class="stat-box"><div class="label">SP</div><div class="value">${sp}</div></div>
            <div class="stat-box"><div class="label">CP</div><div class="value">${cp}</div></div>
          </div>
        `;
      }
    },
    'spells-cantrips': {
      name: 'Cantrips',
      icon: '✨',
      dynamic: true,
      isAvailable: () => {
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`cantrips-${i}-mem`);
          const name = document.getElementById(`cantrips-${i}-name`);
          if (mem?.checked && name?.value?.trim()) return true;
        }
        return false;
      },
      render: () => {
        let html = '<h4>Cantrips (Memorized)</h4>';
        html += '<div class="spell-widget-header"><span>Spell</span><span>Cost</span></div>';
        html += '<div class="skill-list">';
        let found = false;
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`cantrips-${i}-mem`);
          const nameEl = document.getElementById(`cantrips-${i}-name`);
          const cost = document.getElementById(`cantrips-${i}-cost`);
          if (mem?.checked && nameEl?.value?.trim()) {
            const spellName = nameEl.value.trim();
            const description = window.SpellData?.getSpellDescription(spellName) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            html += `<div class="skill-item spell-hover" title="${escapedDesc}"><span>${spellName}</span><span>${cost?.value || ''}</span></div>`;
            found = true;
          }
        }
        if (!found) html += '<div class="skill-item"><span style="color:#999;">None memorized</span></div>';
        html += '</div>';
        return html;
      }
    },
    'spells-rank1': {
      name: 'Rank 1 Spells',
      icon: '🔮',
      dynamic: true,
      isAvailable: () => {
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank1-${i}-mem`);
          const name = document.getElementById(`rank1-${i}-name`);
          if (mem?.checked && name?.value?.trim()) return true;
        }
        return false;
      },
      render: () => {
        let html = '<h4>Rank 1 Spells (Memorized)</h4>';
        html += '<div class="spell-widget-header"><span>Spell</span><span>Cost</span></div>';
        html += '<div class="skill-list">';
        let found = false;
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank1-${i}-mem`);
          const nameEl = document.getElementById(`rank1-${i}-name`);
          const cost = document.getElementById(`rank1-${i}-cost`);
          if (mem?.checked && nameEl?.value?.trim()) {
            const spellName = nameEl.value.trim();
            const description = window.SpellData?.getSpellDescription(spellName) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            html += `<div class="skill-item spell-hover" title="${escapedDesc}"><span>${spellName}</span><span>${cost?.value || ''}</span></div>`;
            found = true;
          }
        }
        if (!found) html += '<div class="skill-item"><span style="color:#999;">None memorized</span></div>';
        html += '</div>';
        return html;
      }
    },
    'spells-rank2': {
      name: 'Rank 2 Spells',
      icon: '🔮',
      dynamic: true,
      isAvailable: () => {
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank2-${i}-mem`);
          const name = document.getElementById(`rank2-${i}-name`);
          if (mem?.checked && name?.value?.trim()) return true;
        }
        return false;
      },
      render: () => {
        let html = '<h4>Rank 2 Spells (Memorized)</h4>';
        html += '<div class="spell-widget-header"><span>Spell</span><span>Cost</span></div>';
        html += '<div class="skill-list">';
        let found = false;
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank2-${i}-mem`);
          const nameEl = document.getElementById(`rank2-${i}-name`);
          const cost = document.getElementById(`rank2-${i}-cost`);
          if (mem?.checked && nameEl?.value?.trim()) {
            const spellName = nameEl.value.trim();
            const description = window.SpellData?.getSpellDescription(spellName) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            html += `<div class="skill-item spell-hover" title="${escapedDesc}"><span>${spellName}</span><span>${cost?.value || ''}</span></div>`;
            found = true;
          }
        }
        if (!found) html += '<div class="skill-item"><span style="color:#999;">None memorized</span></div>';
        html += '</div>';
        return html;
      }
    },
    'spells-rank3': {
      name: 'Rank 3 Spells',
      icon: '🔮',
      dynamic: true,
      isAvailable: () => {
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank3-${i}-mem`);
          const name = document.getElementById(`rank3-${i}-name`);
          if (mem?.checked && name?.value?.trim()) return true;
        }
        return false;
      },
      render: () => {
        let html = '<h4>Rank 3 Spells (Memorized)</h4>';
        html += '<div class="spell-widget-header"><span>Spell</span><span>Cost</span></div>';
        html += '<div class="skill-list">';
        let found = false;
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank3-${i}-mem`);
          const nameEl = document.getElementById(`rank3-${i}-name`);
          const cost = document.getElementById(`rank3-${i}-cost`);
          if (mem?.checked && nameEl?.value?.trim()) {
            const spellName = nameEl.value.trim();
            const description = window.SpellData?.getSpellDescription(spellName) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            html += `<div class="skill-item spell-hover" title="${escapedDesc}"><span>${spellName}</span><span>${cost?.value || ''}</span></div>`;
            found = true;
          }
        }
        if (!found) html += '<div class="skill-item"><span style="color:#999;">None memorized</span></div>';
        html += '</div>';
        return html;
      }
    },
    'spells-rank4': {
      name: 'Rank 4 Spells',
      icon: '🔮',
      dynamic: true,
      isAvailable: () => {
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank4-${i}-mem`);
          const name = document.getElementById(`rank4-${i}-name`);
          if (mem?.checked && name?.value?.trim()) return true;
        }
        return false;
      },
      render: () => {
        let html = '<h4>Rank 4 Spells (Memorized)</h4>';
        html += '<div class="spell-widget-header"><span>Spell</span><span>Cost</span></div>';
        html += '<div class="skill-list">';
        let found = false;
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank4-${i}-mem`);
          const nameEl = document.getElementById(`rank4-${i}-name`);
          const cost = document.getElementById(`rank4-${i}-cost`);
          if (mem?.checked && nameEl?.value?.trim()) {
            const spellName = nameEl.value.trim();
            const description = window.SpellData?.getSpellDescription(spellName) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            html += `<div class="skill-item spell-hover" title="${escapedDesc}"><span>${spellName}</span><span>${cost?.value || ''}</span></div>`;
            found = true;
          }
        }
        if (!found) html += '<div class="skill-item"><span style="color:#999;">None memorized</span></div>';
        html += '</div>';
        return html;
      }
    },
    'spells-rank5': {
      name: 'Rank 5 Spells',
      icon: '🔮',
      dynamic: true,
      isAvailable: () => {
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank5-${i}-mem`);
          const name = document.getElementById(`rank5-${i}-name`);
          if (mem?.checked && name?.value?.trim()) return true;
        }
        return false;
      },
      render: () => {
        let html = '<h4>Rank 5 Spells (Memorized)</h4>';
        html += '<div class="spell-widget-header"><span>Spell</span><span>Cost</span></div>';
        html += '<div class="skill-list">';
        let found = false;
        for (let i = 0; i < 12; i++) {
          const mem = document.getElementById(`rank5-${i}-mem`);
          const nameEl = document.getElementById(`rank5-${i}-name`);
          const cost = document.getElementById(`rank5-${i}-cost`);
          if (mem?.checked && nameEl?.value?.trim()) {
            const spellName = nameEl.value.trim();
            const description = window.SpellData?.getSpellDescription(spellName) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            html += `<div class="skill-item spell-hover" title="${escapedDesc}"><span>${spellName}</span><span>${cost?.value || ''}</span></div>`;
            found = true;
          }
        }
        if (!found) html += '<div class="skill-item"><span style="color:#999;">None memorized</span></div>';
        html += '</div>';
        return html;
      }
    },
    'fatigue': {
      name: 'Fatigue',
      icon: '😓',
      render: () => {
        const currentState = App.character.fatigueState || 'fresh';
        const stateLabels = {
          fresh: 'Fresh', winded: 'Winded', tired: 'Tired', wearied: 'Wearied',
          exhausted: 'Exhausted', debilitated: 'Debilitated', incapacitated: 'Incapacitated',
          semiconscious: 'Semi-conscious', coma: 'Coma'
        };
        const fatigue = FATIGUE_PENALTIES[currentState] || FATIGUE_PENALTIES.fresh;
        
        // Color based on severity
        let stateColor = '#228b22'; // Fresh = green
        if (fatigue.skillPenalty >= 80) stateColor = '#cc0000'; // Herculean+ = red
        else if (fatigue.skillPenalty >= 40) stateColor = '#b35900'; // Formidable = orange
        else if (fatigue.skillPenalty >= 20) stateColor = '#cc9900'; // Hard = yellow-orange
        if (!fatigue.canAct) stateColor = '#666'; // Incapacitated = grey
        
        let html = `<h4>Fatigue</h4>`;
        html += `<div class="stat-row" style="margin-bottom:8px;">
          <span class="stat-label">Current:</span>
          <span class="stat-value-bold" style="color:${stateColor};">${stateLabels[currentState] || 'Fresh'}</span>
        </div>`;
        
        // Compact button grid
        html += `<div class="fatigue-widget-grid">`;
        const states = ['fresh','winded','tired','wearied','exhausted','debilitated','incapacitated','semiconscious','coma'];
        const shortLabels = {
          fresh: 'Fresh', winded: 'Winded', tired: 'Tired', wearied: 'Wearied',
          exhausted: 'Exhaust.', debilitated: 'Debil.', incapacitated: 'Incap.',
          semiconscious: 'Semi-C.', coma: 'Coma'
        };
        states.forEach(state => {
          const isActive = state === currentState;
          const fp = FATIGUE_PENALTIES[state];
          let cls = 'fatigue-widget-btn';
          if (isActive) cls += ' fatigue-btn-active';
          if (fp.skillPenalty >= 80) cls += ' fatigue-btn-severe';
          else if (fp.skillPenalty >= 40) cls += ' fatigue-btn-moderate';
          else if (fp.skillPenalty >= 20) cls += ' fatigue-btn-mild';
          if (!fp.canAct) cls += ' fatigue-btn-disabled';
          html += `<button class="${cls}" data-fatigue-state="${state}">${shortLabels[state]}</button>`;
        });
        html += `</div>`;
        
        // Show active effects summary
        if (fatigue.skillPenalty > 0 || !fatigue.canAct) {
          html += `<div style="margin-top:6px; font-size:0.72rem; color:var(--text-secondary); border-top:1px solid var(--border-light); padding-top:4px;">`;
          if (!fatigue.canAct) {
            html += `<div style="color:#cc0000;font-weight:600;">Cannot Act</div>`;
          } else {
            const effects = [];
            if (fatigue.skillPenalty > 0) effects.push(`Skills: ${fatigue.skillGrade} (-${fatigue.skillPenalty}%)`);
            if (fatigue.initiativePenalty > 0) effects.push(`Init: -${fatigue.initiativePenalty}`);
            if (fatigue.apPenalty > 0) effects.push(`AP: -${fatigue.apPenalty}`);
            if (fatigue.movementType === 'flat') effects.push(`Move: -${fatigue.movementFlat}'`);
            else if (fatigue.movementType === 'halve') effects.push('Move: ½');
            else if (fatigue.movementType === 'zero') effects.push('Move: Immobile');
            html += effects.join(' · ');
          }
          html += `</div>`;
        }
        
        // Rest buttons with horizontal divider
        html += `<hr style="border:none; border-top:2px solid var(--border-light); margin:10px 0 8px 0;">`;
        html += `<div class="fatigue-widget-rest-buttons">
          <button class="fatigue-widget-rest-btn fatigue-widget-rest-short" data-rest-action="short">☀ Short Rest</button>
          <button class="fatigue-widget-rest-btn fatigue-widget-rest-long" data-rest-action="long">⛺ Long Rest</button>
        </div>`;
        
        return html;
      }
    },
    'special-abilities': {
      name: 'Abilities',
      icon: '⭐',
      dynamic: true,
      isAvailable: () => {
        // Check if there are any class abilities
        const classContainer = document.getElementById('class-abilities-list');
        if (classContainer) {
          const inputs = classContainer.querySelectorAll('.class-ability-input');
          for (const input of inputs) {
            if (input.value.trim()) return true;
          }
        }
        // Check if there are any species abilities
        const speciesContainer = document.getElementById('species-abilities-list');
        if (speciesContainer) {
          const inputs = speciesContainer.querySelectorAll('.species-ability-input');
          for (const input of inputs) {
            if (input.value.trim()) return true;
          }
        }
        return false;
      },
      render: () => {
        let html = '<h4>Abilities</h4>';
        html += '<div class="abilities-widget-list collapsed" data-widget-id="special-abilities">';
        
        // Collect class abilities
        const classAbilities = [];
        const classContainer = document.getElementById('class-abilities-list');
        if (classContainer) {
          const inputs = classContainer.querySelectorAll('.class-ability-input');
          inputs.forEach(input => {
            if (input.value.trim()) {
              classAbilities.push(input.value.trim());
            }
          });
        }
        
        // Collect species abilities
        const speciesAbilities = [];
        const speciesContainer = document.getElementById('species-abilities-list');
        if (speciesContainer) {
          const inputs = speciesContainer.querySelectorAll('.species-ability-input');
          inputs.forEach(input => {
            if (input.value.trim()) {
              speciesAbilities.push(input.value.trim());
            }
          });
        }
        
        // Sort each group alphabetically
        classAbilities.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        speciesAbilities.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
        
        let totalCount = 0;
        const initialShow = 5;
        
        // Class abilities first
        if (classAbilities.length > 0) {
          html += '<div class="ability-group-label">Class Abilities</div>';
          classAbilities.forEach((ability, idx) => {
            const description = window.AbilityDescriptions?.getDescription(ability) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            const hiddenClass = totalCount >= initialShow ? ' hidden-ability' : '';
            html += `<div class="ability-widget-item${hiddenClass}" title="${escapedDesc}">${ability}</div>`;
            totalCount++;
          });
        }
        
        // Species abilities second
        if (speciesAbilities.length > 0) {
          const hiddenClass = totalCount >= initialShow ? ' hidden-ability' : '';
          html += `<div class="ability-group-label${hiddenClass}">Species Abilities</div>`;
          speciesAbilities.forEach((ability) => {
            const description = window.AbilityDescriptions?.getDescription(ability) || '';
            const escapedDesc = description.replace(/"/g, '&quot;');
            const hiddenClass2 = totalCount >= initialShow ? ' hidden-ability' : '';
            html += `<div class="ability-widget-item${hiddenClass2}" title="${escapedDesc}">${ability}</div>`;
            totalCount++;
          });
        }
        
        html += '</div>';
        
        // Add expand/collapse button if more than initialShow
        if (totalCount > initialShow) {
          html += `<button class="widget-expand-btn" data-widget-id="special-abilities">Show All (${totalCount})</button>`;
        }
        
        return html;
      }
    },
    'equipment': {
      name: 'Equipment',
      icon: '🎒',
      dynamic: true,
      isAvailable: () => {
        const container = document.getElementById('equipment-container');
        if (!container) return false;
        const rows = container.querySelectorAll('.equipment-row');
        for (const row of rows) {
          const nameInput = row.querySelector('.equipment-name');
          if (nameInput && nameInput.value.trim()) return true;
        }
        return false;
      },
      render: () => {
        let html = '<h4>Equipment</h4>';
        html += '<div class="equipment-widget-list collapsed" data-widget-id="equipment">';
        
        // Collect equipment items
        const items = [];
        const container = document.getElementById('equipment-container');
        if (container) {
          const rows = container.querySelectorAll('.equipment-row');
          rows.forEach(row => {
            const nameInput = row.querySelector('.equipment-name');
            const encInput = row.querySelector('.equipment-enc');
            if (nameInput && nameInput.value.trim()) {
              items.push({
                name: nameInput.value.trim(),
                enc: encInput?.value || '0'
              });
            }
          });
        }
        
        // Sort alphabetically
        items.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        
        const initialShow = 8;
        items.forEach((item, idx) => {
          const hiddenClass = idx >= initialShow ? ' hidden-equipment' : '';
          html += `<div class="equipment-widget-item${hiddenClass}">`;
          html += `<span class="equip-name">${item.name}</span>`;
          html += `<span class="equip-enc">${item.enc}</span>`;
          html += `</div>`;
        });
        
        html += '</div>';
        
        // Add expand/collapse button if more than initialShow
        if (items.length > initialShow) {
          html += `<button class="widget-expand-btn" data-widget-id="equipment">Show All (${items.length})</button>`;
        }
        
        return html;
      }
    }
  },
  
  /**
   * Set up the summary page with drag-and-drop
   */
  setupSummaryPage() {
    const palette = document.getElementById('palette-widgets');
    const canvas = document.getElementById('summary-canvas');
    const resetBtn = document.getElementById('btn-reset-summary');
    
    if (!palette || !canvas) return;
    
    // Load saved layout
    const savedLayout = this.loadSummaryLayout();
    
    // Populate palette with widgets not in the saved layout
    this.populatePalette(savedLayout);
    
    // Populate canvas with saved widgets
    this.populateCanvas(savedLayout);
    
    // Set up canvas drag-over events
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
      canvas.classList.add('drag-over');
    });
    
    canvas.addEventListener('dragleave', () => {
      canvas.classList.remove('drag-over');
    });
    
    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      canvas.classList.remove('drag-over');
      
      const widgetId = e.dataTransfer.getData('text/plain');
      const source = e.dataTransfer.getData('source');
      
      // Only add from palette, not when reordering from canvas
      if (source === 'canvas') {
        // This is a reorder operation, handled by widget drop handlers
        return;
      }
      
      if (widgetId && this.summaryWidgets[widgetId]) {
        this.addWidgetToCanvas(widgetId);
        this.removeWidgetFromPalette(widgetId);
        this.saveSummaryLayout();
      }
    });
    
    // Reset button
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (confirm('Reset summary layout to default?')) {
          this.resetSummaryLayout();
        }
      });
    }
    
    // Setup event delegation for widget buttons (spin buttons, dice rolls)
    this.setupWidgetEventListeners();
  },
  
  /**
   * Populate the palette with available widgets
   */
  populatePalette(excludeIds = []) {
    const palette = document.getElementById('palette-widgets');
    if (!palette) return;
    
    palette.innerHTML = '';
    
    Object.entries(this.summaryWidgets).forEach(([id, widget]) => {
      if (excludeIds.includes(id)) return;
      
      // Skip dynamic widgets that aren't available
      if (widget.dynamic && widget.isAvailable && !widget.isAvailable()) return;
      
      // Skip widgets that have hasContent check and return false (e.g., magic-skills when no magic class)
      if (widget.hasContent && !widget.hasContent()) return;
      
      const item = document.createElement('div');
      item.className = 'widget-item';
      item.draggable = true;
      item.dataset.widgetId = id;
      item.innerHTML = `<span class="widget-icon">${widget.icon}</span><span>${widget.name}</span>`;
      
      item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', id);
        item.classList.add('dragging');
      });
      
      item.addEventListener('dragend', () => {
        item.classList.remove('dragging');
      });
      
      palette.appendChild(item);
    });
  },
  
  /**
   * Populate the canvas with saved widgets
   */
  populateCanvas(widgetIds = []) {
    const canvas = document.getElementById('summary-canvas');
    if (!canvas) return;
    
    canvas.innerHTML = '';
    
    widgetIds.forEach(id => {
      const widget = this.summaryWidgets[id];
      if (widget) {
        // Skip widgets that have hasContent check and return false
        if (widget.hasContent && !widget.hasContent()) return;
        this.addWidgetToCanvas(id, false);
      }
    });
  },
  
  /**
   * Add a widget to the canvas
   */
  addWidgetToCanvas(widgetId, save = true) {
    const canvas = document.getElementById('summary-canvas');
    const widget = this.summaryWidgets[widgetId];
    if (!canvas || !widget) return;
    
    const item = document.createElement('div');
    item.className = 'widget-item';
    item.dataset.widgetId = widgetId;
    item.draggable = true;
    
    const content = document.createElement('div');
    content.className = 'widget-content';
    content.innerHTML = widget.render();
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'widget-remove';
    removeBtn.innerHTML = '×';
    removeBtn.title = 'Remove widget';
    removeBtn.addEventListener('click', () => {
      item.remove();
      this.addWidgetToPalette(widgetId);
      this.saveSummaryLayout();
    });
    
    // Drag handle for reordering
    const dragHandle = document.createElement('div');
    dragHandle.className = 'widget-drag-handle';
    dragHandle.innerHTML = '⋮⋮';
    dragHandle.title = 'Drag to reorder';
    
    // Drag events for reordering within canvas
    item.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', widgetId);
      e.dataTransfer.setData('source', 'canvas');
      item.classList.add('dragging');
      // Store reference for reordering
      this.draggedWidget = item;
    });
    
    item.addEventListener('dragend', () => {
      item.classList.remove('dragging');
      this.draggedWidget = null;
      // Remove all drop indicators
      canvas.querySelectorAll('.widget-item').forEach(w => {
        w.classList.remove('drop-before', 'drop-after');
      });
    });
    
    item.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (!this.draggedWidget || this.draggedWidget === item) return;
      
      const rect = item.getBoundingClientRect();
      const midY = rect.top + rect.height / 2;
      
      // Remove previous indicators
      canvas.querySelectorAll('.widget-item').forEach(w => {
        w.classList.remove('drop-before', 'drop-after');
      });
      
      // Show indicator
      if (e.clientY < midY) {
        item.classList.add('drop-before');
      } else {
        item.classList.add('drop-after');
      }
    });
    
    item.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      const source = e.dataTransfer.getData('source');
      
      if (source === 'canvas' && this.draggedWidget && this.draggedWidget !== item) {
        // Reordering within canvas
        const rect = item.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        
        if (e.clientY < midY) {
          canvas.insertBefore(this.draggedWidget, item);
        } else {
          canvas.insertBefore(this.draggedWidget, item.nextSibling);
        }
        
        this.saveSummaryLayout();
      }
      
      // Clean up indicators
      canvas.querySelectorAll('.widget-item').forEach(w => {
        w.classList.remove('drop-before', 'drop-after');
      });
    });
    
    item.appendChild(dragHandle);
    item.appendChild(content);
    item.appendChild(removeBtn);
    canvas.appendChild(item);
    
    if (save) {
      this.saveSummaryLayout();
    }
  },

  /**
   * Setup event listeners for interactive widget elements
   * Uses event delegation on the canvas for reliability
   */
  setupWidgetEventListeners() {
    // Get the canvas element for event delegation
    const canvas = document.getElementById('summary-canvas');
    if (!canvas || canvas.dataset.listenersAttached) return;
    
    // Mark as attached to prevent duplicate listeners
    canvas.dataset.listenersAttached = 'true';
    
    // Event delegation for all widget buttons
    canvas.addEventListener('click', (e) => {
      // Handle spin buttons
      const spinBtn = e.target.closest('.spin-btn');
      if (spinBtn) {
        e.stopPropagation();
        const targetId = spinBtn.dataset.target;
        const max = parseInt(spinBtn.dataset.max, 10) || 99;
        const isUp = spinBtn.classList.contains('spin-up');
        
        const spinner = spinBtn.closest('.stat-spinner');
        const valueSpan = spinner?.querySelector('.stat-value');
        
        if (!valueSpan) return;
        
        let current = parseInt(valueSpan.textContent, 10) || 0;
        
        if (isUp && current < max) {
          current++;
        } else if (!isUp && current > 0) {
          current--;
        }
        
        valueSpan.textContent = current;
        
        // Sync to character page
        const targetInput = document.getElementById(targetId);
        if (targetInput) {
          targetInput.value = current;
          targetInput.dispatchEvent(new Event('input', { bubbles: true }));
        }
        
        this.scheduleAutoSave();
        return;
      }
      
      // Handle dice buttons (damage rolls)
      const diceBtn = e.target.closest('.dice-btn');
      if (diceBtn) {
        e.stopPropagation();
        let damage = diceBtn.dataset.damage;
        
        // If no data-damage, check for sibling weapon-damage input
        if (!damage) {
          const damageInput = diceBtn.parentElement?.querySelector('.weapon-damage');
          if (damageInput) {
            damage = damageInput.value;
          }
        }
        
        if (damage) {
          this.rollDamage(damage);
        }
        return;
      }
      
      // Handle d100 buttons (skill rolls)
      const d100Btn = e.target.closest('.d100-btn');
      if (d100Btn) {
        e.stopPropagation();
        const skillName = d100Btn.dataset.skill;
        const targetPct = parseInt(d100Btn.dataset.target, 10) || 50;
        this.rollD100(skillName, targetPct);
        return;
      }
      
      // Handle fatigue state buttons in summary widget
      const fatigueBtn = e.target.closest('.fatigue-widget-btn');
      if (fatigueBtn) {
        e.stopPropagation();
        const newState = fatigueBtn.dataset.fatigueState;
        if (newState && FATIGUE_PENALTIES[newState]) {
          this.setFatigueState(newState, true);
        }
        return;
      }
      
      // Handle rest buttons in fatigue widget
      const restBtn = e.target.closest('.fatigue-widget-rest-btn');
      if (restBtn) {
        e.stopPropagation();
        const restAction = restBtn.dataset.restAction;
        if (restAction === 'short') {
          this.shortRest();
        } else if (restAction === 'long') {
          this.longRest(); // longRest now shows its own modal and refreshes widgets
        }
        return;
      }
      
      // Handle widget expand/collapse buttons
      const expandBtn = e.target.closest('.widget-expand-btn');
      if (expandBtn) {
        e.stopPropagation();
        const widgetId = expandBtn.dataset.widgetId;
        // Find the list specifically (not the widget-item container)
        const list = canvas.querySelector(`.abilities-widget-list[data-widget-id="${widgetId}"], .spell-widget-list[data-widget-id="${widgetId}"], .equipment-widget-list[data-widget-id="${widgetId}"]`);
        if (list) {
          const isCollapsed = list.classList.contains('collapsed');
          if (isCollapsed) {
            list.classList.remove('collapsed');
            expandBtn.textContent = 'Show Less';
          } else {
            list.classList.add('collapsed');
            // Count total items
            const totalItems = list.querySelectorAll('.ability-widget-item, .spell-widget-item, .equipment-widget-item').length;
            expandBtn.textContent = `Show All (${totalItems})`;
          }
        }
        return;
      }
      
      // Handle belief roll buttons
      const beliefRollBtn = e.target.closest('.btn-belief-roll');
      if (beliefRollBtn) {
        e.stopPropagation();
        const beliefItem = beliefRollBtn.closest('.belief-roll-item');
        if (beliefItem) {
          const skillName = beliefItem.dataset.skillName || 'Belief';
          const skillValue = parseInt(beliefItem.dataset.skillValue, 10) || 50;
          this.rollD100(skillName, skillValue);
        }
        return;
      }
      
      // Handle Spend EXP button in Character Info widget
      const expBtn = e.target.closest('.widget-exp-btn');
      if (expBtn) {
        e.stopPropagation();
        this.openExpModal();
        return;
      }
    });
  },

  // ============================================
  // Notes Page Functions
  // ============================================
  
  /**
   * Notes section definitions
   */
  NOTES_SECTIONS: {
    'background': {
      id: 'background',
      icon: '📜',
      title: 'Background / Backstory',
      hint: 'Origin story, history, how they became an adventurer',
      placeholder: 'Write your character\'s backstory here...',
      type: 'editor'
    },
    'appearance': {
      id: 'appearance',
      icon: '👤',
      title: 'Appearance',
      hint: 'Physical description, distinguishing marks, typical attire',
      placeholder: 'Describe your character\'s appearance...',
      type: 'editor'
    },
    'personality': {
      id: 'personality',
      icon: '🎭',
      title: 'Personality',
      hint: 'Traits, quirks, mannerisms, fears, flaws',
      placeholder: 'What makes your character unique?',
      type: 'editor'
    },
    'goals': {
      id: 'goals',
      icon: '🎯',
      title: 'Goals & Motivations',
      hint: 'What drives the character, short/long-term objectives',
      placeholder: 'What does your character want to achieve?',
      type: 'editor'
    },
    'connections': {
      id: 'connections',
      icon: '🤝',
      title: 'Connections',
      hint: 'NPCs, allies, enemies, family, mentors, rivals',
      placeholder: 'Who are the important people in your character\'s life?',
      type: 'editor'
    },
    'sessions': {
      id: 'sessions',
      icon: '📖',
      title: 'Session Notes',
      hint: 'Per-session journal entries',
      type: 'journal',
      defaultWide: true
    },
    'quests': {
      id: 'quests',
      icon: '⚔️',
      title: 'Quest Log',
      hint: 'Active and completed quests with notes',
      placeholder: 'Track your quests and objectives...',
      type: 'editor'
    },
    'places': {
      id: 'places',
      icon: '🗺️',
      title: 'Places & Locations',
      hint: 'Towns, dungeons, landmarks visited with notes',
      placeholder: 'Record the places you\'ve visited...',
      type: 'editor'
    },
    'secrets': {
      id: 'secrets',
      icon: '🔮',
      title: 'Secrets & Rumors',
      hint: 'Things the character has learned',
      placeholder: 'What secrets have you uncovered?',
      type: 'editor'
    }
  },
  
  /**
   * Default notes layout
   */
  DEFAULT_NOTES_LAYOUT: [
    { id: 'background', wide: false, height: 180 },
    { id: 'appearance', wide: false, height: 180 },
    { id: 'personality', wide: false, height: 180 },
    { id: 'goals', wide: false, height: 180 },
    { id: 'connections', wide: false, height: 180 },
    { id: 'sessions', wide: true, height: 350 },
    { id: 'quests', wide: false, height: 180 },
    { id: 'places', wide: false, height: 180 },
    { id: 'secrets', wide: false, height: 180 }
  ],
  
  /**
   * Setup the Notes page with rich text toolbar and journal functionality
   */
  setupNotesPage() {
    // Load layout and render sections
    this.renderNotesSections();
    
    // Setup rich text toolbar
    this.setupNotesToolbar();
    
    // Setup layout controls
    this.setupNotesLayoutControls();
    
    // Setup drag and drop
    this.setupNotesDragDrop();
    
    // Load existing notes data
    this.loadNotesData();
  },
  
  /**
   * Get notes layout from character or use default
   */
  getNotesLayout() {
    if (this.character.notesLayout && this.character.notesLayout.length > 0) {
      // Convert any old string heights to pixel values
      return this.character.notesLayout.map(item => {
        if (typeof item.height === 'string') {
          const heightMap = { small: 100, medium: 180, large: 280, xlarge: 400 };
          item.height = heightMap[item.height] || 180;
        }
        return item;
      });
    }
    return JSON.parse(JSON.stringify(this.DEFAULT_NOTES_LAYOUT));
  },
  
  /**
   * Save notes layout to character
   */
  saveNotesLayout() {
    const grid = document.getElementById('notes-grid');
    if (!grid) return;
    
    const layout = [];
    grid.querySelectorAll('.notes-section').forEach(section => {
      const id = section.dataset.sectionId;
      if (id) {
        // Get the actual height of the resizable element
        const editor = section.querySelector('.notes-editor');
        const journalContainer = section.querySelector('.journal-container');
        let height = null;
        
        if (editor) {
          height = editor.offsetHeight;
        } else if (journalContainer) {
          height = journalContainer.offsetHeight;
        }
        
        layout.push({
          id: id,
          wide: section.classList.contains('notes-section-wide'),
          height: height,
          custom: section.dataset.custom === 'true',
          customTitle: section.dataset.customTitle || null,
          customIcon: section.dataset.customIcon || null
        });
      }
    });
    
    this.character.notesLayout = layout;
    this.scheduleAutoSave();
  },
  
  /**
   * Render all notes sections based on layout
   */
  renderNotesSections() {
    const grid = document.getElementById('notes-grid');
    if (!grid) return;
    
    grid.innerHTML = '';
    const layout = this.getNotesLayout();
    
    layout.forEach(item => {
      this.renderNotesSection(item, grid);
    });
    
    this.updateNotesPalette();
  },
  
  /**
   * Render a single notes section
   */
  renderNotesSection(layoutItem, container) {
    const sectionDef = this.NOTES_SECTIONS[layoutItem.id];
    const isCustom = layoutItem.custom || !sectionDef;
    
    const section = document.createElement('div');
    section.className = 'notes-section';
    section.dataset.sectionId = layoutItem.id;
    section.draggable = true;
    
    if (layoutItem.wide) {
      section.classList.add('notes-section-wide');
    }
    
    if (isCustom) {
      section.dataset.custom = 'true';
      section.dataset.customTitle = layoutItem.customTitle || 'Custom Section';
      section.dataset.customIcon = layoutItem.customIcon || '📝';
    }
    
    const icon = isCustom ? (layoutItem.customIcon || '📝') : sectionDef.icon;
    const title = isCustom ? (layoutItem.customTitle || 'Custom Section') : sectionDef.title;
    const hint = isCustom ? 'Custom notes section' : sectionDef.hint;
    const placeholder = isCustom ? 'Write your notes here...' : (sectionDef.placeholder || '');
    const type = sectionDef?.type || 'editor';
    
    // Get saved height or use default
    const savedHeight = layoutItem.height || (type === 'journal' ? 350 : 180);
    
    let contentHTML = '';
    if (type === 'journal') {
      contentHTML = `
        <div class="journal-container" id="journal-container" style="height: ${savedHeight}px;">
          <div class="journal-page">
            <div class="journal-entries" id="journal-entries"></div>
          </div>
        </div>
      `;
    } else {
      contentHTML = `
        <div class="notes-editor" contenteditable="true" id="notes-${layoutItem.id}" data-placeholder="${placeholder}" style="height: ${savedHeight}px;"></div>
      `;
    }
    
    const addEntryBtn = type === 'journal' ? 
      `<button type="button" class="btn btn-small btn-add-entry" id="btn-add-session-entry">+ Add Entry</button>` : '';
    
    section.innerHTML = `
      <div class="notes-section-header">
        <span class="notes-section-drag-handle" title="Drag to reorder">⋮⋮</span>
        <h3>${icon} ${title}</h3>
        <div class="notes-section-controls">
          ${addEntryBtn}
          <button type="button" class="notes-section-btn btn-width ${layoutItem.wide ? 'is-wide' : ''}" title="Toggle full width">↔</button>
          <button type="button" class="notes-section-btn btn-delete" title="Remove section">×</button>
        </div>
        <span class="notes-section-hint">${hint}</span>
      </div>
      ${contentHTML}
    `;
    
    container.appendChild(section);
    
    // Setup event handlers for this section
    this.setupNotesSectionHandlers(section);
    
    // Setup journal if needed
    if (type === 'journal') {
      this.setupJournalEntries();
    }
  },
  
  /**
   * Setup event handlers for a notes section
   */
  setupNotesSectionHandlers(section) {
    // Width toggle
    const widthBtn = section.querySelector('.btn-width');
    if (widthBtn) {
      widthBtn.addEventListener('click', () => {
        section.classList.toggle('notes-section-wide');
        widthBtn.classList.toggle('is-wide');
        this.saveNotesLayout();
      });
    }
    
    // Delete section
    const deleteBtn = section.querySelector('.btn-delete');
    if (deleteBtn) {
      deleteBtn.addEventListener('click', () => {
        const sectionId = section.dataset.sectionId;
        const sectionDef = this.NOTES_SECTIONS[sectionId];
        const title = sectionDef?.title || section.dataset.customTitle || 'this section';
        
        if (confirm(`Remove "${title}" from the notes page?\n\nThe section will be moved to the palette and can be added back later. Content will be preserved.`)) {
          section.remove();
          this.saveNotesLayout();
          this.updateNotesPalette();
        }
      });
    }
    
    // Editor input handlers and resize observer
    const editor = section.querySelector('.notes-editor');
    if (editor) {
      editor.addEventListener('input', () => {
        this.saveNotesData();
        this.scheduleAutoSave();
      });
      
      editor.addEventListener('focus', () => {
        this.activeNotesEditor = editor;
      });
      
      editor.addEventListener('keyup', () => {
        this.updateToolbarState();
      });
      
      editor.addEventListener('mouseup', () => {
        this.updateToolbarState();
        // Save height after potential resize
        this.saveNotesLayout();
      });
      
      // Use ResizeObserver to detect CSS resize changes
      if (window.ResizeObserver) {
        const resizeObserver = new ResizeObserver(() => {
          // Debounce the save
          clearTimeout(this.notesResizeTimeout);
          this.notesResizeTimeout = setTimeout(() => {
            this.saveNotesLayout();
          }, 300);
        });
        resizeObserver.observe(editor);
      }
    }
    
    // Journal container resize observer
    const journalContainer = section.querySelector('.journal-container');
    if (journalContainer && window.ResizeObserver) {
      const resizeObserver = new ResizeObserver(() => {
        clearTimeout(this.notesResizeTimeout);
        this.notesResizeTimeout = setTimeout(() => {
          this.saveNotesLayout();
        }, 300);
      });
      resizeObserver.observe(journalContainer);
    }
  },
  
  /**
   * Update the notes palette with available sections
   */
  updateNotesPalette() {
    const palette = document.getElementById('notes-palette-items');
    if (!palette) return;
    
    palette.innerHTML = '';
    
    // Get sections currently in the grid
    const grid = document.getElementById('notes-grid');
    const activeSections = new Set();
    if (grid) {
      grid.querySelectorAll('.notes-section').forEach(s => {
        activeSections.add(s.dataset.sectionId);
      });
    }
    
    // Add missing predefined sections to palette
    let hasItems = false;
    Object.entries(this.NOTES_SECTIONS).forEach(([id, def]) => {
      if (!activeSections.has(id)) {
        hasItems = true;
        const item = document.createElement('div');
        item.className = 'palette-item';
        item.draggable = true;
        item.dataset.sectionId = id;
        item.innerHTML = `<span class="palette-item-icon">${def.icon}</span><span>${def.title}</span>`;
        
        // Click to add
        item.addEventListener('click', () => {
          this.addNotesSectionFromPalette(id);
        });
        
        // Drag start
        item.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', id);
          e.dataTransfer.setData('source', 'palette');
          item.classList.add('dragging');
        });
        
        item.addEventListener('dragend', () => {
          item.classList.remove('dragging');
        });
        
        palette.appendChild(item);
      }
    });
    
    if (!hasItems) {
      palette.innerHTML = '<span class="palette-empty">All sections added</span>';
    }
  },
  
  /**
   * Add a section from the palette to the grid
   */
  addNotesSectionFromPalette(sectionId) {
    const grid = document.getElementById('notes-grid');
    if (!grid) return;
    
    const sectionDef = this.NOTES_SECTIONS[sectionId];
    const layoutItem = {
      id: sectionId,
      wide: sectionDef?.defaultWide || false,
      height: 180
    };
    
    this.renderNotesSection(layoutItem, grid);
    this.loadNotesData(); // Load any existing content
    this.saveNotesLayout();
    this.updateNotesPalette();
  },
  
  /**
   * Setup notes layout control buttons
   */
  setupNotesLayoutControls() {
    // Custom section button
    const addCustomBtn = document.getElementById('btn-add-custom-section');
    if (addCustomBtn) {
      addCustomBtn.addEventListener('click', () => {
        this.showAddCustomSectionModal();
      });
    }
    
    // Reset layout button
    const resetBtn = document.getElementById('btn-reset-notes-layout');
    if (resetBtn) {
      resetBtn.addEventListener('click', () => {
        if (confirm('Reset notes layout to default?\n\nThis will restore all sections to their default positions. Your content will be preserved.')) {
          this.character.notesLayout = JSON.parse(JSON.stringify(this.DEFAULT_NOTES_LAYOUT));
          this.renderNotesSections();
          this.loadNotesData();
          this.scheduleAutoSave();
        }
      });
    }
  },
  
  /**
   * Show modal to add custom section
   */
  showAddCustomSectionModal() {
    const title = prompt('Enter a title for your custom section:', 'My Notes');
    if (!title || !title.trim()) return;
    
    const icons = ['📝', '📓', '📋', '📌', '💡', '🔖', '📚', '🎲', '⭐', '💎', '🗝️', '🏰'];
    const icon = icons[Math.floor(Math.random() * icons.length)];
    
    const customId = 'custom-' + Date.now();
    const grid = document.getElementById('notes-grid');
    if (!grid) return;
    
    const layoutItem = {
      id: customId,
      wide: false,
      height: 180,
      custom: true,
      customTitle: title.trim(),
      customIcon: icon
    };
    
    this.renderNotesSection(layoutItem, grid);
    this.saveNotesLayout();
  },
  
  /**
   * Setup drag and drop for notes sections
   */
  setupNotesDragDrop() {
    const grid = document.getElementById('notes-grid');
    if (!grid) return;
    
    // Grid drop zone
    grid.addEventListener('dragover', (e) => {
      e.preventDefault();
      grid.classList.add('drag-over');
    });
    
    grid.addEventListener('dragleave', (e) => {
      if (!grid.contains(e.relatedTarget)) {
        grid.classList.remove('drag-over');
      }
    });
    
    grid.addEventListener('drop', (e) => {
      e.preventDefault();
      grid.classList.remove('drag-over');
      
      const sectionId = e.dataTransfer.getData('text/plain');
      const source = e.dataTransfer.getData('source');
      
      if (source === 'palette' && sectionId) {
        this.addNotesSectionFromPalette(sectionId);
      }
    });
    
    // Event delegation for section drag
    grid.addEventListener('dragstart', (e) => {
      const section = e.target.closest('.notes-section');
      if (section && e.target.classList.contains('notes-section-drag-handle')) {
        section.classList.add('dragging');
        e.dataTransfer.setData('text/plain', section.dataset.sectionId);
        e.dataTransfer.setData('source', 'grid');
        e.dataTransfer.effectAllowed = 'move';
        this.draggedNotesSection = section;
      }
    });
    
    grid.addEventListener('dragend', (e) => {
      const section = e.target.closest('.notes-section');
      if (section) {
        section.classList.remove('dragging');
      }
      this.draggedNotesSection = null;
      
      // Remove all drag-over states
      grid.querySelectorAll('.notes-section').forEach(s => {
        s.classList.remove('drag-over');
      });
    });
    
    grid.addEventListener('dragover', (e) => {
      e.preventDefault();
      if (!this.draggedNotesSection) return;
      
      const section = e.target.closest('.notes-section');
      if (section && section !== this.draggedNotesSection) {
        section.classList.add('drag-over');
      }
    });
    
    grid.addEventListener('dragleave', (e) => {
      const section = e.target.closest('.notes-section');
      if (section) {
        section.classList.remove('drag-over');
      }
    });
    
    grid.addEventListener('drop', (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (!this.draggedNotesSection) return;
      
      const targetSection = e.target.closest('.notes-section');
      if (targetSection && targetSection !== this.draggedNotesSection) {
        // Insert before or after based on position
        const rect = targetSection.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        
        if (e.clientY < midY) {
          grid.insertBefore(this.draggedNotesSection, targetSection);
        } else {
          grid.insertBefore(this.draggedNotesSection, targetSection.nextSibling);
        }
        
        this.saveNotesLayout();
      }
      
      // Cleanup
      grid.querySelectorAll('.notes-section').forEach(s => {
        s.classList.remove('drag-over', 'dragging');
      });
      grid.classList.remove('drag-over');
    });
  },
  
  /**
   * Setup rich text toolbar event handlers
   */
  setupNotesToolbar() {
    const toolbar = document.getElementById('notes-toolbar');
    if (!toolbar) return;
    
    // Command buttons (bold, italic, etc.)
    toolbar.querySelectorAll('.toolbar-btn[data-command]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        const command = btn.dataset.command;
        const value = btn.dataset.value || null;
        
        // Special handling for hiliteColor
        if (command === 'hiliteColor') {
          const bgColor = document.getElementById('toolbar-bg-color')?.value || '#ffff00';
          document.execCommand(command, false, bgColor);
        } else {
          document.execCommand(command, false, value);
        }
        
        // Update button states
        this.updateToolbarState();
      });
    });
    
    // Font family select
    const fontFamily = document.getElementById('toolbar-font-family');
    if (fontFamily) {
      fontFamily.addEventListener('change', () => {
        document.execCommand('fontName', false, fontFamily.value);
      });
    }
    
    // Font size select
    const fontSize = document.getElementById('toolbar-font-size');
    if (fontSize) {
      fontSize.addEventListener('change', () => {
        // execCommand fontSize only accepts 1-7, so we use CSS instead
        const selection = window.getSelection();
        if (selection.rangeCount > 0) {
          const range = selection.getRangeAt(0);
          if (!range.collapsed) {
            const span = document.createElement('span');
            span.style.fontSize = fontSize.value;
            range.surroundContents(span);
          }
        }
      });
    }
    
    // Text color
    const textColor = document.getElementById('toolbar-text-color');
    if (textColor) {
      textColor.addEventListener('input', () => {
        document.execCommand('foreColor', false, textColor.value);
      });
    }
  },
  
  /**
   * Update toolbar button states based on current selection
   */
  updateToolbarState() {
    const toolbar = document.getElementById('notes-toolbar');
    if (!toolbar) return;
    
    // Update toggle buttons
    const toggleCommands = ['bold', 'italic', 'underline', 'strikeThrough'];
    toggleCommands.forEach(cmd => {
      const btn = toolbar.querySelector(`[data-command="${cmd}"]`);
      if (btn) {
        if (document.queryCommandState(cmd)) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      }
    });
  },
  
  /**
   * Setup journal entry management
   */
  setupJournalEntries() {
    const addBtn = document.getElementById('btn-add-session-entry');
    if (addBtn) {
      // Remove existing listeners by cloning
      const newBtn = addBtn.cloneNode(true);
      addBtn.parentNode.replaceChild(newBtn, addBtn);
      
      newBtn.addEventListener('click', () => {
        this.addJournalEntry();
      });
    }
    
    // Event delegation for delete buttons
    const journalContainer = document.getElementById('journal-entries');
    if (journalContainer) {
      // Remove existing listeners
      const newContainer = journalContainer.cloneNode(true);
      journalContainer.parentNode.replaceChild(newContainer, journalContainer);
      
      newContainer.addEventListener('click', (e) => {
        if (e.target.closest('.btn-delete-entry')) {
          const entry = e.target.closest('.journal-entry');
          if (entry && confirm('Delete this journal entry?')) {
            entry.remove();
            this.saveNotesData();
            this.scheduleAutoSave();
            this.updateJournalEmptyState();
          }
        }
      });
      
      newContainer.addEventListener('input', () => {
        this.saveNotesData();
        this.scheduleAutoSave();
      });
    }
  },
  
  /**
   * Add a new journal entry
   */
  addJournalEntry(data = null) {
    const container = document.getElementById('journal-entries');
    if (!container) return;
    
    // Remove empty state if present
    const emptyState = container.querySelector('.journal-empty');
    if (emptyState) {
      emptyState.remove();
    }
    
    const today = new Date();
    const dateStr = data?.date || today.toLocaleDateString('en-US', { 
      month: 'short', day: 'numeric', year: 'numeric' 
    });
    
    const entry = document.createElement('div');
    entry.className = 'journal-entry';
    entry.innerHTML = `
      <div class="journal-entry-header">
        <div class="journal-entry-date">
          📅 <input type="text" value="${dateStr}" placeholder="Date">
        </div>
        <div class="journal-entry-title">
          <input type="text" value="${data?.title || ''}" placeholder="Session Title">
        </div>
        <button type="button" class="btn-delete-entry" title="Delete entry">×</button>
      </div>
      <div class="journal-entry-content" contenteditable="true" data-placeholder="Write about this session...">${data?.content || ''}</div>
    `;
    
    // Add to top (most recent first)
    container.insertBefore(entry, container.firstChild);
    
    // Focus the title field
    if (!data) {
      entry.querySelector('.journal-entry-title input').focus();
    }
    
    // Setup focus tracking for this entry's content
    const contentEl = entry.querySelector('.journal-entry-content');
    if (contentEl) {
      contentEl.addEventListener('focus', () => {
        this.activeNotesEditor = contentEl;
      });
    }
    
    if (!data) {
      this.saveNotesData();
      this.scheduleAutoSave();
    }
  },
  
  /**
   * Update journal empty state display
   */
  updateJournalEmptyState() {
    const container = document.getElementById('journal-entries');
    if (!container) return;
    
    const entries = container.querySelectorAll('.journal-entry');
    const emptyState = container.querySelector('.journal-empty');
    
    if (entries.length === 0 && !emptyState) {
      container.innerHTML = `
        <div class="journal-empty">
          <div class="journal-empty-icon">📖</div>
          <p>No session notes yet.</p>
          <p>Click "+ Add Entry" to start recording your adventures!</p>
        </div>
      `;
    }
  },
  
  /**
   * Save all notes data to character object
   */
  saveNotesData() {
    if (!this.character.notesData) {
      this.character.notesData = {};
    }
    
    // Save all editor sections (including custom)
    document.querySelectorAll('.notes-editor').forEach(editor => {
      const sectionId = editor.id.replace('notes-', '');
      if (sectionId) {
        this.character.notesData[sectionId] = editor.innerHTML;
      }
    });
    
    // Save journal entries
    const journalEntries = [];
    document.querySelectorAll('.journal-entry').forEach(entry => {
      const dateInput = entry.querySelector('.journal-entry-date input');
      const titleInput = entry.querySelector('.journal-entry-title input');
      const content = entry.querySelector('.journal-entry-content');
      
      journalEntries.push({
        date: dateInput?.value || '',
        title: titleInput?.value || '',
        content: content?.innerHTML || ''
      });
    });
    this.character.notesData.journalEntries = journalEntries;
    
    // Keep old notes for backwards compatibility
    if (this.character.notes && !this.character.notesData.background) {
      this.character.notesData.background = this.character.notes.replace(/\n/g, '<br>');
    }
  },
  
  /**
   * Load notes data from character object
   */
  loadNotesData() {
    const notesData = this.character.notesData || {};
    
    // Load all editor sections
    document.querySelectorAll('.notes-editor').forEach(editor => {
      const sectionId = editor.id.replace('notes-', '');
      if (sectionId && notesData[sectionId]) {
        editor.innerHTML = notesData[sectionId];
      }
    });
    
    // Migrate old notes to background if no new data exists
    if (!notesData.background && this.character.notes) {
      const bgEditor = document.getElementById('notes-background');
      if (bgEditor) {
        bgEditor.innerHTML = this.character.notes.replace(/\n/g, '<br>');
      }
    }
    
    // Load journal entries
    const journalContainer = document.getElementById('journal-entries');
    if (journalContainer) {
      journalContainer.innerHTML = '';
      const journalEntries = notesData.journalEntries || [];
      if (journalEntries.length > 0) {
        journalEntries.forEach(entry => {
          this.addJournalEntry(entry);
        });
      } else {
        this.updateJournalEmptyState();
      }
    }
  },

  /**
   * Roll d100 for a skill check and show result
   */
  rollD100(skillName, targetPct) {
    // Roll d100 (1-100, where 100 = "00")
    const roll = Math.floor(Math.random() * 100) + 1;
    
    // Determine result
    let result = '';
    let resultClass = '';
    
    // Critical: 10% of skill value, always rounding UP
    // e.g., 80% skill -> ceil(8.0) = 8, so 08 or less is critical
    // e.g., 81% skill -> ceil(8.1) = 9, so 09 or less is critical
    let critThreshold = Math.ceil(targetPct / 10);
    
    // Determine if this is a Combat Skill roll (user may name it anything)
    const normalizedSkill = (skillName || '').toLowerCase().trim();
    const combatSkillName = (document.getElementById('combat-skill-1-name')?.value || '').toLowerCase().trim();
    const isCombatSkillRoll = normalizedSkill === combatSkillName || 
      normalizedSkill.includes('combat skill') || normalizedSkill.includes('combat style');
    
    // Ranger Ranged Weapon Specialization: 1/5th critical range for Combat Skill
    let rangerCrit = false;
    const hasRangerRangedSpec = (this.character.weaponSpecializations || []).some(s => s.type === 'Ranger Ranged');
    if (hasRangerRangedSpec && isCombatSkillRoll) {
      critThreshold = Math.ceil(targetPct / 5);
      rangerCrit = true;
    }
    
    // Weapon Master: double critical range for Combat Skill rolls
    let critDoubled = false;
    if (this.character.weaponSpecCritDoubled && (this.character.activeWeaponSpecs || []).length > 0) {
      if (isCombatSkillRoll) {
        critThreshold = critThreshold * 2;
        critDoubled = true;
      }
    }
    
    // Fumble: 99 or 00 (100), but skills over 100% only fumble on 00
    const isFumble = targetPct >= 100 ? (roll === 100) : (roll >= 99);
    
    // 96-00 is ALWAYS a Failure, no matter how high the skill
    const isAutoFail = roll >= 96;
    
    // 01-05 is ALWAYS a Success, even if skill is reduced below 5%
    const isAutoSuccess = roll <= 5;
    
    if (isFumble) {
      // Fumble takes highest priority
      result = 'Fumble!';
      resultClass = 'roll-fumble';
    } else if (isAutoFail) {
      // 96-00 always failure (96-98 are failure, 99-00 handled as fumble above)
      result = 'Failure';
      resultClass = 'roll-failure';
    } else if (roll <= critThreshold && (roll <= targetPct || isAutoSuccess)) {
      // Critical: within critical range AND also a success (normal or auto)
      result = critDoubled ? 'Critical! (Doubled)' : rangerCrit ? 'Critical! (1/5th)' : 'Critical!';
      resultClass = 'roll-critical';
    } else if (roll <= targetPct || isAutoSuccess) {
      // Normal success or auto-success (01-05)
      result = 'Success';
      resultClass = 'roll-success';
    } else {
      result = 'Failure';
      resultClass = 'roll-failure';
    }
    
    this.showD100Result(skillName, targetPct, roll, result, resultClass);

    // Deactivate Divine Protection after rolling Willpower, Endurance, or Evade
    if (this.character.divineProtectionActive) {
      const normSkill = (skillName || '').toLowerCase().trim();
      if (normSkill === 'willpower' || normSkill === 'endurance' || normSkill === 'evade') {
        this.deactivateDivineProtection();
      }
    }

    // Deactivate Improved Aim after rolling Combat Skill
    if (this.character.improvedAimActive) {
      if (isCombatSkillRoll) {
        this.deactivateImprovedAim();
      }
    }

    // Species Enemy: deactivate after a roll
    if (this.character.speciesEnemyActive) {
      if (isCombatSkillRoll) {
        // Combat skill rolled — keep active until damage is rolled
        this.character.speciesEnemyCombatRolled = true;
      } else {
        // Non-combat roll — deactivate immediately
        this.deactivateSpeciesEnemy();
      }
    }
  },

  /**
   * Show d100 roll result overlay
   */
  showD100Result(skillName, targetPct, roll, result, resultClass) {
    const isFumble = resultClass === 'roll-fumble';
    
    // Look up skill-specific outcome text
    const outcomeText = this.getSkillOutcome(skillName, resultClass);
    const outcomeHTML = outcomeText
      ? `<div class="d100-outcome-text">${outcomeText}</div>`
      : '';
    
    // Create or get overlay
    let overlay = document.getElementById('d100-result-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'd100-result-overlay';
      overlay.className = 'damage-result-overlay';
      document.body.appendChild(overlay);
    }
    
    // Store fumble state so click-outside handler knows whether to close
    overlay.dataset.fumble = isFumble ? 'true' : 'false';
    
    // Remove old click handler and add fresh one
    const newOverlay = overlay.cloneNode(false);
    overlay.parentNode.replaceChild(newOverlay, overlay);
    overlay = newOverlay;
    
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay && overlay.dataset.fumble !== 'true') {
        overlay.classList.remove('visible');
      }
    });
    
    if (isFumble) {
      overlay.innerHTML = `
        <div class="damage-result-content d100-result-content d100-fumble-content">
          <div class="d100-skill-name">${skillName}</div>
          <div class="d100-target">Target: ${targetPct}%</div>
          <div class="d100-roll">${roll.toString().padStart(2, '0')}</div>
          <div class="d100-result roll-fumble">Fumble!</div>
          ${outcomeHTML}
          <div class="d100-fumble-text">
            Fumbled skills gain a free increase of 1%. It is a truism that we learn more from our mistakes than our successes, and this represents the reflection a character undergoes following a disastrous failure. Multiple fumbles of the same skill do not stack.
          </div>
          <div class="d100-fumble-question">Would you like to automatically add a point to this skill or do it yourself?</div>
          <div class="d100-fumble-buttons">
            <button class="damage-close d100-fumble-btn" id="d100-fumble-auto">Add Automatically</button>
            <button class="damage-close d100-fumble-btn d100-fumble-manual" id="d100-fumble-manual">Do It Myself</button>
          </div>
        </div>
      `;
      
      overlay.querySelector('#d100-fumble-auto').addEventListener('click', () => {
        this.applyFumbleIncrease(skillName);
        overlay.classList.remove('visible');
      });
      
      overlay.querySelector('#d100-fumble-manual').addEventListener('click', () => {
        overlay.classList.remove('visible');
      });
    } else {
      overlay.innerHTML = `
        <div class="damage-result-content d100-result-content">
          <div class="d100-skill-name">${skillName}</div>
          <div class="d100-target">Target: ${targetPct}%</div>
          <div class="d100-roll">${roll.toString().padStart(2, '0')}</div>
          <div class="d100-result ${resultClass}">${result}</div>
          ${outcomeHTML}
          <button class="damage-close">OK</button>
        </div>
      `;
      
      overlay.querySelector('.damage-close').addEventListener('click', () => {
        overlay.classList.remove('visible');
      });
    }
    
    overlay.classList.add('visible');
  },
  
  /**
   * Apply +1% fumble increase to a skill by name
   */
  applyFumbleIncrease(skillName) {
    const normalizedName = skillName.toLowerCase().trim();
    let found = false;
    
    // Search Standard Skills
    document.querySelectorAll('.standard-skills .skill-row').forEach(row => {
      const name = (row.querySelector('.skill-name')?.textContent || '').replace(/\u2139/g, '').toLowerCase().trim();
      if (name === normalizedName) {
        const input = row.querySelector('.skill-input');
        if (input) {
          input.value = (parseInt(input.value) || 0) + 1;
          input.dispatchEvent(new Event('change', { bubbles: true }));
          this._flashFumbleIncrease(input);
          found = true;
        }
      }
    });
    
    if (found) { this.scheduleAutoSave(); return; }
    
    // Search Professional Skills
    document.querySelectorAll('.professional-skill-row').forEach(row => {
      const name = (row.querySelector('.prof-skill-name')?.value || '').toLowerCase().trim();
      if (name === normalizedName) {
        const input = row.querySelector('.prof-skill-current');
        if (input) {
          input.value = (parseInt(input.value) || 0) + 1;
          input.dispatchEvent(new Event('change', { bubbles: true }));
          this._flashFumbleIncrease(input);
          found = true;
        }
      }
    });
    
    if (found) { this.scheduleAutoSave(); return; }
    
    // Search Alignment rows
    document.querySelectorAll('.alignment-section .belief-row').forEach(row => {
      const name = (row.querySelector('.belief-name')?.value || '').toLowerCase().trim();
      if (name === normalizedName) {
        const input = row.querySelector('.belief-input');
        if (input) {
          input.value = (parseInt(input.value) || 0) + 1;
          input.dispatchEvent(new Event('change', { bubbles: true }));
          this._flashFumbleIncrease(input);
          found = true;
        }
      }
    });
    
    if (found) { this.scheduleAutoSave(); return; }
    
    // Search Passions
    document.querySelectorAll('#passions-container .belief-row').forEach(row => {
      const name = (row.querySelector('.belief-name')?.value || '').toLowerCase().trim();
      if (name === normalizedName) {
        const input = row.querySelector('.belief-input');
        if (input) {
          input.value = (parseInt(input.value) || 0) + 1;
          input.dispatchEvent(new Event('change', { bubbles: true }));
          this._flashFumbleIncrease(input);
          found = true;
        }
      }
    });
    
    if (found) { this.scheduleAutoSave(); return; }
    
    // Search Oaths
    document.querySelectorAll('#oaths-container .belief-row').forEach(row => {
      const name = (row.querySelector('.belief-name')?.value || '').toLowerCase().trim();
      if (name === normalizedName) {
        const input = row.querySelector('.belief-input');
        if (input) {
          input.value = (parseInt(input.value) || 0) + 1;
          input.dispatchEvent(new Event('change', { bubbles: true }));
          this._flashFumbleIncrease(input);
          found = true;
        }
      }
    });
    
    if (found) { this.scheduleAutoSave(); return; }
    
    // Search Combat Skills
    document.querySelectorAll('.combat-skill-row').forEach(row => {
      const nameEl = row.querySelector('.combat-skill-name');
      const name = (nameEl?.tagName === 'INPUT' ? nameEl.value : nameEl?.textContent || '').toLowerCase().trim();
      if (name === normalizedName) {
        const input = row.querySelector('.combat-skill-percent');
        if (input) {
          input.value = (parseInt(input.value) || 0) + 1;
          input.dispatchEvent(new Event('change', { bubbles: true }));
          this._flashFumbleIncrease(input);
          found = true;
        }
      }
    });
    
    if (found) this.scheduleAutoSave();
  },
  
  /**
   * Flash highlight on an input that received a fumble increase
   */
  _flashFumbleIncrease(input) {
    const origBg = input.style.background;
    const origColor = input.style.color;
    input.style.background = '#4caf50';
    input.style.color = '#fff';
    input.style.transition = 'background 0.3s, color 0.3s';
    setTimeout(() => {
      input.style.background = origBg || '';
      input.style.color = origColor || '';
      setTimeout(() => { input.style.transition = ''; }, 300);
    }, 1200);
  },

  /**
   * Roll damage dice and show result
   */
  rollDamage(damageString) {
    // Parse damage string like "1d8+1+1d6" or "1d6+1d4"
    const result = this.parseDamageRoll(damageString);
    
    // Show result in an overlay
    this.showDamageResult(damageString, result);
  },

  /**
   * Parse and roll a damage string
   */
  parseDamageRoll(damageString) {
    // Normalize the string
    const normalized = damageString.toLowerCase().replace(/\s/g, '');
    
    // Split by + and - while keeping the operators
    const parts = normalized.split(/(?=[+-])/);
    
    let total = 0;
    const rolls = [];
    
    parts.forEach(part => {
      // Check if it's a dice roll (e.g., 1d8, 2d6)
      const diceMatch = part.match(/([+-]?)(\d*)d(\d+)/);
      if (diceMatch) {
        const sign = diceMatch[1] === '-' ? -1 : 1;
        const count = parseInt(diceMatch[2], 10) || 1;
        const sides = parseInt(diceMatch[3], 10);
        
        let diceTotal = 0;
        const individualRolls = [];
        for (let i = 0; i < count; i++) {
          const roll = Math.floor(Math.random() * sides) + 1;
          individualRolls.push(roll);
          diceTotal += roll;
        }
        
        rolls.push({ dice: `${count}d${sides}`, rolls: individualRolls, total: diceTotal * sign });
        total += diceTotal * sign;
      } else {
        // It's a modifier
        const numMatch = part.match(/([+-]?\d+)/);
        if (numMatch) {
          const mod = parseInt(numMatch[1], 10);
          rolls.push({ modifier: mod });
          total += mod;
        }
      }
    });
    
    return { total, rolls };
  },

  /**
   * Show damage roll result overlay
   */
  showDamageResult(damageString, result) {
    // Create or get overlay
    let overlay = document.getElementById('damage-result-overlay');
    if (!overlay) {
      overlay = document.createElement('div');
      overlay.id = 'damage-result-overlay';
      overlay.className = 'damage-result-overlay';
      overlay.innerHTML = `
        <div class="damage-result-content">
          <div class="damage-formula"></div>
          <div class="damage-breakdown"></div>
          <div class="damage-total"></div>
          <button class="damage-close">OK</button>
        </div>
      `;
      document.body.appendChild(overlay);
      
      overlay.querySelector('.damage-close').addEventListener('click', () => {
        overlay.classList.remove('visible');
      });
      
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.classList.remove('visible');
        }
      });
    }
    
    // Build breakdown string
    let breakdown = '';
    result.rolls.forEach((r, i) => {
      if (i > 0 && !breakdown.endsWith(' ')) breakdown += ' ';
      if (r.dice) {
        const rollsStr = r.rolls.join('+');
        breakdown += `${r.dice} (${rollsStr}=${r.total > 0 ? r.total : r.total})`;
      } else if (r.modifier !== undefined) {
        breakdown += (r.modifier >= 0 ? '+' : '') + r.modifier;
      }
    });
    
    overlay.querySelector('.damage-formula').textContent = `Damage: ${damageString}`;
    overlay.querySelector('.damage-breakdown').textContent = breakdown;
    overlay.querySelector('.damage-total').textContent = result.total;
    
    overlay.classList.add('visible');
  },
  
  /**
   * Remove a widget from the palette
   */
  removeWidgetFromPalette(widgetId) {
    const palette = document.getElementById('palette-widgets');
    if (!palette) return;
    
    const item = palette.querySelector(`[data-widget-id="${widgetId}"]`);
    if (item) item.remove();
  },
  
  /**
   * Add a widget back to the palette
   */
  addWidgetToPalette(widgetId) {
    const palette = document.getElementById('palette-widgets');
    const widget = this.summaryWidgets[widgetId];
    if (!palette || !widget) return;
    
    const item = document.createElement('div');
    item.className = 'widget-item';
    item.draggable = true;
    item.dataset.widgetId = widgetId;
    item.innerHTML = `<span class="widget-icon">${widget.icon}</span><span>${widget.name}</span>`;
    
    item.addEventListener('dragstart', (e) => {
      e.dataTransfer.setData('text/plain', widgetId);
      item.classList.add('dragging');
    });
    
    item.addEventListener('dragend', () => {
      item.classList.remove('dragging');
    });
    
    palette.appendChild(item);
  },
  
  /**
   * Save current summary layout to localStorage
   */
  saveSummaryLayout() {
    const canvas = document.getElementById('summary-canvas');
    if (!canvas) return;
    
    const widgetIds = Array.from(canvas.querySelectorAll('.widget-item'))
      .map(item => item.dataset.widgetId)
      .filter(id => id);
    
    try {
      localStorage.setItem('mythras-summary-layout', JSON.stringify(widgetIds));
    } catch (e) {
      console.warn('Could not save summary layout');
    }
  },
  
  /**
   * Load summary layout from localStorage
   */
  loadSummaryLayout() {
    try {
      const saved = localStorage.getItem('mythras-summary-layout');
      if (saved) {
        return JSON.parse(saved);
      }
    } catch (e) {
      // Ignore
    }
    // Default layout
    return ['character-info', 'characteristics', 'attributes', 'hp-overview'];
  },
  
  /**
   * Reset summary layout to default
   */
  resetSummaryLayout() {
    try {
      localStorage.removeItem('mythras-summary-layout');
    } catch (e) {
      // Ignore
    }
    
    const defaultLayout = ['character-info', 'characteristics', 'attributes', 'hp-overview'];
    this.populatePalette(defaultLayout);
    this.populateCanvas(defaultLayout);
  },
  
  /**
   * Refresh all widgets on the summary canvas
   */
  refreshSummaryWidgets() {
    const canvas = document.getElementById('summary-canvas');
    if (!canvas) return;
    
    // Use requestAnimationFrame to ensure DOM is ready after page switch
    requestAnimationFrame(() => {
      canvas.querySelectorAll('.widget-item').forEach(item => {
        const widgetId = item.dataset.widgetId;
        const widget = this.summaryWidgets[widgetId];
        if (widget) {
          const content = item.querySelector('.widget-content');
          if (content) {
            content.innerHTML = widget.render();
          }
        }
      });
    });
  },
  
  /**
   * Refresh a single widget on the summary canvas by ID
   */
  refreshSummaryWidget(widgetId) {
    const canvas = document.getElementById('summary-canvas');
    if (!canvas) return;
    
    const item = canvas.querySelector(`.widget-item[data-widget-id="${widgetId}"]`);
    if (item) {
      const widget = this.summaryWidgets[widgetId];
      if (widget) {
        const content = item.querySelector('.widget-content');
        if (content) {
          content.innerHTML = widget.render();
        }
      }
    }
  },

  /**
   * Setup alphabetize buttons
   */
  setupAlphabetizeButton() {
    // Professional Skills
    const profBtn = document.getElementById('btn-alphabetize-prof');
    if (profBtn) {
      profBtn.addEventListener('click', () => this.alphabetizeProfessionalSkills());
    }
    
    // Passions
    const passionsBtn = document.getElementById('btn-alphabetize-passions');
    if (passionsBtn) {
      passionsBtn.addEventListener('click', () => this.alphabetizeBeliefs('passions'));
    }
    
    // Oaths
    const oathsBtn = document.getElementById('btn-alphabetize-oaths');
    if (oathsBtn) {
      oathsBtn.addEventListener('click', () => this.alphabetizeBeliefs('oaths'));
    }
    
    // Languages
    const langBtn = document.getElementById('btn-alphabetize-languages');
    if (langBtn) {
      langBtn.addEventListener('click', () => this.alphabetizeLanguages());
    }
    
    // Equipment
    const equipBtn = document.getElementById('btn-alphabetize-equipment');
    if (equipBtn) {
      equipBtn.addEventListener('click', () => this.alphabetizeEquipment());
    }
    
    // Melee Weapons
    const meleeBtn = document.getElementById('btn-alphabetize-melee');
    if (meleeBtn) {
      meleeBtn.addEventListener('click', () => this.alphabetizeMeleeWeapons());
    }
    
    // Ranged Weapons
    const rangedBtn = document.getElementById('btn-alphabetize-ranged');
    if (rangedBtn) {
      rangedBtn.addEventListener('click', () => this.alphabetizeRangedWeapons());
    }
  },

  /**
   * Setup add/remove row buttons
   */
  setupAddRowButtons() {
    // Professional Skills
    document.getElementById('btn-add-prof-skill')?.addEventListener('click', () => this.addProfessionalSkillRow());
    document.getElementById('btn-remove-prof-skill')?.addEventListener('click', () => this.removeLastRow('professional-skills-container', '.professional-skill-row', '.prof-skill-name'));
    
    // Languages
    document.getElementById('btn-add-language')?.addEventListener('click', () => this.addLanguageRow());
    document.getElementById('btn-remove-language')?.addEventListener('click', () => this.removeLastLanguageRow());
    
    // Oaths
    document.getElementById('btn-add-oath')?.addEventListener('click', () => this.addOathRow());
    document.getElementById('btn-remove-oath')?.addEventListener('click', () => this.removeLastRow('oaths-container', '.belief-row', '.belief-name'));
    
    // Alignments
    document.getElementById('btn-add-alignment')?.addEventListener('click', () => this.addAlignmentRow());
    document.getElementById('btn-remove-alignment')?.addEventListener('click', () => this.removeLastRow('alignment-container', '.belief-row', '.belief-name'));
    
    // Passions
    document.getElementById('btn-add-passion')?.addEventListener('click', () => this.addPassionRow());
    document.getElementById('btn-remove-passion')?.addEventListener('click', () => this.removeLastRow('passions-container', '.belief-row', '.belief-name'));
    
    // Equipment
    document.getElementById('btn-add-equipment')?.addEventListener('click', () => this.addEquipmentRow());
    document.getElementById('btn-remove-equipment')?.addEventListener('click', () => this.removeLastRow('equipment-container', '.equipment-row', '.equipment-name'));
    
    // Melee Weapons
    document.getElementById('btn-add-melee')?.addEventListener('click', () => this.addMeleeWeaponRow());
    document.getElementById('btn-remove-melee')?.addEventListener('click', () => this.removeLastRow('melee-weapons-body', 'tr', '.weapon-name'));
    
    // Ranged Weapons
    document.getElementById('btn-add-ranged')?.addEventListener('click', () => this.addRangedWeaponRow());
    document.getElementById('btn-remove-ranged')?.addEventListener('click', () => this.removeLastRow('ranged-weapons-body', 'tr', '.weapon-name'));
  },
  
  /**
   * Remove last row from a section (warn if has content)
   */
  removeLastRow(containerId, rowSelector, dataFieldSelector) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const rows = Array.from(container.querySelectorAll(rowSelector));
    if (rows.length === 0) return;
    
    const lastRow = rows[rows.length - 1];
    const dataField = lastRow.querySelector(dataFieldSelector);
    const hasContent = dataField && dataField.value.trim();
    
    if (hasContent) {
      // Warn user before deleting row with content
      const confirmed = confirm(`Remove "${dataField.value.trim()}"?\n\nThis will delete this row.`);
      if (!confirmed) return;
    }
    
    // If this is a weapon row, sync deletion to Equipment page
    const isWeaponRow = containerId === 'melee-weapons-body' || containerId === 'ranged-weapons-body';
    const weaponName = isWeaponRow && dataField ? dataField.value.trim() : '';
    
    lastRow.remove();
    this.reindexSection(containerId, rowSelector);
    
    // Remove from Equipment if it was a weapon
    if (isWeaponRow && weaponName) {
      this._removeWeaponFromEquipment(weaponName);
    }
    
    this.scheduleAutoSave();
  },
  
  /**
   * Remove a weapon from the Equipment page by name
   */
  _removeWeaponFromEquipment(weaponName) {
    if (!weaponName) return;
    const targetName = weaponName.toLowerCase().trim();
    let found = false;
    
    // Search both equipment containers: main and sub-container (bags/backpacks)
    ['equipment-container', 'container-items'].forEach(containerId => {
      const container = document.getElementById(containerId);
      if (!container) return;
      const rows = Array.from(container.querySelectorAll('.equipment-row'));
      for (const row of rows) {
        const nameInput = row.querySelector('.equipment-name');
        if (!nameInput) continue;
        const rowName = nameInput.value.trim().toLowerCase();
        if (rowName === targetName || this._weaponNameMatches(rowName, targetName)) {
          row.remove();
          found = true;
        }
      }
    });
    
    if (found) {
      // Re-index equipment IDs after removal
      const mainContainer = document.getElementById('equipment-container');
      if (mainContainer) {
        mainContainer.querySelectorAll('.equipment-row').forEach((row, i) => {
          const nameInput = row.querySelector('.equipment-name');
          const encInput = row.querySelector('.equipment-enc');
          if (nameInput) nameInput.id = `equip-${i}-name`;
          if (encInput) encInput.id = `equip-${i}-enc`;
        });
      }
      const subContainer = document.getElementById('container-items');
      if (subContainer) {
        subContainer.querySelectorAll('.equipment-row').forEach((row, i) => {
          const nameInput = row.querySelector('.equipment-name');
          const encInput = row.querySelector('.equipment-enc');
          if (nameInput) nameInput.id = `container-${i}-name`;
          if (encInput) encInput.id = `container-${i}-enc`;
        });
      }
    }
    
    // Also remove from dual-category combat section if applicable
    const classification = this.classifyWeaponByName(weaponName);
    if (classification && classification.type === 'dual') {
      // Remove from the other combat section too
      ['melee-weapons-body', 'ranged-weapons-body'].forEach(bodyId => {
        const body = document.getElementById(bodyId);
        if (!body) return;
        const rows = Array.from(body.querySelectorAll('tr'));
        for (const row of rows) {
          const nameInput = row.querySelector('.weapon-name');
          if (!nameInput) continue;
          const rowName = nameInput.value.trim().toLowerCase();
          if (rowName === targetName || this._weaponNameMatches(rowName, targetName)) {
            row.remove();
          }
        }
      });
      // Re-index both weapon sections
      this.reindexSection('melee-weapons-body', 'tr');
      this.reindexSection('ranged-weapons-body', 'tr');
    }
    
    // Recalculate encumbrance after removing
    if (found) {
      this.updateTotalEnc();
      if (window.EncumbranceData && window.EncumbranceData.recalculateEncumbrance) {
        window.EncumbranceData.recalculateEncumbrance();
      }
      this.collectFormData();
      this.scheduleAutoSave();
    }
  },
  
  /**
   * Remove last language row (skip native tongue, warn if has content)
   */
  removeLastLanguageRow() {
    const container = document.getElementById('language-container');
    if (!container) return;
    
    const rows = Array.from(container.querySelectorAll('.language-row:not(.native)'));
    if (rows.length === 0) return;
    
    const lastRow = rows[rows.length - 1];
    const nameField = lastRow.querySelector('.language-name');
    const hasContent = nameField && nameField.value.trim();
    
    if (hasContent) {
      const confirmed = confirm(`Remove "${nameField.value.trim()}"?\n\nThis will delete this language.`);
      if (!confirmed) return;
    }
    
    lastRow.remove();
    this.reindexLanguages();
    this.scheduleAutoSave();
  },

  /**
   * Setup event listeners for passion formula inputs
   */
  setupPassionFormulaListeners() {
    const container = document.getElementById('passions-container');
    if (!container) return;
    
    container.querySelectorAll('.belief-formula-input').forEach(input => {
      input.addEventListener('input', () => {
        this.recalculateAll();
        this.scheduleAutoSave();
      });
    });
  },

  /**
   * Alphabetize beliefs (passions or oaths)
   */
  alphabetizeBeliefs(type) {
    const containerId = type === 'passions' ? 'passions-container' : 'oaths-container';
    const container = document.getElementById(containerId);
    if (!container) return;
    
    // Gather all beliefs with their data
    const beliefs = [];
    const rows = container.querySelectorAll('.belief-row');
    rows.forEach(row => {
      const nameInput = row.querySelector('.belief-name');
      const currentInput = row.querySelector('.belief-input');
      const formulaInput = row.querySelector('.belief-formula-input');
      if (nameInput && nameInput.value.trim()) {
        beliefs.push({
          name: nameInput.value.trim(),
          current: currentInput?.value || '',
          formula: formulaInput?.value || ''
        });
      }
    });
    
    // Sort alphabetically
    beliefs.sort((a, b) => a.name.localeCompare(b.name));
    
    // Re-populate rows
    rows.forEach((row, i) => {
      const nameInput = row.querySelector('.belief-name');
      const currentInput = row.querySelector('.belief-input');
      const formulaInput = row.querySelector('.belief-formula-input');
      if (i < beliefs.length) {
        nameInput.value = beliefs[i].name;
        currentInput.value = beliefs[i].current;
        if (formulaInput && beliefs[i].formula) {
          formulaInput.value = beliefs[i].formula;
        }
      } else {
        nameInput.value = '';
        currentInput.value = '';
        if (formulaInput) formulaInput.value = 'POW+INT+50';
      }
    });
    
    this.recalculateAll();
    this.scheduleAutoSave();
  },

  /**
   * Alphabetize languages (keeping Native Tongue at top)
   */
  alphabetizeLanguages() {
    const container = document.getElementById('language-container');
    if (!container) return;
    
    // Gather non-native languages with all data
    const languages = [];
    const rows = container.querySelectorAll('.language-row:not(.native)');
    rows.forEach(row => {
      const nameInput = row.querySelector('.language-name');
      const currentInput = row.querySelector('.language-input');
      const formulaSpan = row.querySelector('.language-formula');
      if (nameInput && nameInput.value.trim()) {
        languages.push({
          name: nameInput.value.trim(),
          current: currentInput?.value || '',
          classLanguage: nameInput.dataset.classLanguage || null,
          classGranted: row.dataset.classGranted || null,
          formula: formulaSpan?.textContent || 'INT+CHA'
        });
      }
    });
    
    // Sort alphabetically
    languages.sort((a, b) => a.name.localeCompare(b.name));
    
    // Remove all non-native rows
    rows.forEach(row => row.remove());
    
    // Re-create only filled rows
    languages.forEach(lang => {
      const newIndex = container.querySelectorAll('.language-row:not(.native)').length + 2;
      const row = document.createElement('div');
      row.className = 'language-row';
      if (lang.classGranted) row.dataset.classGranted = 'true';
      row.innerHTML = `
        <input type="text" class="language-name" id="language-${newIndex}-name" placeholder="" value="${lang.name.replace(/"/g, '&quot;')}"${lang.classLanguage ? ` data-class-language="${lang.classLanguage}"` : ''}>
        <span class="language-formula">${lang.formula}</span>
        <span class="language-base" id="language-${newIndex}-base">0</span>
        <input type="number" class="language-input" id="language-${newIndex}-current" placeholder="" value="${lang.current}">
      `;
      container.appendChild(row);
      
      // Add event listeners with auto-remove on empty
      const nameInput = row.querySelector('.language-name');
      const currentInput = row.querySelector('.language-input');
      nameInput.addEventListener('blur', (e) => {
        if (e.target.value.trim()) {
          e.target.value = this.toTitleCase(e.target.value.trim());
        } else {
          row.remove();
          this.reindexLanguages();
        }
        this.scheduleAutoSave();
      });
      nameInput.addEventListener('input', () => this.scheduleAutoSave());
      currentInput.addEventListener('input', () => this.scheduleAutoSave());
    });
    
    // Recalculate bases
    this.recalculateAll();
    this.scheduleAutoSave();
  },
  
  /**
   * Alphabetize equipment
   */
  alphabetizeEquipment() {
    const container = document.getElementById('equipment-container');
    if (!container) return;
    
    // Gather all equipment with data
    const equipment = [];
    const rows = container.querySelectorAll('.equipment-row');
    rows.forEach(row => {
      const nameInput = row.querySelector('.equipment-name');
      const encInput = row.querySelector('.equipment-enc');
      if (nameInput && nameInput.value.trim()) {
        equipment.push({
          name: nameInput.value.trim(),
          enc: encInput?.value || ''
        });
      }
    });
    
    // Sort alphabetically
    equipment.sort((a, b) => a.name.localeCompare(b.name));
    
    // Clear container and re-create rows with sorted data
    container.innerHTML = '';
    equipment.forEach((item, index) => {
      const row = document.createElement('div');
      row.className = 'equipment-row';
      row.innerHTML = `
        <input type="text" class="equipment-name" id="equip-${index}-name" placeholder="" value="${item.name.replace(/"/g, '&quot;')}">
        <input type="number" class="equipment-enc" id="equip-${index}-enc" placeholder="" step="0.1" value="${item.enc}">
      `;
      container.appendChild(row);
      
      // Re-attach event listeners
      const nameInput = row.querySelector('.equipment-name');
      const encInput = row.querySelector('.equipment-enc');
      
      nameInput.dataset.previousValue = item.name.toLowerCase();
      
      nameInput.addEventListener('focus', () => {
        nameInput.dataset.previousValue = nameInput.value.trim().toLowerCase();
      });
      
      nameInput.addEventListener('focus', () => {
        nameInput.dataset.previousValue = nameInput.value.trim().toLowerCase();
      });
      
      nameInput.addEventListener('blur', async () => {
        const currentValue = nameInput.value.trim().toLowerCase();
        const previousValue = nameInput.dataset.previousValue || '';
        
        if (previousValue && (!currentValue || currentValue !== previousValue)) {
          const removedContainer = this.getContainerIdFromItemName(previousValue);
          if (removedContainer) {
            // Check if the new value is also a container (transfer scenario)
            const newContainer = currentValue ? this.getContainerIdFromItemName(currentValue) : null;
            if (newContainer && newContainer !== removedContainer && this.containerHasItems(removedContainer)) {
              this.transferContainerItems(removedContainer, newContainer);
            } else {
              const stillExists = this.containerStillExistsElsewhere(removedContainer, index);
              if (!stillExists) {
                const hasItems = this.containerHasItems(removedContainer);
                if (hasItems) {
                  const handled = await this.handleContainerRemoval(removedContainer, nameInput, previousValue);
                  if (!handled) {
                    nameInput.value = previousValue;
                    nameInput.dataset.previousValue = previousValue;
                    return;
                  }
                }
              }
            }
          }
        }
        
        nameInput.dataset.previousValue = nameInput.value.trim().toLowerCase();
        
        if (nameInput.value.trim()) {
          let itemName = this.toTitleCase(nameInput.value.trim());
          const containerId = this.getContainerIdFromItemName(itemName);
          if (containerId && !itemName.toLowerCase().includes('see below')) {
            itemName = itemName + ' (See Below)';
            
            // Check if this new container upgrades an existing one with items
            const upgradeMap = { 'reinforced-backpack': 'backpack' };
            const oldContainerId = upgradeMap[containerId];
            if (oldContainerId && this.containerHasItems(oldContainerId)) {
              this.transferContainerItems(oldContainerId, containerId);
            }
          }
          nameInput.value = itemName;
        }
        
        if (window.EncumbranceData) {
          const itemName = nameInput.value;
          if (itemName.trim() === '') {
            window.EncumbranceData.clearEquipmentEncIfEmpty('equip', index, itemName);
          } else {
            window.EncumbranceData.autofillEquipmentEnc('equip', index, itemName);
          }
          this.updateTotalEnc();
          this.updateContainerButtons();
          this.scheduleAutoSave();
        }
        
        // Sync weapon to combat page
        if (nameInput.value.trim()) {
          this.syncEquipmentToCombat(nameInput.value.trim());
        }
      });
      
      nameInput.addEventListener('input', () => {
        this.updateTotalEnc();
        this.updateContainerButtons();
        this.scheduleAutoSave();
      });
      
      encInput.addEventListener('input', () => {
        this.updateTotalEnc();
        this.scheduleAutoSave();
      });
    });
    
    this.updateTotalEnc();
    this.updateContainerButtons();
    this.scheduleAutoSave();
  },

  /**
   * Alphabetize melee weapons
   */
  alphabetizeMeleeWeapons() {
    const tbody = document.getElementById('melee-weapons-body');
    if (!tbody) return;
    
    // Gather all weapons with data
    const weapons = [];
    const rows = tbody.querySelectorAll('tr');
    rows.forEach(row => {
      const nameInput = row.querySelector('.weapon-name');
      if (nameInput && nameInput.value.trim()) {
        // Collect all field values
        const fields = Array.from(row.querySelectorAll('input')).map(input => ({
          value: input.value,
          baseDamage: input.dataset.baseDamage || '',
          weaponName: input.dataset.weaponName || '',
          userModified: input.dataset.userModified || ''
        }));
        weapons.push({
          name: nameInput.value.trim(),
          fields: fields,
          userModified: nameInput.dataset.userModified || ''
        });
      }
    });
    
    // Sort alphabetically by weapon name
    weapons.sort((a, b) => a.name.localeCompare(b.name));
    
    // Reassign to rows
    let weaponIndex = 0;
    rows.forEach(row => {
      const inputs = row.querySelectorAll('input');
      if (weaponIndex < weapons.length) {
        const weapon = weapons[weaponIndex];
        inputs.forEach((input, i) => {
          if (weapon.fields[i]) {
            input.value = weapon.fields[i].value;
            if (weapon.fields[i].baseDamage) {
              input.dataset.baseDamage = weapon.fields[i].baseDamage;
            }
            if (weapon.fields[i].weaponName) {
              input.dataset.weaponName = weapon.fields[i].weaponName;
            }
          }
        });
        // Preserve userModified on name input
        const nameInput = row.querySelector('.weapon-name');
        if (nameInput && weapon.userModified) {
          nameInput.dataset.userModified = weapon.userModified;
        }
        weaponIndex++;
      } else {
        // Clear remaining rows
        inputs.forEach(input => {
          input.value = '';
          delete input.dataset.baseDamage;
          delete input.dataset.weaponName;
          delete input.dataset.userModified;
        });
      }
    });
    
    this.scheduleAutoSave();
  },

  /**
   * Alphabetize ranged weapons
   */
  alphabetizeRangedWeapons() {
    const tbody = document.getElementById('ranged-weapons-body');
    if (!tbody) return;
    
    // Gather all weapons with data
    const weapons = [];
    const rows = tbody.querySelectorAll('tr');
    rows.forEach(row => {
      const nameInput = row.querySelector('.weapon-name');
      if (nameInput && nameInput.value.trim()) {
        // Collect all field values
        const fields = Array.from(row.querySelectorAll('input')).map(input => ({
          value: input.value,
          baseDamage: input.dataset.baseDamage || '',
          weaponName: input.dataset.weaponName || '',
          userModified: input.dataset.userModified || ''
        }));
        weapons.push({
          name: nameInput.value.trim(),
          fields: fields,
          userModified: nameInput.dataset.userModified || ''
        });
      }
    });
    
    // Sort alphabetically by weapon name
    weapons.sort((a, b) => a.name.localeCompare(b.name));
    
    // Reassign to rows
    let weaponIndex = 0;
    rows.forEach(row => {
      const inputs = row.querySelectorAll('input');
      if (weaponIndex < weapons.length) {
        const weapon = weapons[weaponIndex];
        inputs.forEach((input, i) => {
          if (weapon.fields[i]) {
            input.value = weapon.fields[i].value;
            if (weapon.fields[i].baseDamage) {
              input.dataset.baseDamage = weapon.fields[i].baseDamage;
            }
            if (weapon.fields[i].weaponName) {
              input.dataset.weaponName = weapon.fields[i].weaponName;
            }
          }
        });
        // Preserve userModified on name input
        const nameInput = row.querySelector('.weapon-name');
        if (nameInput && weapon.userModified) {
          nameInput.dataset.userModified = weapon.userModified;
        }
        weaponIndex++;
      } else {
        // Clear remaining rows
        inputs.forEach(input => {
          input.value = '';
          delete input.dataset.baseDamage;
          delete input.dataset.weaponName;
          delete input.dataset.userModified;
        });
      }
    });
    
    this.scheduleAutoSave();
  },

  /**
   * Generic remove row with warning
   */
  removeRow(containerId, rowClass, typeName) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const rows = container.querySelectorAll(`.${rowClass}`);
    if (rows.length <= 1) {
      alert(`Cannot remove the last ${typeName} row.`);
      return;
    }
    
    const lastRow = rows[rows.length - 1];
    const nameInput = lastRow.querySelector('input[type="text"]');
    const hasContent = nameInput && nameInput.value.trim();
    
    if (hasContent) {
      if (!confirm(`The last ${typeName} row contains "${nameInput.value}". Delete it permanently?`)) {
        return;
      }
    }
    
    lastRow.remove();
    this.scheduleAutoSave();
  },

  /**
   * Remove language row with warning
   */
  removeLanguageRow() {
    const container = document.getElementById('language-container');
    if (!container) return;
    
    const rows = container.querySelectorAll('.language-row:not(.native)');
    if (rows.length <= 1) {
      alert('Cannot remove the last Language row.');
      return;
    }
    
    const lastRow = rows[rows.length - 1];
    const nameInput = lastRow.querySelector('.language-name');
    const hasContent = nameInput && nameInput.value.trim();
    
    if (hasContent) {
      if (!confirm(`The last Language row contains "${nameInput.value}". Delete it permanently?`)) {
        return;
      }
    }
    
    lastRow.remove();
    this.scheduleAutoSave();
  },

  /**
   * Remove belief row (passion/oath) with warning
   */
  removeBeliefRow(containerId, typeName) {
    const container = document.getElementById(containerId);
    if (!container) return;
    
    const rows = container.querySelectorAll('.belief-row');
    if (rows.length <= 1) {
      alert(`Cannot remove the last ${typeName} row.`);
      return;
    }
    
    const lastRow = rows[rows.length - 1];
    const nameInput = lastRow.querySelector('.belief-name');
    const hasContent = nameInput && nameInput.value.trim();
    
    if (hasContent) {
      if (!confirm(`The last ${typeName} row contains "${nameInput.value}". Delete it permanently?`)) {
        return;
      }
    }
    
    lastRow.remove();
    this.scheduleAutoSave();
  },

  /**
   * Remove equipment row with warning
   */
  removeEquipmentRow() {
    const container = document.getElementById('equipment-container');
    if (!container) return;
    
    const rows = container.querySelectorAll('.equipment-row');
    if (rows.length <= 1) {
      alert('Cannot remove the last Equipment row.');
      return;
    }
    
    const lastRow = rows[rows.length - 1];
    const nameInput = lastRow.querySelector('.equipment-name');
    const hasContent = nameInput && nameInput.value.trim();
    
    if (hasContent) {
      if (!confirm(`The last Equipment row contains "${nameInput.value}". Delete it permanently?`)) {
        return;
      }
    }
    
    lastRow.remove();
    this.updateTotalEnc();
    this.scheduleAutoSave();
  },

  /**
   * Add a new passion row
   */
  addPassionRow() {
    const container = document.getElementById('passions-container');
    if (!container) return;
    
    const rows = container.querySelectorAll('.belief-row');
    const newIndex = rows.length + 1;
    
    const row = document.createElement('div');
    row.className = 'belief-row';
    row.dataset.index = newIndex;
    row.innerHTML = `
      <input type="text" class="belief-name" id="passion-${newIndex}-name" placeholder="">
      <input type="text" class="belief-formula-input" id="passion-${newIndex}-formula" value="POW+INT+50" placeholder="e.g. POW+INT+50">
      <span class="belief-base" id="passion-${newIndex}-base">0</span>
      <input type="number" class="belief-input" id="passion-${newIndex}-current" placeholder="">
    `;
    container.appendChild(row);
    
    // Add formula input listener
    const formulaInput = row.querySelector('.belief-formula-input');
    if (formulaInput) {
      formulaInput.addEventListener('input', () => {
        this.recalculateAll();
        this.scheduleAutoSave();
      });
    }
    
    this.recalculateAll();
    row.querySelector('.belief-name').focus();
    this.scheduleAutoSave();
    this.addSkillDiceButtons();
  },

  /**
   * Add a new professional skill row
   */
  addProfessionalSkillRow(autoFocus = true) {
    const container = document.getElementById('professional-skills-container');
    if (!container) return;
    
    // Find current highest index
    const rows = container.querySelectorAll('.professional-skill-row');
    const newIndex = rows.length;
    
    const row = document.createElement('div');
    row.className = 'professional-skill-row';
    row.innerHTML = `
      <span class="prereq-keys" id="prof-skill-${newIndex}-prereq" data-skill-name=""></span>
      <input type="text" class="prof-skill-name" id="prof-skill-${newIndex}-name" placeholder="">
      <input type="text" class="prof-skill-base" id="prof-skill-${newIndex}-base" placeholder="" readonly>
      <span class="prof-skill-base-val" id="prof-skill-${newIndex}-base-val"></span>
      <input type="number" class="prof-skill-current" id="prof-skill-${newIndex}-current" placeholder="">
      <span class="enc-indicator prof-enc-indicator" id="prof-skill-${newIndex}-enc" style="display: none;" title="Affected by ENC"></span>
    `;
    container.appendChild(row);
    
    // Add event listeners (same as generateProfessionalSkills)
    const nameInput = row.querySelector('.prof-skill-name');
    const baseInput = row.querySelector('.prof-skill-base');
    const currentInput = row.querySelector('.prof-skill-current');
    const prereqKeys = row.querySelector('.prereq-keys');
    
    // Track previous name for deletion detection
    nameInput.dataset.previousName = '';
    
    nameInput.addEventListener('blur', () => {
      if (nameInput.value.trim()) {
        nameInput.value = this.toTitleCase(nameInput.value.trim());
        prereqKeys.dataset.skillName = nameInput.value;
        // Auto-fill formula on blur
        this.autoFillProfessionalSkillFormula(nameInput, baseInput);
        this.updatePrereqKeys();
        this.scheduleAutoSave();
      }
    });
    
    nameInput.addEventListener('input', () => {
      this.autoFillProfessionalSkillFormula(nameInput, baseInput);
      this.updateProfessionalSkillData(newIndex);
      this.updateProfSkillEncIndicator(newIndex);
      prereqKeys.dataset.skillName = nameInput.value.trim();
      this.updatePrereqKeys();
      this.scheduleAutoSave();
    });
    
    baseInput.addEventListener('input', () => {
      this.calculateProfessionalSkillBase(newIndex);
      this.updateProfessionalSkillData(newIndex);
      this.updateProfSkillEncIndicator(newIndex);
      this.scheduleAutoSave();
    });
    
    currentInput.addEventListener('input', (e) => {
      if (e.target.classList.contains('enc-penalized-value')) {
        const newOriginal = e.target.value;
        e.target.dataset.originalValue = newOriginal;
        setTimeout(() => this.updateTotalEnc(), 10);
      } else if (e.target.dataset.originalValue !== undefined) {
        e.target.dataset.originalValue = e.target.value;
      }
      this.updateProfessionalSkillData(newIndex);
      this.syncProfSkillToMagic(newIndex);
      this.scheduleAutoSave();
    });
    
    // Scroll to show new row (only when user-initiated)
    if (autoFocus) {
      row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      nameInput.focus();
    }
    
    this.scheduleAutoSave();
    this.addSkillDiceButtons();
  },

  /**
   * Add a new language row
   */
  addLanguageRow() {
    const container = document.getElementById('language-container');
    if (!container) return;
    
    // Find current highest index
    const rows = container.querySelectorAll('.language-row:not(.native)');
    const newIndex = rows.length + 2; // +2 because native is 1, first additional is 2
    
    const row = document.createElement('div');
    row.className = 'language-row';
    row.innerHTML = `
      <input type="text" class="language-name" id="language-${newIndex}-name" placeholder="">
      <span class="language-formula">INT+CHA</span>
      <span class="language-base" id="language-${newIndex}-base">0</span>
      <input type="number" class="language-input" id="language-${newIndex}-current" placeholder="">
    `;
    container.appendChild(row);
    
    // Add event listeners with auto-remove on empty
    const nameInput = row.querySelector('.language-name');
    const currentInput = row.querySelector('.language-input');
    
    nameInput.addEventListener('blur', (e) => {
      if (e.target.value.trim()) {
        e.target.value = this.toTitleCase(e.target.value.trim());
      } else {
        // Name cleared - remove this row
        row.remove();
        this.reindexLanguages();
      }
      this.scheduleAutoSave();
    });
    nameInput.addEventListener('input', () => this.scheduleAutoSave());
    currentInput.addEventListener('input', () => this.scheduleAutoSave());
    
    // Calculate base value
    this.recalculateAll();
    
    // Focus the new row
    nameInput.focus();
    
    this.scheduleAutoSave();
  },

  /**
   * Add a new oath row
   */
  addAlignmentRow() {
    const container = document.getElementById('alignment-container');
    if (!container) return;
    
    // Find current highest index
    const rows = container.querySelectorAll('.belief-row');
    const newIndex = rows.length + 1;
    
    const row = document.createElement('div');
    row.className = 'belief-row';
    row.dataset.index = newIndex;
    row.innerHTML = `
      <input type="text" class="belief-name" id="alignment-${newIndex}-name" placeholder="">
      <span class="belief-formula">POW+INT+50</span>
      <span class="belief-base" id="alignment-${newIndex}-base">0</span>
      <input type="number" class="belief-input" id="alignment-${newIndex}-current" placeholder="">
    `;
    container.appendChild(row);
    
    // Calculate base value
    this.recalculateAll();
    
    // Focus the new row
    row.querySelector('.belief-name').focus();
    
    this.scheduleAutoSave();
    this.addSkillDiceButtons();
  },

  addOathRow() {
    const container = document.getElementById('oaths-container');
    if (!container) return;
    
    // Find current highest index
    const rows = container.querySelectorAll('.belief-row');
    const newIndex = rows.length + 1;
    
    const row = document.createElement('div');
    row.className = 'belief-row';
    row.dataset.index = newIndex;
    row.innerHTML = `
      <input type="text" class="belief-name" id="oath-${newIndex}-name" placeholder="">
      <span class="belief-formula">POW+CHA+50</span>
      <span class="belief-base" id="oath-${newIndex}-base">0</span>
      <input type="number" class="belief-input" id="oath-${newIndex}-current" placeholder="">
    `;
    container.appendChild(row);
    
    // Calculate base value
    this.recalculateAll();
    
    // Focus the new row
    row.querySelector('.belief-name').focus();
    
    this.scheduleAutoSave();
    this.addSkillDiceButtons();
  },

  /**
   * Add a new equipment row
   */
  addEquipmentRow() {
    const container = document.getElementById('equipment-container');
    if (!container) return;
    
    const rows = container.querySelectorAll('.equipment-row');
    const newIndex = rows.length;
    
    const row = document.createElement('div');
    row.className = 'equipment-row';
    row.innerHTML = `
      <input type="text" class="equipment-name" id="equip-${newIndex}-name" placeholder="">
      <input type="number" class="equipment-enc" id="equip-${newIndex}-enc" placeholder="" step="0.1">
    `;
    container.appendChild(row);
    
    // Add event listeners (same as generateEquipmentRows)
    const nameInput = row.querySelector('.equipment-name');
    const encInput = row.querySelector('.equipment-enc');
    const rowIndex = newIndex;
    
    nameInput.dataset.previousValue = '';
    
    nameInput.addEventListener('focus', () => {
      nameInput.dataset.previousValue = nameInput.value.trim().toLowerCase();
    });
    
    nameInput.addEventListener('blur', async () => {
      const currentValue = nameInput.value.trim().toLowerCase();
      const previousValue = nameInput.dataset.previousValue || '';
      
      if (previousValue && (!currentValue || currentValue !== previousValue)) {
        const removedContainer = this.getContainerIdFromItemName(previousValue);
        if (removedContainer) {
          // Check if the new value is also a container (transfer scenario)
          const newContainer = currentValue ? this.getContainerIdFromItemName(currentValue) : null;
          if (newContainer && newContainer !== removedContainer && this.containerHasItems(removedContainer)) {
            this.transferContainerItems(removedContainer, newContainer);
          } else {
            const stillExists = this.containerStillExistsElsewhere(removedContainer, rowIndex);
            if (!stillExists) {
              const hasItems = this.containerHasItems(removedContainer);
              if (hasItems) {
                const handled = await this.handleContainerRemoval(removedContainer, nameInput, previousValue);
                if (!handled) {
                  nameInput.value = previousValue;
                  nameInput.dataset.previousValue = previousValue;
                  return;
                }
              }
            }
          }
        }
      }
      
      nameInput.dataset.previousValue = nameInput.value.trim().toLowerCase();
      
      if (nameInput.value.trim()) {
        let itemName = this.toTitleCase(nameInput.value.trim());
        const containerId = this.getContainerIdFromItemName(itemName);
        if (containerId && !itemName.toLowerCase().includes('see below')) {
          itemName = itemName + ' (See Below)';
          
          // Check if this new container upgrades an existing one with items
          const upgradeMap = { 'reinforced-backpack': 'backpack' };
          const oldContainerId = upgradeMap[containerId];
          if (oldContainerId && this.containerHasItems(oldContainerId)) {
            this.transferContainerItems(oldContainerId, containerId);
          }
        }
        nameInput.value = itemName;
      }
      
      if (window.EncumbranceData) {
        const itemName = nameInput.value;
        if (itemName.trim() === '') {
          window.EncumbranceData.clearEquipmentEncIfEmpty('equip', rowIndex, itemName);
        } else {
          window.EncumbranceData.autofillEquipmentEnc('equip', rowIndex, itemName);
        }
        this.updateTotalEnc();
        this.updateContainerButtons();
        this.scheduleAutoSave();
      }
      
      // Sync weapon to combat page
      if (nameInput.value.trim()) {
        this.syncEquipmentToCombat(nameInput.value.trim());
      }
    });
    
    nameInput.addEventListener('input', () => {
      this.updateContainerButtons();
      this.scheduleAutoSave();
    });
    
    encInput.addEventListener('input', () => {
      this.updateTotalEnc();
      this.scheduleAutoSave();
    });
    
    row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    nameInput.focus();
    
    this.scheduleAutoSave();
  },

  /**
   * Alphabetize professional skills
   */
  alphabetizeProfessionalSkills() {
    const container = document.getElementById('professional-skills-container');
    if (!container) return;
    const rows = container.querySelectorAll('.professional-skill-row');
    const totalRows = rows.length;
    
    // Gather all professional skills with their data
    const skills = [];
    for (let i = 0; i < totalRows; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      const baseInput = document.getElementById(`prof-skill-${i}-base`);
      const currentInput = document.getElementById(`prof-skill-${i}-current`);
      
      if (nameInput && nameInput.value.trim()) {
        skills.push({
          name: nameInput.value.trim(),
          base: baseInput?.value || '',
          current: currentInput?.value || '',
          originalValue: currentInput?.dataset?.originalValue || ''
        });
      }
    }
    
    // Sort alphabetically
    skills.sort((a, b) => a.name.localeCompare(b.name));
    
    // Suppress duplicate checks during reorder
    this._alphabetizing = true;
    
    // Write ALL values first without triggering events
    for (let i = 0; i < totalRows; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      const baseInput = document.getElementById(`prof-skill-${i}-base`);
      const currentInput = document.getElementById(`prof-skill-${i}-current`);
      
      if (!nameInput) continue;
      
      if (i < skills.length) {
        nameInput.value = skills[i].name;
        nameInput.dataset.previousName = skills[i].name;
        if (baseInput) baseInput.value = skills[i].base;
        if (currentInput) {
          currentInput.value = skills[i].current;
          if (skills[i].originalValue) {
            currentInput.dataset.originalValue = skills[i].originalValue;
          }
        }
      } else {
        nameInput.value = '';
        nameInput.dataset.previousName = '';
        if (baseInput) baseInput.value = '';
        if (currentInput) currentInput.value = '';
      }
    }
    
    // Now trigger recalculations (after all values are in place)
    for (let i = 0; i < totalRows; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      if (!nameInput) continue;
      this.autoFillProfessionalSkillFormula(nameInput, document.getElementById(`prof-skill-${i}-base`));
      this.calculateProfessionalSkillBase(i);
      this.updateProfessionalSkillData(i);
      this.updateProfSkillEncIndicator(i);
    }
    
    this._alphabetizing = false;
    
    this.updatePrereqKeys();
    this.scheduleAutoSave();
  },

  /**
   * Setup EXP spending modal
   */
  setupExpModal() {
    const btn = document.getElementById('btn-spend-exp');
    if (btn) {
      btn.addEventListener('click', () => {
        this.openExpModal();
      });
    }
  },

  /**
   * Open the main EXP spending modal
   */
  openExpModal() {
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    
    // Create modal if it doesn't exist
    let modal = document.getElementById('exp-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'exp-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content exp-modal-content">
          <div class="modal-header">
            <h3>Spend EXP Rolls</h3>
            <button class="modal-close" id="exp-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="exp-rolls-display">
              <span class="exp-rolls-label">Available EXP Rolls:</span>
              <span class="exp-rolls-value" id="exp-modal-rolls">0</span>
            </div>
            <div class="exp-options">
              <button type="button" class="btn exp-option-btn" id="exp-btn-improve-skills">
                <span class="exp-option-icon">📈</span>
                <span class="exp-option-text">Improve Existing Skills</span>
              </button>
              <button type="button" class="btn exp-option-btn" id="exp-btn-unlock-abilities">
                <span class="exp-option-icon">⭐</span>
                <span class="exp-option-text">Unlock Class Abilities</span>
              </button>
              <button type="button" class="btn exp-option-btn" id="exp-btn-learn-skills">
                <span class="exp-option-icon">📚</span>
                <span class="exp-option-text">Learn New Skills</span>
              </button>
              <button type="button" class="btn exp-option-btn" id="exp-btn-passions">
                <span class="exp-option-icon">❤️</span>
                <span class="exp-option-text">Strengthen Passions, Alignment, or Oaths</span>
              </button>
              <button type="button" class="btn exp-option-btn" id="exp-btn-add-subclass">
                <span class="exp-option-icon">🎭</span>
                <span class="exp-option-text">Add New Sub-class</span>
              </button>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button
      document.getElementById('exp-modal-close').addEventListener('click', () => {
        this.closeExpModal();
      });
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeExpModal();
        }
      });
      
      // Escape to close
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
          this.closeExpModal();
        }
      });
      
      // Option buttons
      document.getElementById('exp-btn-improve-skills').addEventListener('click', () => {
        this.openImproveSkillsModal();
      });
      
      document.getElementById('exp-btn-unlock-abilities').addEventListener('click', () => {
        this.openUnlockAbilitiesModal();
      });
      
      document.getElementById('exp-btn-learn-skills').addEventListener('click', () => {
        this.closeExpModal();
        this.openLearnNewSkillsModal();
      });
      
      document.getElementById('exp-btn-passions').addEventListener('click', () => {
        this.openStrengthenPassionsModal();
      });
      
      document.getElementById('exp-btn-add-subclass').addEventListener('click', () => {
        this.openAddSubclassModal();
      });
    }
    
    // Update EXP rolls display
    document.getElementById('exp-modal-rolls').textContent = expRolls;
    
    // Show modal
    modal.classList.remove('hidden');
  },

  /**
   * Close the main EXP modal
   */
  closeExpModal() {
    const modal = document.getElementById('exp-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Open the Improve Existing Skills modal
   */
  openImproveSkillsModal() {
    // Close the main EXP modal
    this.closeExpModal();
    
    // Create modal if it doesn't exist
    let modal = document.getElementById('improve-skills-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'improve-skills-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content improve-skills-modal-content">
          <div class="modal-header">
            <h3>Improve Existing Skills</h3>
            <button class="modal-close" id="improve-skills-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="exp-rolls-display">
              <span class="exp-rolls-label">Available EXP Rolls:</span>
              <span class="exp-rolls-value" id="improve-skills-exp-rolls">0</span>
            </div>
            <p class="improve-skills-instructions">Select skills to attempt improvement (1 EXP Roll each):</p>
            <div class="skills-columns skills-columns-4">
              <div class="skill-column">
                <h4>Standard Skills</h4>
                <div class="skill-list" id="improve-standard-skills"></div>
              </div>
              <div class="skill-column">
                <h4>Professional Skills</h4>
                <div class="skill-list" id="improve-professional-skills"></div>
              </div>
              <div class="skill-column">
                <h4>Combat</h4>
                <div class="skill-list" id="improve-combat-skills"></div>
              </div>
              <div class="skill-column">
                <h4>Magical Skills</h4>
                <div class="skill-list" id="improve-magical-skills"></div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="improve-skills-back">Back</button>
            <button type="button" class="btn btn-secondary" id="improve-skills-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="improve-skills-continue" disabled>Continue</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button
      document.getElementById('improve-skills-modal-close').addEventListener('click', () => {
        this.closeImproveSkillsModal();
      });
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeImproveSkillsModal();
        }
      });
      
      // Escape to close
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
          this.closeImproveSkillsModal();
        }
      });
      
      // Back button
      document.getElementById('improve-skills-back').addEventListener('click', () => {
        this.closeImproveSkillsModal();
        this.openExpModal();
      });
      
      // Cancel button
      document.getElementById('improve-skills-cancel').addEventListener('click', () => {
        this.closeImproveSkillsModal();
      });
      
      // Continue button
      document.getElementById('improve-skills-continue').addEventListener('click', () => {
        this.processSkillImprovement();
      });
    }
    
    // Populate skill lists
    this.populateImprovementSkills();
    
    // Update EXP rolls display
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    document.getElementById('improve-skills-exp-rolls').textContent = expRolls;
    
    // Show modal
    modal.classList.remove('hidden');
  },

  /**
   * Populate the skill lists for improvement
   */
  populateImprovementSkills() {
    const standardContainer = document.getElementById('improve-standard-skills');
    const professionalContainer = document.getElementById('improve-professional-skills');
    const combatContainer = document.getElementById('improve-combat-skills');
    const magicalContainer = document.getElementById('improve-magical-skills');
    
    // Clear existing
    standardContainer.innerHTML = '';
    professionalContainer.innerHTML = '';
    combatContainer.innerHTML = '';
    magicalContainer.innerHTML = '';
    
    // Get class names for prereq checking
    const primaryClass = document.getElementById('class-primary')?.value || '';
    const secondaryClass = document.getElementById('class-secondary')?.value || '';
    const tertiaryClass = document.getElementById('class-tertiary')?.value || '';
    
    // Helper to get prereq class level (1=primary, 2=secondary, 3=tertiary, 0=none)
    const getPrereqLevel = (skillName) => {
      // Use the global isPrereqForClass function from class-ranks-data.js
      if (typeof isPrereqForClass === 'function') {
        if (primaryClass && isPrereqForClass(skillName, primaryClass)) return 1;
        if (secondaryClass && isPrereqForClass(skillName, secondaryClass)) return 2;
        if (tertiaryClass && isPrereqForClass(skillName, tertiaryClass)) return 3;
      }
      return 0;
    };
    
    // Helper to create skill row HTML with prereq coloring
    const createSkillRow = (value, skillName, current, displayName) => {
      const prereqLevel = getPrereqLevel(skillName);
      const prereqClass = prereqLevel > 0 ? `prereq-class-${prereqLevel}` : '';
      return `
        <label class="skill-checkbox-row ${prereqClass}">
          <input type="checkbox" name="improve-skill" value="${value}" data-skill-value="${current}">
          <span class="skill-name">${displayName || skillName}</span>
          <span class="skill-value">${current}%</span>
        </label>
      `;
    };
    
    // Standard Skills (removed home-parallel and unarmed - unarmed goes to Combat)
    const standardSkills = [
      'athletics', 'boating', 'brawn', 'conceal', 'customs', 'dance', 'deceit',
      'drive', 'endurance', 'evade', 'first-aid', 'influence',
      'insight', 'locale', 'perception', 'ride', 'sing', 'stealth', 'swim',
      'willpower'
    ];
    
    const standardLabels = {
      'athletics': 'Athletics', 'boating': 'Boating', 'brawn': 'Brawn', 
      'conceal': 'Conceal', 'customs': 'Customs', 'dance': 'Dance',
      'deceit': 'Deceit', 'drive': 'Drive', 'endurance': 'Endurance',
      'evade': 'Evade', 'first-aid': 'First Aid',
      'influence': 'Influence', 'insight': 'Insight', 'locale': 'Locale',
      'perception': 'Perception', 'ride': 'Ride', 'sing': 'Sing',
      'stealth': 'Stealth', 'swim': 'Swim', 'willpower': 'Willpower'
    };
    
    standardSkills.forEach(skillId => {
      const currentEl = document.getElementById(`${skillId}-current`);
      let current = currentEl?.value || currentEl?.textContent || '0';
      const skillName = standardLabels[skillId] || skillId;
      
      // For Evade, use the value without display bonuses (Artful Dodger, Lightning Reflexes)
      if (skillId === 'evade' && (this.artfulDodgerDisplayed || this.lightningReflexesDisplayed)) {
        current = this.getEvadeWithoutDisplayBonuses().toString();
      }
      
      standardContainer.innerHTML += createSkillRow(`standard:${skillId}`, skillName, current, skillName);
    });
    
    // Professional Skills (from the character sheet) - collect and sort alphabetically
    const profSkills = [];
    for (let i = 0; i < 20; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      const currentInput = document.getElementById(`prof-skill-${i}-current`);
      
      if (nameInput && nameInput.value.trim()) {
        profSkills.push({
          index: i,
          name: nameInput.value.trim(),
          current: currentInput?.value || '0'
        });
      }
    }
    
    // Sort alphabetically
    profSkills.sort((a, b) => a.name.localeCompare(b.name));
    
    profSkills.forEach(skill => {
      professionalContainer.innerHTML += createSkillRow(`prof:${skill.index}`, skill.name, skill.current, skill.name);
    });
    
    // Combat Skills - Combat Skill and Unarmed
    const combatSkillName = document.getElementById('combat-skill-1-name')?.value || 'Combat Skill';
    const combatSkillCurrent = document.getElementById('combat-skill-1-percent')?.value || '0';
    combatContainer.innerHTML += createSkillRow('combat', combatSkillName, combatSkillCurrent, combatSkillName);
    
    // Unarmed
    const unarmedCurrent = document.getElementById('unarmed-percent')?.value || '0';
    combatContainer.innerHTML += createSkillRow('standard:unarmed', 'Unarmed', unarmedCurrent, 'Unarmed');
    
    // Magical Skills - from the spell pages
    const magicalSkillDefs = [
      { id: 'channel-percent', name: 'Channel' },
      { id: 'piety-percent', name: 'Piety' },
      { id: 'arcane-casting-percent', name: 'Arcane Casting' },
      { id: 'arcane-knowledge-percent', name: 'Arcane Knowledge' },
      { id: 'arcane-sorcery-percent', name: 'Arcane Sorcery' },
      { id: 'sorcerous-wisdom-percent', name: 'Sorcerous Wisdom' },
      { id: 'musicianship-percent', name: 'Musicianship' },
      { id: 'lyrical-magic-percent', name: 'Lyrical Magic' }
    ];
    
    magicalSkillDefs.forEach(skill => {
      const el = document.getElementById(skill.id);
      if (el && el.value) {
        const current = el.value || '0';
        magicalContainer.innerHTML += createSkillRow(`magic:${skill.id}`, skill.name, current, skill.name);
      }
    });
    
    // If no magical skills, show message
    if (magicalContainer.innerHTML === '') {
      magicalContainer.innerHTML = '<p class="no-skills-message">No magical skills</p>';
    }
    
    // Add legend if any classes are set
    this.updateSkillsLegend(primaryClass, secondaryClass, tertiaryClass);
    
    // Add change listeners to enable/disable Continue button
    this.updateContinueButton();
    document.querySelectorAll('#improve-skills-modal input[name="improve-skill"]').forEach(cb => {
      cb.addEventListener('change', () => this.updateContinueButton());
    });
  },

  /**
   * Update the prereq skills legend
   */
  updateSkillsLegend(primaryClass, secondaryClass, tertiaryClass) {
    let legendContainer = document.getElementById('skills-prereq-legend');
    if (!legendContainer) {
      // Create legend container after skills-columns
      const skillsColumns = document.querySelector('.skills-columns');
      if (skillsColumns) {
        legendContainer = document.createElement('div');
        legendContainer.id = 'skills-prereq-legend';
        legendContainer.className = 'skills-prereq-legend';
        skillsColumns.parentNode.insertBefore(legendContainer, skillsColumns.nextSibling);
      }
    }
    
    if (!legendContainer) return;
    
    // Build legend HTML
    let legendItems = [];
    if (primaryClass) {
      legendItems.push(`<span class="legend-item"><span class="legend-color prereq-class-1"></span> ${primaryClass} (Primary)</span>`);
    }
    if (secondaryClass) {
      legendItems.push(`<span class="legend-item"><span class="legend-color prereq-class-2"></span> ${secondaryClass} (Secondary)</span>`);
    }
    if (tertiaryClass) {
      legendItems.push(`<span class="legend-item"><span class="legend-color prereq-class-3"></span> ${tertiaryClass} (Tertiary)</span>`);
    }
    
    if (legendItems.length > 0) {
      legendContainer.innerHTML = `<span class="legend-label">Prerequisite Skills:</span> ${legendItems.join('')}`;
      legendContainer.style.display = 'flex';
    } else {
      legendContainer.style.display = 'none';
    }
  },

  /**
   * Update the Continue button state based on selections
   */
  updateContinueButton() {
    const checked = document.querySelectorAll('#improve-skills-modal input[name="improve-skill"]:checked');
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    const continueBtn = document.getElementById('improve-skills-continue');
    
    if (continueBtn) {
      // Enable if at least one skill selected and have enough EXP rolls
      continueBtn.disabled = checked.length === 0 || checked.length > expRolls;
      
      // Update button text to show count
      if (checked.length > 0) {
        continueBtn.textContent = `Continue (${checked.length} skill${checked.length > 1 ? 's' : ''})`;
      } else {
        continueBtn.textContent = 'Continue';
      }
    }
  },

  /**
   * Close the Improve Skills modal
   */
  closeImproveSkillsModal() {
    const modal = document.getElementById('improve-skills-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Open the Strengthen Passions, Alignment, or Oaths modal
   */
  openStrengthenPassionsModal() {
    // Close the main EXP modal
    this.closeExpModal();
    
    // Create modal if it doesn't exist
    let modal = document.getElementById('strengthen-passions-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'strengthen-passions-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content improve-skills-modal-content">
          <div class="modal-header">
            <h3>Strengthen Passions, Alignment, or Oaths</h3>
            <button class="modal-close" id="strengthen-passions-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="exp-rolls-display">
              <span class="exp-rolls-label">Available EXP Rolls:</span>
              <span class="exp-rolls-value" id="strengthen-passions-exp-rolls">0</span>
            </div>
            <p class="improve-skills-instructions">Select items to attempt strengthening (1 EXP Roll each):</p>
            <div class="skills-columns skills-columns-3">
              <div class="skill-column">
                <h4>Alignment</h4>
                <div class="skill-list" id="strengthen-alignment-list"></div>
              </div>
              <div class="skill-column">
                <h4>Passions</h4>
                <div class="skill-list" id="strengthen-passions-list"></div>
              </div>
              <div class="skill-column">
                <h4>Oaths</h4>
                <div class="skill-list" id="strengthen-oaths-list"></div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="strengthen-passions-back">Back</button>
            <button type="button" class="btn btn-secondary" id="strengthen-passions-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="strengthen-passions-continue" disabled>Continue</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button
      document.getElementById('strengthen-passions-modal-close').addEventListener('click', () => {
        this.closeStrengthenPassionsModal();
      });
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeStrengthenPassionsModal();
        }
      });
      
      // Escape to close
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
          this.closeStrengthenPassionsModal();
        }
      });
      
      // Back button
      document.getElementById('strengthen-passions-back').addEventListener('click', () => {
        this.closeStrengthenPassionsModal();
        this.openExpModal();
      });
      
      // Cancel button
      document.getElementById('strengthen-passions-cancel').addEventListener('click', () => {
        this.closeStrengthenPassionsModal();
      });
      
      // Continue button
      document.getElementById('strengthen-passions-continue').addEventListener('click', () => {
        this.processPassionStrengthening();
      });
    }
    
    // Populate the lists
    this.populateStrengthenPassions();
    
    // Update EXP rolls display
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    document.getElementById('strengthen-passions-exp-rolls').textContent = expRolls;
    
    // Show modal
    modal.classList.remove('hidden');
  },

  /**
   * Populate the Passions, Alignment, and Oaths lists for strengthening
   */
  populateStrengthenPassions() {
    const alignmentContainer = document.getElementById('strengthen-alignment-list');
    const passionsContainer = document.getElementById('strengthen-passions-list');
    const oathsContainer = document.getElementById('strengthen-oaths-list');
    
    // Clear existing
    alignmentContainer.innerHTML = '';
    passionsContainer.innerHTML = '';
    oathsContainer.innerHTML = '';
    
    // Helper to create row HTML
    const createRow = (value, name, current) => {
      return `
        <label class="skill-checkbox-row">
          <input type="checkbox" name="strengthen-passion" value="${value}" data-skill-value="${current}">
          <span class="skill-name">${name}</span>
          <span class="skill-value">${current}%</span>
        </label>
      `;
    };
    
    // Alignment (dynamically added, check container)
    const alignmentData = [];
    const alignmentContainerEl = document.getElementById('alignment-container');
    if (alignmentContainerEl) {
      const alignmentRows = alignmentContainerEl.querySelectorAll('.belief-row');
      alignmentRows.forEach((row, idx) => {
        const index = row.dataset.index || (idx + 1);
        const nameInput = document.getElementById(`alignment-${index}-name`);
        const currentInput = document.getElementById(`alignment-${index}-current`);
        
        if (nameInput && nameInput.value.trim()) {
          alignmentData.push({
            index: index,
            name: nameInput.value.trim(),
            current: currentInput?.value || '0'
          });
        }
      });
    }
    
    alignmentData.forEach(alignment => {
      alignmentContainer.innerHTML += createRow(`alignment:${alignment.index}`, alignment.name, alignment.current);
    });
    
    if (alignmentContainer.innerHTML === '') {
      alignmentContainer.innerHTML = '<p class="no-skills-message">No alignments defined</p>';
    }
    
    // Passions (dynamically added, check container)
    const passionsData = [];
    const passionsContainerEl = document.getElementById('passions-container');
    if (passionsContainerEl) {
      const passionRows = passionsContainerEl.querySelectorAll('.belief-row');
      passionRows.forEach((row, idx) => {
        // Use data-index if available, otherwise use loop index + 1
        const index = row.dataset.index || (idx + 1);
        const nameInput = document.getElementById(`passion-${index}-name`);
        const currentInput = document.getElementById(`passion-${index}-current`);
        
        if (nameInput && nameInput.value.trim()) {
          passionsData.push({
            index: index,
            name: nameInput.value.trim(),
            current: currentInput?.value || '0'
          });
        }
      });
    }
    
    // Sort alphabetically
    passionsData.sort((a, b) => a.name.localeCompare(b.name));
    
    passionsData.forEach(passion => {
      passionsContainer.innerHTML += createRow(`passion:${passion.index}`, passion.name, passion.current);
    });
    
    if (passionsContainer.innerHTML === '') {
      passionsContainer.innerHTML = '<p class="no-skills-message">No passions defined</p>';
    }
    
    // Oaths (dynamically added, check container)
    const oathsData = [];
    const oathsContainerEl = document.getElementById('oaths-container');
    if (oathsContainerEl) {
      const oathRows = oathsContainerEl.querySelectorAll('.belief-row');
      oathRows.forEach((row, idx) => {
        // Use data-index if available, otherwise use loop index + 1
        const index = row.dataset.index || (idx + 1);
        const nameInput = document.getElementById(`oath-${index}-name`);
        const currentInput = document.getElementById(`oath-${index}-current`);
        
        if (nameInput && nameInput.value.trim()) {
          oathsData.push({
            index: index,
            name: nameInput.value.trim(),
            current: currentInput?.value || '0'
          });
        }
      });
    }
    
    // Sort alphabetically
    oathsData.sort((a, b) => a.name.localeCompare(b.name));
    
    oathsData.forEach(oath => {
      oathsContainer.innerHTML += createRow(`oath:${oath.index}`, oath.name, oath.current);
    });
    
    if (oathsContainer.innerHTML === '') {
      oathsContainer.innerHTML = '<p class="no-skills-message">No oaths defined</p>';
    }
    
    // Add change listeners to enable/disable Continue button
    this.updateStrengthenContinueButton();
    document.querySelectorAll('#strengthen-passions-modal input[name="strengthen-passion"]').forEach(cb => {
      cb.addEventListener('change', () => this.updateStrengthenContinueButton());
    });
  },

  /**
   * Update the Continue button state for Strengthen Passions modal
   */
  updateStrengthenContinueButton() {
    const checked = document.querySelectorAll('#strengthen-passions-modal input[name="strengthen-passion"]:checked');
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    const continueBtn = document.getElementById('strengthen-passions-continue');
    
    if (continueBtn) {
      continueBtn.disabled = checked.length === 0 || checked.length > expRolls;
      
      // Update button text to show count
      if (checked.length > expRolls) {
        continueBtn.textContent = `Not enough EXP (${checked.length} selected, ${expRolls} available)`;
      } else if (checked.length > 0) {
        continueBtn.textContent = `Continue (${checked.length} selected)`;
      } else {
        continueBtn.textContent = 'Continue';
      }
    }
  },

  /**
   * Close the Strengthen Passions modal
   */
  closeStrengthenPassionsModal() {
    const modal = document.getElementById('strengthen-passions-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Open the Add New Sub-class modal
   */
  openAddSubclassModal() {
    // Close the main EXP modal
    this.closeExpModal();
    
    // Get current class info
    const primaryClass = document.getElementById('class-primary')?.value?.trim() || '';
    const secondaryClass = document.getElementById('class-secondary')?.value?.trim() || '';
    const tertiaryClass = document.getElementById('class-tertiary')?.value?.trim() || '';
    const primaryRank = parseInt(document.getElementById('rank-primary')?.value, 10) || 0;
    const species = document.getElementById('species')?.value?.trim().toLowerCase() || '';
    const isSyrin = species === 'syrin';
    
    // Check if can add subclass
    const cannotMulticlass = ['anti-paladin', 'berserker', 'cavalier', 'monk', 'paladin'];
    const currentClasses = [primaryClass, secondaryClass, tertiaryClass].filter(c => c).map(c => c.toLowerCase());
    
    // Determine which slot we're filling
    let targetSlot = '';
    if (!secondaryClass) {
      targetSlot = 'secondary';
    } else if (!tertiaryClass) {
      targetSlot = 'tertiary';
    }
    
    // Check restrictions
    let errorMessage = '';
    if (!primaryClass) {
      errorMessage = 'You must have a primary class before adding a sub-class.';
    } else if (currentClasses.length >= 3) {
      errorMessage = 'You already have the maximum of 3 classes.';
    } else if (cannotMulticlass.includes(primaryClass.toLowerCase())) {
      errorMessage = `${primaryClass} cannot multi-class.`;
    } else if (primaryRank < 1) {
      errorMessage = 'You must be at least Rank 1 in your primary class to add a sub-class.';
    }
    
    // Calculate cost
    const expCost = primaryRank;
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    
    // Create modal if it doesn't exist
    let modal = document.getElementById('add-subclass-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'add-subclass-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content add-subclass-modal-content">
          <div class="modal-header">
            <h3>Add New Sub-class</h3>
            <button class="modal-close" id="add-subclass-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="exp-rolls-display">
              <span class="exp-rolls-label">Available EXP Rolls:</span>
              <span class="exp-rolls-value" id="add-subclass-exp-rolls">0</span>
            </div>
            <div class="subclass-cost-display" id="subclass-cost-display">
              <span class="subclass-cost-label">Cost:</span>
              <span class="subclass-cost-value" id="subclass-cost-value">0</span>
              <span class="subclass-cost-note" id="subclass-cost-note"></span>
            </div>
            <div class="subclass-error" id="subclass-error"></div>
            <div class="subclass-selection" id="subclass-selection">
              <label for="subclass-select">Choose a class:</label>
              <select id="subclass-select" class="subclass-select">
                <option value="">-- Select a Class --</option>
              </select>
              <div class="subclass-restriction-note" id="subclass-restriction-note"></div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="add-subclass-back">Back</button>
            <button type="button" class="btn btn-secondary" id="add-subclass-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="add-subclass-confirm" disabled>Add Sub-class</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button
      document.getElementById('add-subclass-modal-close').addEventListener('click', () => {
        this.closeAddSubclassModal();
      });
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeAddSubclassModal();
        }
      });
      
      // Escape to close
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
          this.closeAddSubclassModal();
        }
      });
      
      // Back button
      document.getElementById('add-subclass-back').addEventListener('click', () => {
        this.closeAddSubclassModal();
        this.openExpModal();
      });
      
      // Cancel button
      document.getElementById('add-subclass-cancel').addEventListener('click', () => {
        this.closeAddSubclassModal();
      });
      
      // Select change
      document.getElementById('subclass-select').addEventListener('change', () => {
        this.updateSubclassConfirmButton();
      });
      
      // Confirm button
      document.getElementById('add-subclass-confirm').addEventListener('click', () => {
        this.confirmAddSubclass();
      });
    }
    
    // Update display
    document.getElementById('add-subclass-exp-rolls').textContent = expRolls;
    document.getElementById('subclass-cost-value').textContent = expCost + ' EXP Rolls';
    document.getElementById('subclass-cost-note').textContent = `(Based on Rank ${primaryRank} in ${primaryClass})`;
    
    // Show error or selection
    const errorDiv = document.getElementById('subclass-error');
    const selectionDiv = document.getElementById('subclass-selection');
    const costDisplay = document.getElementById('subclass-cost-display');
    
    if (errorMessage) {
      errorDiv.textContent = errorMessage;
      errorDiv.style.display = 'block';
      selectionDiv.style.display = 'none';
      costDisplay.style.display = 'none';
    } else {
      errorDiv.style.display = 'none';
      selectionDiv.style.display = 'block';
      costDisplay.style.display = 'flex';
      
      // Populate class options
      this.populateSubclassOptions(currentClasses, isSyrin);
    }
    
    // Store target slot and cost for confirm
    modal.dataset.targetSlot = targetSlot;
    modal.dataset.expCost = expCost;
    
    // Update confirm button state
    this.updateSubclassConfirmButton();
    
    // Show modal
    modal.classList.remove('hidden');
  },

  /**
   * Populate the sub-class dropdown with available classes
   */
  populateSubclassOptions(currentClasses, isSyrin) {
    const select = document.getElementById('subclass-select');
    const restrictionNote = document.getElementById('subclass-restriction-note');
    
    // All available classes
    const allClasses = [
      'Anti-Paladin', 'Bard', 'Berserker', 'Cavalier', 'Cleric', 'Druid',
      'Fighter', 'Mage', 'Monk', 'Paladin', 'Ranger', 'Rogue', 'Sorcerer', 'Warlord'
    ];
    
    // Classes that cannot multi-class at all
    const cannotMulticlass = ['anti-paladin', 'berserker', 'cavalier', 'monk', 'paladin'];
    
    // Incompatible pairs
    const incompatibilities = {
      'cleric': ['druid'],
      'druid': ['cleric'],
      'ranger': ['fighter'],
      'fighter': ['ranger'],
      'sorcerer': ['bard', 'mage'],
      'bard': ['sorcerer'],
      'mage': ['sorcerer']
    };
    
    // Build list of incompatible classes based on current classes
    const incompatibleClasses = new Set();
    currentClasses.forEach(cls => {
      const clsLower = cls.toLowerCase();
      if (incompatibilities[clsLower]) {
        incompatibilities[clsLower].forEach(inc => incompatibleClasses.add(inc));
      }
    });
    
    // Clear and rebuild options
    select.innerHTML = '<option value="">-- Select a Class --</option>';
    
    const restrictions = [];
    
    allClasses.forEach(cls => {
      const clsLower = cls.toLowerCase();
      
      // Skip if already has this class
      if (currentClasses.includes(clsLower)) return;
      
      // Skip if cannot multi-class
      if (cannotMulticlass.includes(clsLower)) {
        restrictions.push(`${cls} cannot multi-class`);
        return;
      }
      
      // Skip if Syrin and Mage/Sorcerer
      if (isSyrin && (clsLower === 'mage' || clsLower === 'sorcerer')) {
        restrictions.push(`Syrin cannot be ${cls}`);
        return;
      }
      
      // Skip if incompatible with current classes
      if (incompatibleClasses.has(clsLower)) {
        const conflictWith = currentClasses.find(c => {
          const incs = incompatibilities[c.toLowerCase()];
          return incs && incs.includes(clsLower);
        });
        restrictions.push(`${cls} incompatible with ${conflictWith}`);
        return;
      }
      
      // Add option
      const option = document.createElement('option');
      option.value = cls;
      option.textContent = cls;
      select.appendChild(option);
    });
    
    // Show restrictions note if any
    if (restrictions.length > 0) {
      restrictionNote.innerHTML = '<strong>Unavailable:</strong> ' + restrictions.join('; ');
      restrictionNote.style.display = 'block';
    } else {
      restrictionNote.style.display = 'none';
    }
  },

  /**
   * Update the confirm button state for Add Sub-class
   */
  updateSubclassConfirmButton() {
    const select = document.getElementById('subclass-select');
    const confirmBtn = document.getElementById('add-subclass-confirm');
    const modal = document.getElementById('add-subclass-modal');
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    const expCost = parseInt(modal?.dataset.expCost, 10) || 0;
    
    const selectedClass = select?.value || '';
    const canAfford = expRolls >= expCost;
    
    if (confirmBtn) {
      confirmBtn.disabled = !selectedClass || !canAfford;
      
      if (!canAfford && selectedClass) {
        confirmBtn.textContent = `Not enough EXP (need ${expCost})`;
      } else if (selectedClass) {
        confirmBtn.textContent = `Add ${selectedClass} (${expCost} EXP)`;
      } else {
        confirmBtn.textContent = 'Add Sub-class';
      }
    }
  },

  /**
   * Close the Add Sub-class modal
   */
  closeAddSubclassModal() {
    const modal = document.getElementById('add-subclass-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Confirm adding the sub-class
   */
  confirmAddSubclass() {
    const modal = document.getElementById('add-subclass-modal');
    const select = document.getElementById('subclass-select');
    const selectedClass = select?.value || '';
    const targetSlot = modal?.dataset.targetSlot || '';
    const expCost = parseInt(modal?.dataset.expCost, 10) || 0;
    
    if (!selectedClass || !targetSlot) return;
    
    // Set the new class
    const classInput = document.getElementById(`class-${targetSlot}`);
    const rankInput = document.getElementById(`rank-${targetSlot}`);
    
    if (classInput) {
      classInput.value = selectedClass;
      classInput.dispatchEvent(new Event('input', { bubbles: true }));
      classInput.dispatchEvent(new Event('change', { bubbles: true }));
    }
    
    if (rankInput) {
      rankInput.value = 0;
      rankInput.dispatchEvent(new Event('input', { bubbles: true }));
      rankInput.dispatchEvent(new Event('change', { bubbles: true }));
    }
    
    // Deduct EXP rolls
    const expRollsInput = document.getElementById('exp-rolls');
    if (expRollsInput) {
      const currentExp = parseInt(expRollsInput.value, 10) || 0;
      expRollsInput.value = Math.max(0, currentExp - expCost);
      expRollsInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    // Trigger recalculations
    this.recalculateAll();
    this.updateMagicVisibility();
    this.updatePrereqKeys();
    
    // Close modal and show success
    this.closeAddSubclassModal();
    
    // Show confirmation message
    alert(`Added ${selectedClass} as your ${targetSlot === 'secondary' ? '2nd' : '3rd'} class at Rank 0!\n\nSpent ${expCost} EXP Rolls.`);
    
    // Auto-save
    this.scheduleAutoSave();
  },

  /**
   * Open the Unlock Class Abilities modal
   */
  openUnlockAbilitiesModal() {
    // Close the main EXP modal
    this.closeExpModal();
    
    // Get character's classes and ranks
    const classes = this.getCharacterClasses();
    
    if (classes.length === 0) {
      alert('You must have at least one class to unlock abilities.');
      return;
    }
    
    // Create modal if it doesn't exist
    let modal = document.getElementById('unlock-abilities-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'unlock-abilities-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content unlock-abilities-modal-content">
          <div class="modal-header">
            <h3>Unlock Class Abilities</h3>
            <button class="modal-close" id="unlock-abilities-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="exp-rolls-display">
              <span class="exp-rolls-label">Available EXP Rolls:</span>
              <span class="exp-rolls-value" id="unlock-abilities-exp-rolls">0</span>
            </div>
            <div class="pending-automatic-section" id="pending-automatic-section" style="display: none;">
              <h4>⏳ Pending Automatic Abilities</h4>
              <p class="pending-automatic-subtitle">These abilities are granted automatically when you meet the prerequisites</p>
              <div class="pending-automatic-list" id="pending-automatic-list"></div>
            </div>
            <div class="class-tabs" id="unlock-abilities-class-tabs"></div>
            <div class="rank-tabs" id="unlock-abilities-rank-tabs"></div>
            <div class="abilities-container" id="unlock-abilities-container">
              <div class="abilities-section available-abilities">
                <h4>Available Abilities</h4>
                <div class="abilities-list" id="available-abilities-list"></div>
              </div>
              <hr class="abilities-divider unqualified-divider">
              <div class="abilities-section unqualified-abilities">
                <h4>Not Yet Qualified</h4>
                <div class="abilities-list" id="unqualified-abilities-list"></div>
              </div>
              <hr class="abilities-divider acquired-divider">
              <div class="abilities-section acquired-abilities">
                <h4>Already Acquired</h4>
                <div class="abilities-list" id="acquired-abilities-list"></div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="unlock-abilities-back">Back</button>
            <button type="button" class="btn btn-secondary" id="unlock-abilities-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="unlock-abilities-confirm" disabled>Unlock Selected</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close button
      document.getElementById('unlock-abilities-modal-close').addEventListener('click', () => {
        this.closeUnlockAbilitiesModal();
      });
      
      // Click outside to close
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeUnlockAbilitiesModal();
        }
      });
      
      // Escape to close
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
          this.closeUnlockAbilitiesModal();
        }
      });
      
      // Back button
      document.getElementById('unlock-abilities-back').addEventListener('click', () => {
        this.closeUnlockAbilitiesModal();
        this.openExpModal();
      });
      
      // Cancel button
      document.getElementById('unlock-abilities-cancel').addEventListener('click', () => {
        this.closeUnlockAbilitiesModal();
      });
      
      // Confirm button
      document.getElementById('unlock-abilities-confirm').addEventListener('click', () => {
        this.confirmUnlockAbilities();
      });
    }
    
    // Store classes info on modal
    modal.dataset.classes = JSON.stringify(classes);
    
    // Update EXP rolls display
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    document.getElementById('unlock-abilities-exp-rolls').textContent = expRolls;
    
    // Build class tabs
    this.buildClassTabs(classes);
    
    // Populate pending automatic abilities
    this.populatePendingAutomaticAbilities(classes);
    
    // Select first class by default
    if (classes.length > 0) {
      this.selectClassTab(classes[0].name, classes[0].rank);
    }
    
    // Show modal
    modal.classList.remove('hidden');
  },

  /**
   * Get character's classes and ranks
   */
  getCharacterClasses() {
    const classes = [];
    
    const primary = document.getElementById('class-primary')?.value?.trim();
    const primaryRank = parseInt(document.getElementById('rank-primary')?.value, 10) || 0;
    if (primary) {
      classes.push({ name: primary, rank: primaryRank, slot: 'primary' });
    }
    
    const secondary = document.getElementById('class-secondary')?.value?.trim();
    const secondaryRank = parseInt(document.getElementById('rank-secondary')?.value, 10) || 0;
    if (secondary) {
      classes.push({ name: secondary, rank: secondaryRank, slot: 'secondary' });
    }
    
    const tertiary = document.getElementById('class-tertiary')?.value?.trim();
    const tertiaryRank = parseInt(document.getElementById('rank-tertiary')?.value, 10) || 0;
    if (tertiary) {
      classes.push({ name: tertiary, rank: tertiaryRank, slot: 'tertiary' });
    }
    
    return classes;
  },

  /**
   * Automatic abilities data - abilities granted for free at certain ranks if prereqs met
   */
  AUTOMATIC_ABILITIES: {
    cavalier: [
      {
        name: 'Exotic Mounts I (Unicorn)',
        rank: 2,
        prereqs: [
          { type: 'species-not', value: 'half-orc', label: 'Species is not Half-orc' },
          { type: 'skill', name: 'Ride', value: 60 },
          { type: 'skill-gender', name: 'Oath', male: 80, female: 60 }
        ]
      },
      {
        name: 'Exotic Mounts II (Pegasus)',
        rank: 3,
        prereqs: [
          { type: 'skill', name: 'Ride', value: 90 },
          { type: 'skill', name: 'Oath', value: 90 }
        ]
      },
      {
        name: 'Exotic Mounts III (Hippogriff)',
        rank: 4,
        prereqs: [
          { type: 'skill', name: 'Ride', value: 110 },
          { type: 'skill', name: 'Oath', value: 110 }
        ]
      },
      {
        name: 'Exotic Mounts IV (Griffon)',
        rank: 5,
        prereqs: [
          { type: 'skill', name: 'Ride', value: 130 },
          { type: 'skill', name: 'Oath', value: 130 }
        ]
      }
    ]
    // Add more classes here as needed
  },

  /**
   * Populate the pending automatic abilities section
   */
  populatePendingAutomaticAbilities(classes) {
    const section = document.getElementById('pending-automatic-section');
    const list = document.getElementById('pending-automatic-list');
    list.innerHTML = '';
    
    const pendingAbilities = [];
    const existingAbilities = this.getAllSpecialAbilities().map(a => a.toLowerCase().trim());
    
    classes.forEach(cls => {
      const classKey = cls.name.toLowerCase().trim();
      const autoAbilities = this.AUTOMATIC_ABILITIES[classKey];
      if (!autoAbilities) return;
      
      autoAbilities.forEach(ability => {
        // Check if character has reached the required rank
        if (cls.rank < ability.rank) return;
        
        // Check if already has this ability
        const hasAbility = existingAbilities.some(a => 
          a === ability.name.toLowerCase() ||
          a.startsWith(ability.name.toLowerCase().split('(')[0].trim())
        );
        if (hasAbility) return;
        
        // Check prerequisites and collect missing ones
        const missingPrereqs = this.checkAutomaticAbilityPrereqs(ability.prereqs);
        
        // Only show if there are missing prereqs (otherwise they would have gotten it)
        if (missingPrereqs.length > 0) {
          pendingAbilities.push({
            name: ability.name,
            className: cls.name,
            rank: ability.rank,
            missing: missingPrereqs
          });
        }
      });
    });
    
    if (pendingAbilities.length === 0) {
      section.style.display = 'none';
      return;
    }
    
    section.style.display = 'block';
    
    pendingAbilities.forEach(ability => {
      const row = document.createElement('div');
      row.className = 'pending-automatic-item';
      
      let missingHtml = ability.missing.map(m => 
        `<span class="prereq-missing">❌ ${m}</span>`
      ).join('');
      
      row.innerHTML = `
        <div class="pending-automatic-name">
          <strong>${ability.name}</strong>
          <span class="pending-class-badge">${ability.className} Rank ${ability.rank}</span>
        </div>
        <div class="pending-automatic-prereqs">
          ${missingHtml}
        </div>
      `;
      
      list.appendChild(row);
    });
  },

  /**
   * Check prerequisites for automatic abilities
   * Returns array of missing prereq descriptions
   */
  checkAutomaticAbilityPrereqs(prereqs) {
    const missing = [];
    const species = (document.getElementById('species')?.value || '').toLowerCase().trim();
    const gender = (document.getElementById('gender')?.value || '').toLowerCase().trim();
    
    prereqs.forEach(prereq => {
      switch (prereq.type) {
        case 'species-not':
          const speciesVariants = [prereq.value, prereq.value.replace('-', ''), prereq.value.replace('-', ' ')];
          if (speciesVariants.includes(species)) {
            missing.push(prereq.label);
          }
          break;
          
        case 'skill':
          const skillValue = this.getSkillValueByName(prereq.name);
          if (skillValue < prereq.value) {
            missing.push(`${prereq.name} ${prereq.value}% (currently ${skillValue}%)`);
          }
          break;
          
        case 'skill-gender':
          const genderSkillValue = this.getSkillValueByName(prereq.name);
          let required = prereq.male; // default to male requirement
          if (gender === 'female' || gender === 'f') {
            required = prereq.female;
          }
          if (genderSkillValue < required) {
            const genderLabel = (gender === 'female' || gender === 'f') ? 'female' : 'male';
            missing.push(`${prereq.name} ${required}% for ${genderLabel} (currently ${genderSkillValue}%)`);
          }
          break;
      }
    });
    
    return missing;
  },

  /**
   * Build class tabs for the unlock abilities modal
   */
  buildClassTabs(classes) {
    const container = document.getElementById('unlock-abilities-class-tabs');
    container.innerHTML = '';
    
    classes.forEach((cls, index) => {
      const tab = document.createElement('button');
      tab.type = 'button';
      tab.className = 'class-tab' + (index === 0 ? ' active' : '');
      tab.dataset.className = cls.name;
      tab.dataset.classRank = cls.rank;
      tab.innerHTML = `${cls.name} <span class="rank-badge">Rank ${cls.rank}</span>`;
      tab.addEventListener('click', () => {
        this.selectClassTab(cls.name, cls.rank);
      });
      container.appendChild(tab);
    });
  },

  /**
   * Select a class tab and populate rank tabs
   */
  selectClassTab(className, classRank) {
    // Update active class tab
    document.querySelectorAll('.class-tab').forEach(tab => {
      tab.classList.toggle('active', tab.dataset.className === className);
    });
    
    // Store selected class
    const modal = document.getElementById('unlock-abilities-modal');
    modal.dataset.selectedClass = className;
    modal.dataset.selectedClassRank = classRank;
    
    // Build rank tabs (1 through current rank - Rank 0 has no abilities)
    this.buildRankTabs(classRank);
    
    // Find the lowest rank where the character hasn't taken all abilities
    const selectedRank = this.findLowestIncompleteRank(className, classRank);
    if (classRank >= 1) {
      this.selectRankTab(selectedRank);
    }
  },

  /**
   * Find the lowest rank where the character hasn't acquired all available abilities
   */
  findLowestIncompleteRank(className, maxRank) {
    if (maxRank < 1) return 1;
    
    const acquiredAbilities = this.getAcquiredAbilities();
    const charIncreases = this.character.characteristicIncreases || [];
    const getSkillValue = (skillName) => this.getSkillValueByName(skillName);
    
    for (let rank = 1; rank <= maxRank; rank++) {
      const abilities = getRankedAbilitiesForClass(className, rank);
      
      // Check if any abilities at this rank are still available (not acquired and prereqs met)
      for (const ability of abilities) {
        // Special handling for Characteristic Increase
        if (ability.name === 'Characteristic Increase') {
          const charIncreasesAtThisRank = charIncreases.filter(inc => inc.rank === rank);
          if (charIncreasesAtThisRank.length === 0) {
            // Haven't taken Characteristic Increase at this rank
            return rank;
          }
          continue;
        }
        
        // Check if already acquired
        const alreadyHas = hasAbility(ability.name, acquiredAbilities);
        const repeatable = isRepeatableAbility(ability.name);
        
        if (!alreadyHas || repeatable) {
          // Check prerequisites
          const prereqCheck = checkAbilityPrereqs(ability.prereqs, acquiredAbilities, getSkillValue);
          if (prereqCheck.met) {
            // Found an available ability at this rank
            return rank;
          }
        }
      }
    }
    
    // All abilities acquired at all ranks, default to highest rank
    return maxRank;
  },

  /**
   * Build rank tabs for the selected class (starting at Rank 1, since Rank 0 has no abilities)
   */
  buildRankTabs(maxRank) {
    const container = document.getElementById('unlock-abilities-rank-tabs');
    container.innerHTML = '';
    
    // Start at Rank 1 (Rank 0 has no purchasable abilities)
    for (let r = 1; r <= maxRank; r++) {
      const tab = document.createElement('button');
      tab.type = 'button';
      tab.className = 'rank-tab';
      tab.dataset.rank = r;
      tab.textContent = `Rank ${r}`;
      tab.addEventListener('click', () => {
        this.selectRankTab(r);
      });
      container.appendChild(tab);
    }
    
    // If maxRank is 0, show a message
    if (maxRank === 0) {
      container.innerHTML = '<span class="no-ranks-message">Rank 0 has no purchasable abilities</span>';
    }
  },

  /**
   * Select a rank tab and populate abilities
   */
  selectRankTab(rank) {
    // Update active rank tab
    document.querySelectorAll('.rank-tab').forEach(tab => {
      tab.classList.toggle('active', parseInt(tab.dataset.rank, 10) === rank);
    });
    
    const modal = document.getElementById('unlock-abilities-modal');
    modal.dataset.selectedRank = rank;
    
    // Populate abilities for selected class and rank
    const className = modal.dataset.selectedClass;
    this.populateAbilities(className, rank);
  },

  /**
   * Ability upgrade chains - maps lower abilities to their upgrades
   * If user has any upgrade, the base ability is considered "superseded"
   */
  ABILITY_UPGRADE_CHAINS: {
    'mental strength i': ['mental strength ii', 'mental strength iii', 'mental strength iv', 'mental strength v'],
    'mental strength 1': ['mental strength 2', 'mental strength 3', 'mental strength 4', 'mental strength 5'],
    'mental strength ii': ['mental strength iii', 'mental strength iv', 'mental strength v'],
    'mental strength 2': ['mental strength 3', 'mental strength 4', 'mental strength 5'],
    'mental strength iii': ['mental strength iv', 'mental strength v'],
    'mental strength 3': ['mental strength 4', 'mental strength 5'],
    'mental strength iv': ['mental strength v'],
    'mental strength 4': ['mental strength 5'],
    'overrun': ['greater overrun'],
    'sweeping strike': ['greater sweeping strike'],
    'defensive reflexes i': ['defensive reflexes ii', 'defensive reflexes iii', 'defensive reflexes iv', 'defensive reflexes v'],
    'defensive reflexes 1': ['defensive reflexes 2', 'defensive reflexes 3', 'defensive reflexes 4', 'defensive reflexes 5'],
    'defensive reflexes ii': ['defensive reflexes iii', 'defensive reflexes iv', 'defensive reflexes v'],
    'defensive reflexes 2': ['defensive reflexes 3', 'defensive reflexes 4', 'defensive reflexes 5'],
    'defensive reflexes iii': ['defensive reflexes iv', 'defensive reflexes v'],
    'defensive reflexes 3': ['defensive reflexes 4', 'defensive reflexes 5'],
    'defensive reflexes iv': ['defensive reflexes v'],
    'defensive reflexes 4': ['defensive reflexes 5'],
    'holy smite': ['improved holy smite', 'greater holy smite'],
    'improved holy smite': ['greater holy smite'],
  },

  /**
   * Check if an ability has been superseded by a higher version
   * @param {string} abilityName - The ability to check
   * @param {Set} acquiredAbilities - Set of abilities the character has
   * @returns {string|null} - Name of superseding ability, or null if not superseded
   */
  getSupersedingAbility(abilityName, acquiredAbilities) {
    const lowerName = abilityName.toLowerCase().trim();
    const upgrades = this.ABILITY_UPGRADE_CHAINS[lowerName];
    
    if (!upgrades) return null;
    
    // Check if any upgrade exists in acquired abilities
    for (const upgrade of upgrades) {
      // Check exact match
      if (acquiredAbilities.has(upgrade)) {
        return this.toTitleCase(upgrade);
      }
      // Check with variations (roman vs arabic numerals handled by the chain itself)
      for (const acquired of acquiredAbilities) {
        if (acquired.toLowerCase() === upgrade) {
          return this.toTitleCase(acquired);
        }
      }
    }
    
    return null;
  },

  /**
   * Populate abilities list for a class and rank
   */
  populateAbilities(className, rank) {
    const availableList = document.getElementById('available-abilities-list');
    const unqualifiedList = document.getElementById('unqualified-abilities-list');
    const acquiredList = document.getElementById('acquired-abilities-list');
    
    availableList.innerHTML = '';
    unqualifiedList.innerHTML = '';
    acquiredList.innerHTML = '';
    
    // Get abilities for this class at this rank
    const abilities = getRankedAbilitiesForClass(className, rank);
    
    if (abilities.length === 0) {
      availableList.innerHTML = '<p class="no-abilities">No abilities available at this rank for this class.</p>';
      document.querySelector('.unqualified-divider').style.display = 'none';
      document.querySelector('.unqualified-abilities').style.display = 'none';
      document.querySelector('.acquired-divider').style.display = 'none';
      document.querySelector('.acquired-abilities').style.display = 'none';
      return;
    }
    
    // Get acquired abilities
    const acquiredAbilities = this.getAcquiredAbilities();
    
    // Get characteristic increases for this character
    const charIncreases = this.character.characteristicIncreases || [];
    const charIncreasesAtThisRank = charIncreases.filter(inc => inc.rank === rank);
    
    // Helper to get skill value
    const getSkillValue = (skillName) => this.getSkillValueByName(skillName);
    
    // Sort abilities into categories
    const available = [];      // Can select
    const acquired = [];       // Already have (shown at bottom)
    const unqualified = [];    // Missing prereqs
    
    abilities.forEach(ability => {
      // Special handling for Characteristic Increase - once per rank
      if (ability.name === 'Characteristic Increase') {
        if (charIncreasesAtThisRank.length > 0) {
          // Already took it at this rank
          const charTaken = charIncreasesAtThisRank[0].char.toUpperCase();
          acquired.push({ ...ability, acquired: true, acquiredNote: `+1 ${charTaken}` });
        } else {
          // Available to take at this rank
          available.push({ ...ability, acquired: false });
        }
        return;
      }
      
      // Check if already acquired (using base name matching)
      const alreadyHas = hasAbility(ability.name, acquiredAbilities);
      
      // Check if this ability has been superseded by a higher version
      const supersededBy = this.getSupersedingAbility(ability.name, acquiredAbilities);
      
      // Check if this is a repeatable ability (can take multiple times)
      const repeatable = isRepeatableAbility(ability.name);
      
      if (alreadyHas && !repeatable) {
        // Show as acquired (greyed out) - goes to bottom section
        acquired.push({ ...ability, acquired: true });
        return;
      }
      
      if (supersededBy) {
        // Show as acquired because a higher version exists
        acquired.push({ ...ability, acquired: true, acquiredNote: `(have ${supersededBy})` });
        return;
      }
      
      // Check prerequisites
      const prereqCheck = checkAbilityPrereqs(ability.prereqs, acquiredAbilities, getSkillValue);
      
      if (prereqCheck.met) {
        available.push({ ...ability, acquired: false, repeatable });
      } else {
        unqualified.push({ ...ability, missing: prereqCheck.missing });
      }
    });
    
    // Render available abilities
    if (available.length === 0) {
      availableList.innerHTML = '<p class="no-abilities">No abilities available to unlock at this rank.</p>';
    } else {
      available.forEach(ability => {
        availableList.appendChild(this.createAbilityRow(ability, rank));
      });
    }
    
    // Render unqualified abilities
    if (unqualified.length > 0) {
      document.querySelector('.unqualified-divider').style.display = '';
      document.querySelector('.unqualified-abilities').style.display = '';
      unqualified.forEach(ability => {
        unqualifiedList.appendChild(this.createAbilityRow(ability, rank, true));
      });
    } else {
      document.querySelector('.unqualified-divider').style.display = 'none';
      document.querySelector('.unqualified-abilities').style.display = 'none';
    }
    
    // Render acquired abilities (at the bottom)
    if (acquired.length > 0) {
      document.querySelector('.acquired-divider').style.display = '';
      document.querySelector('.acquired-abilities').style.display = '';
      acquired.forEach(ability => {
        acquiredList.appendChild(this.createAbilityRow(ability, rank));
      });
    } else {
      document.querySelector('.acquired-divider').style.display = 'none';
      document.querySelector('.acquired-abilities').style.display = 'none';
    }
    
    // Update confirm button
    this.updateUnlockConfirmButton();
  },

  /**
   * Create an ability row element
   */
  createAbilityRow(ability, rank, disabled = false) {
    const row = document.createElement('label');
    row.className = 'ability-row' + (ability.acquired ? ' acquired' : '') + (disabled ? ' disabled' : '');
    
    const cost = rank; // EXP cost = rank
    
    let html = `
      <input type="checkbox" name="unlock-ability" value="${ability.name}" 
        data-cost="${cost}" ${ability.acquired || disabled ? 'disabled' : ''}>
      <div class="ability-info">
        <div class="ability-header">
          <span class="ability-name">${ability.name}</span>
          <span class="ability-cost">${cost} EXP</span>
        </div>
        <div class="ability-summary">${ability.summary}</div>
    `;
    
    if (ability.acquired) {
      const acquiredText = ability.acquiredNote 
        ? `✓ Already Acquired (${ability.acquiredNote})`
        : '✓ Already Acquired';
      html += `<div class="ability-status acquired">${acquiredText}</div>`;
    } else if (ability.missing && ability.missing.length > 0) {
      html += `<div class="ability-status missing">⚠ Requires: ${ability.missing.join(', ')}</div>`;
    }
    
    html += `</div>`;
    row.innerHTML = html;
    
    // Add change listener
    const checkbox = row.querySelector('input');
    if (checkbox && !checkbox.disabled) {
      checkbox.addEventListener('change', () => this.updateUnlockConfirmButton());
    }
    
    return row;
  },

  /**
   * Get set of acquired abilities
   */
  getAcquiredAbilities() {
    // Start with tracked acquired abilities
    const abilities = new Set(this.character.acquiredAbilities || []);
    
    // Also include abilities already on the sheet (manually added or from auto-grant)
    const container = document.getElementById('class-abilities-list');
    if (container) {
      const inputs = container.querySelectorAll('.class-ability-input');
      inputs.forEach(input => {
        if (input.value.trim()) {
          abilities.add(input.value.trim());
        }
      });
    }
    
    // Also check Languages section for Language abilities (e.g., Druids' Cant, Thieves' Cant)
    // Check native tongue
    const nativeName = document.getElementById('native-tongue-name')?.value?.trim();
    if (nativeName) {
      abilities.add(`Language (${nativeName})`);
    }
    // Check additional languages
    const langContainer = document.getElementById('language-container');
    if (langContainer) {
      const langRows = langContainer.querySelectorAll('.language-row:not(.native)');
      langRows.forEach(row => {
        const langName = row.querySelector('.language-name')?.value?.trim();
        if (langName) {
          abilities.add(`Language (${langName})`);
        }
      });
    }
    
    return abilities;
  },

  /**
   * Get skill value by name (for prereq checking)
   */
  getSkillValueByName(skillName) {
    const normalized = skillName.toLowerCase().trim();
    
    // Map common names to element IDs
    const skillMappings = {
      'evade': 'evade-current',
      'acrobatics': 'prof-skill-acrobatics', // Professional skill
      'athletics': 'athletics-current',
      'willpower': 'willpower-current',
      'musicianship': 'musicianship-percent',
      'combat style': 'combat-skill-1-percent',
      'combat skill': 'combat-skill-1-percent',
      'unarmed': 'unarmed-percent',
    };
    
    // Try direct mapping first
    if (skillMappings[normalized]) {
      const el = document.getElementById(skillMappings[normalized]);
      if (el) return parseInt(el.value, 10) || 0;
    }
    
    // Try standard skills
    const standardId = `${normalized.replace(/\s+/g, '-')}-current`;
    const standardEl = document.getElementById(standardId);
    if (standardEl) return parseInt(standardEl.value, 10) || 0;
    
    // Try professional skills
    for (let i = 0; i < PROFESSIONAL_SKILL_SLOTS; i++) {
      const nameEl = document.getElementById(`prof-skill-${i}-name`);
      const valueEl = document.getElementById(`prof-skill-${i}-current`);
      if (nameEl && nameEl.value.toLowerCase().trim() === normalized) {
        return parseInt(valueEl?.value, 10) || 0;
      }
    }
    
    // Try magic skills
    const magicMappings = {
      'musicianship': 'musicianship-percent',
      'channel': 'channel-percent',
      'piety': 'piety-percent',
      'arcane casting': 'arcane-casting-percent',
      'arcane knowledge': 'arcane-knowledge-percent',
      'arcane sorcery': 'arcane-sorcery-percent',
    };
    if (magicMappings[normalized]) {
      const el = document.getElementById(magicMappings[normalized]);
      if (el) return parseInt(el.value, 10) || 0;
    }
    
    // Check Oaths (any entry in the Oaths container)
    if (normalized === 'oath') {
      const oathsContainer = document.getElementById('oaths-container');
      if (oathsContainer) {
        let highestOath = 0;
        const oathRows = oathsContainer.querySelectorAll('.belief-row');
        oathRows.forEach(row => {
          const nameEl = row.querySelector('.belief-name');
          const valueEl = row.querySelector('.belief-input');
          const oathName = (nameEl?.value || '').toLowerCase().trim();
          if (oathName) {
            const value = parseInt(valueEl?.value, 10) || 0;
            if (value > highestOath) highestOath = value;
          }
        });
        return highestOath;
      }
    }
    
    // Check Passions (return highest passion value)
    if (normalized === 'passion') {
      const passionsContainer = document.getElementById('passions-container');
      if (passionsContainer) {
        let highestPassion = 0;
        const passionRows = passionsContainer.querySelectorAll('.belief-row');
        passionRows.forEach(row => {
          const valueEl = row.querySelector('.belief-input');
          const value = parseInt(valueEl?.value, 10) || 0;
          if (value > highestPassion) highestPassion = value;
        });
        return highestPassion;
      }
    }
    
    return 0;
  },

  /**
   * Update the unlock confirm button state
   */
  updateUnlockConfirmButton() {
    const checked = document.querySelectorAll('#unlock-abilities-modal input[name="unlock-ability"]:checked');
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    const confirmBtn = document.getElementById('unlock-abilities-confirm');
    
    let totalCost = 0;
    checked.forEach(cb => {
      totalCost += parseInt(cb.dataset.cost, 10) || 0;
    });
    
    const canAfford = expRolls >= totalCost;
    
    if (confirmBtn) {
      confirmBtn.disabled = checked.length === 0 || !canAfford;
      
      if (checked.length === 0) {
        confirmBtn.textContent = 'Unlock Selected';
      } else if (!canAfford) {
        confirmBtn.textContent = `Not enough EXP (need ${totalCost}, have ${expRolls})`;
      } else {
        confirmBtn.textContent = `Unlock ${checked.length} Ability${checked.length > 1 ? 'ies' : ''} (${totalCost} EXP)`;
      }
    }
  },

  /**
   * Close the unlock abilities modal
   */
  closeUnlockAbilitiesModal() {
    const modal = document.getElementById('unlock-abilities-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
  },

  /**
   * Confirm unlocking selected abilities
   */
  confirmUnlockAbilities() {
    const modal = document.getElementById('unlock-abilities-modal');
    const checked = document.querySelectorAll('#unlock-abilities-modal input[name="unlock-ability"]:checked');
    if (checked.length === 0) return;
    
    // Get the current class context
    const currentClass = modal?.dataset?.selectedClass || '';
    
    let totalCost = 0;
    const newAbilities = [];
    let characteristicIncreaseRank = null;
    
    checked.forEach(cb => {
      const cost = parseInt(cb.dataset.cost, 10) || 0;
      totalCost += cost;
      const abilityName = cb.value;
      
      // Check for Characteristic Increase - needs special handling
      if (abilityName === 'Characteristic Increase') {
        characteristicIncreaseRank = cost; // The rank is the cost
      } else {
        newAbilities.push(abilityName);
      }
    });
    
    // If Characteristic Increase was selected, show the selection modal
    if (characteristicIncreaseRank !== null) {
      // Store the other abilities and cost for after characteristic selection
      this.pendingAbilityUnlock = {
        abilities: newAbilities,
        totalCost: totalCost,
        characteristicRank: characteristicIncreaseRank,
        sourceClass: currentClass
      };
      this.closeUnlockAbilitiesModal();
      this.showCharacteristicIncreaseModal(characteristicIncreaseRank);
      return;
    }
    
    // No Characteristic Increase - proceed normally
    this.finalizeAbilityUnlock(newAbilities, totalCost, currentClass);
  },

  /**
   * Show the characteristic selection modal for Characteristic Increase ability
   */
  showCharacteristicIncreaseModal(rank) {
    let modal = document.getElementById('characteristic-increase-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'characteristic-increase-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content characteristic-increase-modal-content">
          <div class="modal-header">
            <h3>Characteristic Increase</h3>
            <button class="modal-close" id="char-increase-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <p class="char-increase-instructions">Choose a Characteristic to increase by +1:</p>
            <div class="char-increase-options">
              <label class="char-option"><input type="radio" name="char-increase" value="STR"><span class="char-label">STR</span><span class="char-current" id="char-inc-str-val"></span></label>
              <label class="char-option"><input type="radio" name="char-increase" value="CON"><span class="char-label">CON</span><span class="char-current" id="char-inc-con-val"></span></label>
              <label class="char-option"><input type="radio" name="char-increase" value="SIZ"><span class="char-label">SIZ</span><span class="char-current" id="char-inc-siz-val"></span></label>
              <label class="char-option"><input type="radio" name="char-increase" value="DEX"><span class="char-label">DEX</span><span class="char-current" id="char-inc-dex-val"></span></label>
              <label class="char-option"><input type="radio" name="char-increase" value="INT"><span class="char-label">INT</span><span class="char-current" id="char-inc-int-val"></span></label>
              <label class="char-option"><input type="radio" name="char-increase" value="POW"><span class="char-label">POW</span><span class="char-current" id="char-inc-pow-val"></span></label>
              <label class="char-option"><input type="radio" name="char-increase" value="CHA"><span class="char-label">CHA</span><span class="char-current" id="char-inc-cha-val"></span></label>
            </div>
            <p class="char-increase-note">Note: Cannot exceed racial maximum.</p>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="char-increase-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="char-increase-confirm" disabled>Confirm</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close handlers
      document.getElementById('char-increase-modal-close').addEventListener('click', () => {
        this.closeCharacteristicIncreaseModal();
      });
      
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.closeCharacteristicIncreaseModal();
        }
      });
      
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
          this.closeCharacteristicIncreaseModal();
        }
      });
      
      // Cancel button
      document.getElementById('char-increase-cancel').addEventListener('click', () => {
        this.closeCharacteristicIncreaseModal();
      });
      
      // Radio button change
      modal.querySelectorAll('input[name="char-increase"]').forEach(radio => {
        radio.addEventListener('change', () => {
          document.getElementById('char-increase-confirm').disabled = false;
        });
      });
      
      // Confirm button
      document.getElementById('char-increase-confirm').addEventListener('click', () => {
        this.confirmCharacteristicIncrease();
      });
    }
    
    // Get species for characteristic maximums
    const speciesName = document.getElementById('species')?.value || '';
    const charMaxes = SpeciesData.getAllCharacteristicMaxes(speciesName);
    
    // Update current values display and check maximums
    const chars = ['str', 'con', 'siz', 'dex', 'int', 'pow', 'cha'];
    let anyAvailable = false;
    
    chars.forEach(char => {
      const charUpper = char.toUpperCase();
      const input = document.getElementById(`${char}-value`);
      const display = document.getElementById(`char-inc-${char}-val`);
      const radio = modal.querySelector(`input[name="char-increase"][value="${charUpper}"]`);
      const label = radio?.closest('.char-option');
      
      if (input && display) {
        const currentVal = parseInt(input.value, 10) || 0;
        const maxVal = charMaxes ? charMaxes[charUpper] : null;
        
        if (maxVal && currentVal >= maxVal) {
          // At maximum - disable and show note
          display.textContent = `(${currentVal}) MAX`;
          if (radio) {
            radio.disabled = true;
          }
          if (label) {
            label.classList.add('at-max');
          }
        } else {
          // Still has room to increase
          display.textContent = `(${currentVal})`;
          if (radio) {
            radio.disabled = false;
          }
          if (label) {
            label.classList.remove('at-max');
          }
          anyAvailable = true;
        }
      }
    });
    
    // If no characteristics are available, show a message
    const noOptionsMsg = modal.querySelector('.no-char-options-msg');
    if (!anyAvailable) {
      if (!noOptionsMsg) {
        const msg = document.createElement('p');
        msg.className = 'no-char-options-msg';
        msg.textContent = 'All characteristics are at their species maximum.';
        modal.querySelector('.char-increase-options').appendChild(msg);
      }
    } else if (noOptionsMsg) {
      noOptionsMsg.remove();
    }
    
    // Store the rank
    modal.dataset.rank = rank;
    
    // Reset selection
    modal.querySelectorAll('input[name="char-increase"]').forEach(radio => {
      radio.checked = false;
    });
    document.getElementById('char-increase-confirm').disabled = true;
    
    // Show modal
    modal.classList.remove('hidden');
  },

  /**
   * Close the characteristic increase modal
   */
  closeCharacteristicIncreaseModal() {
    const modal = document.getElementById('characteristic-increase-modal');
    if (modal) {
      modal.classList.add('hidden');
    }
    // Clear pending unlock if cancelled
    this.pendingAbilityUnlock = null;
  },

  /**
   * Confirm the characteristic increase selection
   */
  confirmCharacteristicIncrease() {
    const modal = document.getElementById('characteristic-increase-modal');
    const selected = modal.querySelector('input[name="char-increase"]:checked');
    if (!selected) return;
    
    const charName = selected.value; // e.g., "STR"
    const rank = parseInt(modal.dataset.rank, 10);
    
    // Get current value and increase it
    const charInput = document.getElementById(`${charName.toLowerCase()}-value`);
    if (charInput) {
      const currentVal = parseInt(charInput.value, 10) || 0;
      const newVal = currentVal + 1;
      charInput.value = newVal;
      
      // IMPORTANT: Also update the character data object (used by recalculateAll)
      if (this.character.attributes) {
        this.character.attributes[charName] = newVal;
      }
      
      // Trigger recalculations FIRST (this updates BASE values)
      charInput.dispatchEvent(new Event('input', { bubbles: true }));
      charInput.dispatchEvent(new Event('change', { bubbles: true }));
      
      // Update all skill percentages AFTER recalculations complete
      // Use setTimeout to ensure recalculations finish first
      setTimeout(() => {
        this.updateSkillPercentagesForCharacteristic(charName);
      }, 50);
    }
    
    // Track the characteristic increase
    if (!this.character.characteristicIncreases) {
      this.character.characteristicIncreases = [];
    }
    this.character.characteristicIncreases.push({ rank, char: charName });
    
    // Build the ability name with all increases
    const abilityDisplayName = this.buildCharacteristicIncreaseName();
    
    // Close modal
    modal.classList.add('hidden');
    
    // Now finalize the ability unlock with the other abilities
    const pending = this.pendingAbilityUnlock;
    if (pending) {
      // Add the characteristic increase ability to the list
      const allAbilities = [...pending.abilities];
      const sourceClass = pending.sourceClass || '';
      
      // Add to acquired abilities tracking (use base name for prereq checking)
      if (!this.character.acquiredAbilities) {
        this.character.acquiredAbilities = [];
      }
      
      // Add other abilities
      allAbilities.forEach(name => {
        if (!this.character.acquiredAbilities.includes(name)) {
          this.character.acquiredAbilities.push(name);
        }
      });
      
      // Add abilities to sheet (Language abilities go to Languages section)
      allAbilities.forEach(name => {
        if (name.toLowerCase().startsWith('language (')) {
          const match = name.match(/Language \(([^)]+)\)/i);
          if (match) {
            this.addLanguageIfNotExists(match[1], sourceClass);
          }
        } else {
          this.addAbilityToSheet(name);
        }
      });
      
      // Update or add the Characteristic Increase ability on sheet
      this.updateCharacteristicIncreaseOnSheet(abilityDisplayName);
      
      // Deduct EXP rolls
      const expRollsInput = document.getElementById('exp-rolls');
      if (expRollsInput) {
        const currentExp = parseInt(expRollsInput.value, 10) || 0;
        expRollsInput.value = Math.max(0, currentExp - pending.totalCost);
        expRollsInput.dispatchEvent(new Event('input', { bubbles: true }));
      }
      
      // Recalculate everything
      this.recalculateAll();
      
      // Show success message
      const allNames = [...allAbilities];
      allNames.push(`Characteristic Increase (+1 ${charName.toUpperCase()})`);
      
      alert(`Unlocked ${allNames.length} ability${allNames.length > 1 ? 'ies' : ''}:\n\n• ${allNames.join('\n• ')}\n\nSpent ${pending.totalCost} EXP Rolls.\n\nAbilities added to Special Abilities on Combat page.`);
      
      this.pendingAbilityUnlock = null;
      this.scheduleAutoSave();
    }
  },

  /**
   * Update all skill percentages when a characteristic increases
   * @param {string} charName - The characteristic that increased (e.g., "STR")
   */
  updateSkillPercentagesForCharacteristic(charName) {
    const charUpper = charName.toUpperCase();
    
    // Standard skills (uses skill-name-current for editable percent)
    const standardSkillIds = {
      athletics: 'athletics-current',
      boating: 'boating-current',
      brawn: 'brawn-current',
      conceal: 'conceal-current',
      customs: 'customs-current',
      dance: 'dance-current',
      deceit: 'deceit-current',
      drive: 'drive-current',
      endurance: 'endurance-current',
      evade: 'evade-current',
      firstAid: 'first-aid-current',
      influence: 'influence-current',
      insight: 'insight-current',
      locale: 'locale-current',
      perception: 'perception-current',
      ride: 'ride-current',
      sing: 'sing-current',
      stealth: 'stealth-current',
      swim: 'swim-current',
      willpower: 'willpower-current'
    };
    
    // Check standard skills
    if (typeof SKILL_DEFINITIONS !== 'undefined' && SKILL_DEFINITIONS.standard) {
      Object.entries(SKILL_DEFINITIONS.standard).forEach(([key, skill]) => {
        if (skill.attrs && skill.attrs.includes(charUpper)) {
          const inputId = standardSkillIds[key];
          if (inputId) {
            const input = document.getElementById(inputId);
            if (input && input.value !== '' && input.value !== null) {
              const increment = skill.multiplier === 2 ? 2 : 1;
              const currentVal = parseInt(input.value, 10) || 0;
              input.value = currentVal + increment;
              input.dispatchEvent(new Event('input', { bubbles: true }));
              input.dispatchEvent(new Event('change', { bubbles: true }));
            }
          }
        }
      });
    }
    
    // Combat skills
    if (charUpper === 'STR' || charUpper === 'DEX') {
      // Combat Style 1
      const combat1 = document.getElementById('combat-skill-1-percent');
      if (combat1 && combat1.value !== '' && combat1.value !== null) {
        const currentVal = parseInt(combat1.value, 10) || 0;
        combat1.value = currentVal + 1;
        combat1.dispatchEvent(new Event('input', { bubbles: true }));
        combat1.dispatchEvent(new Event('change', { bubbles: true }));
      }
      // Unarmed
      const unarmed = document.getElementById('unarmed-percent');
      if (unarmed && unarmed.value !== '' && unarmed.value !== null) {
        const currentVal = parseInt(unarmed.value, 10) || 0;
        unarmed.value = currentVal + 1;
        unarmed.dispatchEvent(new Event('input', { bubbles: true }));
        unarmed.dispatchEvent(new Event('change', { bubbles: true }));
      }
    }
    
    // Professional skills - check each one (uses prof-skill-X-name and prof-skill-X-current)
    // PROFESSIONAL_SKILL_SLOTS is 22, loop 0-21
    for (let i = 0, _n = this._profSkillRowCount(); i < _n; i++) {
      const skillNameEl = document.getElementById(`prof-skill-${i}-name`);
      const skillPctEl = document.getElementById(`prof-skill-${i}-current`);
      
      if (skillNameEl && skillPctEl && skillNameEl.value && skillPctEl.value !== '' && skillPctEl.value !== null) {
        const skillName = skillNameEl.value.toLowerCase().replace(/\s*\(.*\)/, '').trim();
        const proDef = SKILL_DEFINITIONS.professional?.[skillName];
        
        if (proDef && proDef.attrs && proDef.attrs.includes(charUpper)) {
          const increment = proDef.multiplier === 2 ? 2 : 1;
          const currentVal = parseInt(skillPctEl.value, 10) || 0;
          skillPctEl.value = currentVal + increment;
          skillPctEl.dispatchEvent(new Event('input', { bubbles: true }));
          skillPctEl.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    }
    
    // Magic skills
    const magicSkillIds = {
      channel: { id: 'channel-percent', attrs: ['INT', 'POW'] },
      piety: { id: 'piety-percent', attrs: ['CHA', 'POW'] },
      arcaneCasting: { id: 'arcane-casting-percent', attrs: ['INT', 'POW'] },
      arcaneKnowledge: { id: 'arcane-knowledge-percent', attrs: ['INT'], multiplier: 2 },
      arcaneSorcery: { id: 'arcane-sorcery-percent', attrs: ['CHA', 'POW'] },
      sorcerousWisdom: { id: 'sorcerous-wisdom-percent', attrs: ['CHA', 'INT'] },
      musicianship: { id: 'musicianship-percent', attrs: ['DEX', 'CHA'] },
      lyricalMagic: { id: 'lyrical-magic-percent', attrs: ['CHA', 'POW'] }
    };
    
    Object.entries(magicSkillIds).forEach(([name, skill]) => {
      if (skill.attrs.includes(charUpper)) {
        const input = document.getElementById(skill.id);
        if (input && input.value !== '' && input.value !== null) {
          const increment = skill.multiplier === 2 ? 2 : 1;
          const currentVal = parseInt(input.value, 10) || 0;
          input.value = currentVal + increment;
          input.dispatchEvent(new Event('input', { bubbles: true }));
          input.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    });
    
    // Beliefs (Alignments, Passions, Oaths) - POW or INT or CHA
    if (charUpper === 'POW' || charUpper === 'INT') {
      // Alignments use POW+INT (1-indexed, 2 slots)
      for (let i = 1; i <= 2; i++) {
        const alignPct = document.getElementById(`alignment-${i}-current`);
        if (alignPct && alignPct.value !== '' && alignPct.value !== null) {
          const currentVal = parseInt(alignPct.value, 10) || 0;
          alignPct.value = currentVal + 1;
          alignPct.dispatchEvent(new Event('input', { bubbles: true }));
          alignPct.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
      // Passions use POW+INT (1-indexed, 4 slots)
      for (let i = 1; i <= 4; i++) {
        const passionPct = document.getElementById(`passion-${i}-current`);
        if (passionPct && passionPct.value !== '' && passionPct.value !== null) {
          const currentVal = parseInt(passionPct.value, 10) || 0;
          passionPct.value = currentVal + 1;
          passionPct.dispatchEvent(new Event('input', { bubbles: true }));
          passionPct.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    }
    if (charUpper === 'POW' || charUpper === 'CHA') {
      // Oaths use POW+CHA (1-indexed, 4 slots)
      for (let i = 1; i <= 4; i++) {
        const oathPct = document.getElementById(`oath-${i}-current`);
        if (oathPct && oathPct.value !== '' && oathPct.value !== null) {
          const currentVal = parseInt(oathPct.value, 10) || 0;
          oathPct.value = currentVal + 1;
          oathPct.dispatchEvent(new Event('input', { bubbles: true }));
          oathPct.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    }
    
    // Languages - INT+CHA
    if (charUpper === 'INT' || charUpper === 'CHA') {
      // Native tongue
      const nativePct = document.getElementById('native-tongue-current');
      if (nativePct && nativePct.value !== '' && nativePct.value !== null) {
        const currentVal = parseInt(nativePct.value, 10) || 0;
        nativePct.value = currentVal + 1;
        nativePct.dispatchEvent(new Event('input', { bubbles: true }));
        nativePct.dispatchEvent(new Event('change', { bubbles: true }));
      }
      // Additional languages (2-7)
      for (let i = 2; i <= 7; i++) {
        const langPct = document.getElementById(`language-${i}-current`);
        if (langPct && langPct.value !== '' && langPct.value !== null) {
          const currentVal = parseInt(langPct.value, 10) || 0;
          langPct.value = currentVal + 1;
          langPct.dispatchEvent(new Event('input', { bubbles: true }));
          langPct.dispatchEvent(new Event('change', { bubbles: true }));
        }
      }
    }
    
    // Sync magic skills between pages
    this.syncMagicSkillValues();
  },

  /**
   * Build the display name for Characteristic Increase with all ranks/chars
   */
  buildCharacteristicIncreaseName() {
    const increases = this.character.characteristicIncreases || [];
    if (increases.length === 0) return 'Characteristic Increase';
    
    const parts = increases.map(inc => `Rank ${inc.rank}: ${inc.char.toUpperCase()}`);
    return `Characteristic Increase (${parts.join(', ')})`;
  },

  /**
   * Update or add the Characteristic Increase ability on the sheet
   */
  updateCharacteristicIncreaseOnSheet(displayName) {
    const container = document.getElementById('class-abilities-list');
    if (!container) return;
    
    // Look for existing Characteristic Increase entry
    const inputs = container.querySelectorAll('.class-ability-input');
    for (const input of inputs) {
      if (input.value.toLowerCase().startsWith('characteristic increase')) {
        // Update existing entry
        input.value = displayName;
        this.updateAbilityTooltip(input);
        return;
      }
    }
    
    // Not found, add new
    this.addAbilityToSheet(displayName);
  },

  /**
   * Restore the Characteristic Increase display name on page load
   */
  restoreCharacteristicIncreaseDisplay() {
    const increases = this.character.characteristicIncreases || [];
    if (increases.length === 0) return;
    
    const displayName = this.buildCharacteristicIncreaseName();
    this.updateCharacteristicIncreaseOnSheet(displayName);
  },

  /**
   * Finalize the ability unlock (when no Characteristic Increase is involved)
   */
  finalizeAbilityUnlock(newAbilities, totalCost, sourceClass = '') {
    // Add to acquired abilities tracking
    if (!this.character.acquiredAbilities) {
      this.character.acquiredAbilities = [];
    }
    newAbilities.forEach(name => {
      if (!this.character.acquiredAbilities.includes(name)) {
        this.character.acquiredAbilities.push(name);
      }
    });
    
    // Before adding new abilities, remove any superseded lower-tier versions
    // (e.g., gaining "Defensive Reflexes II" removes "Defensive Reflexes I")
    newAbilities.forEach(name => {
      this.removeSupersededAbility(name);
    });
    
    // Add abilities to the Special Abilities section on Combat page
    // Language abilities are handled specially - they go to Languages section
    newAbilities.forEach(name => {
      if (name.toLowerCase().startsWith('language (')) {
        // Extract language name from "Language (Druids' Cant)" format
        const match = name.match(/Language \(([^)]+)\)/i);
        if (match) {
          this.addLanguageIfNotExists(match[1], sourceClass);
        }
      } else {
        this.addAbilityToSheet(name);
      }
    });
    
    // Clean up any empty rows after adding abilities
    this.compactClassAbilities();
    
    // Check for special actions based on abilities being unlocked
    this.handleUnlockedAbilitySpecialActions(newAbilities);
    
    // Deduct EXP rolls
    const expRollsInput = document.getElementById('exp-rolls');
    if (expRollsInput) {
      const currentExp = parseInt(expRollsInput.value, 10) || 0;
      expRollsInput.value = Math.max(0, currentExp - totalCost);
      expRollsInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
    
    // Close modal and show success
    this.closeUnlockAbilitiesModal();
    
    alert(`Unlocked ${newAbilities.length} ability${newAbilities.length > 1 ? 'ies' : ''}:\n\n• ${newAbilities.join('\n• ')}\n\nSpent ${totalCost} EXP Rolls.\n\nAbilities added to Special Abilities on Combat page.`);
    
    // Refresh all ability section visibility (so newly purchased abilities show their buttons)
    this.checkBerserkRageVisibility();
    this.checkForcefulStrikeVisibility();
    this.checkBruteStrengthVisibility();
    this.checkJustAScratchVisibility();
    this.checkMysticHealingVisibility();
    this.checkPainControlVisibility();
    this.checkNertherWalkVisibility();
    this.checkQuiveringPalmVisibility();
    this.checkPerfectionVisibility();
    this.checkCommandingVisibility();
    this.checkHolyStrikeVisibility();
    this.checkLayOnHandsVisibility();
    this.checkDetectEvilVisibility();
    this.checkCureDiseaseVisibility();
    this.checkDivineProtectionVisibility();
    this.checkCircleOfPowerVisibility();
    this.checkImprovedAimVisibility();
    this.checkSpeciesEnemyVisibility();
    this.checkMentalStrengthVisibility();
    this.checkTurnUndeadVisibility();
    this.checkMonkAbilitiesVisibility();
    
    // Auto-save
    this.scheduleAutoSave();
  },
  
  /**
   * Handle special actions when specific abilities are unlocked
   */
  handleUnlockedAbilitySpecialActions(abilities) {
    const normalizedAbilities = abilities.map(a => a.toLowerCase().trim());
    
    // Check for Druid Rank 1 abilities - add Druids' Cant
    const druidRank1 = ['divine spellcasting', 'identify plants and animals', 'identify pure water'];
    const hasDruidAbility = normalizedAbilities.some(a => druidRank1.includes(a));
    const isDruid = this.getCurrentClasses().includes('druid');
    
    if (hasDruidAbility && isDruid) {
      this.addLanguageIfNotExists("Druids' Cant");
    }
    
    // Check for Rogue Rank 1 abilities - add Thieves' Cant
    const rogueRank1 = ['climb walls', 'hide in shadows', 'sneak attack', 'subterfuge'];
    const hasRogueAbility = normalizedAbilities.some(a => rogueRank1.includes(a));
    const isRogue = this.getCurrentClasses().includes('rogue');
    
    if (hasRogueAbility && isRogue) {
      this.addLanguageIfNotExists("Thieves' Cant");
    }
  },

  /**
   * Process the passion/alignment/oath strengthening - reuse the skill improvement flow
   */
  processPassionStrengthening() {
    const checked = document.querySelectorAll('#strengthen-passions-modal input[name="strengthen-passion"]:checked');
    
    if (checked.length === 0) return;
    
    // Gather selected items with their display names
    // Reuse skillsToImprove since the improvement process is the same
    this.skillsToImprove = Array.from(checked).map(cb => {
      const row = cb.closest('.skill-checkbox-row');
      const nameSpan = row.querySelector('.skill-name');
      return {
        id: cb.value,
        name: nameSpan?.textContent || cb.value,
        currentValue: parseInt(cb.dataset.skillValue, 10) || 0
      };
    });
    
    // Close the selection modal and open the roll method modal
    this.closeStrengthenPassionsModal();
    this.openRollMethodModal();
  },

  /**
   * Process the skill improvement rolls - show the roll method selection modal
   */
  processSkillImprovement() {
    const checked = document.querySelectorAll('#improve-skills-modal input[name="improve-skill"]:checked');
    
    if (checked.length === 0) return;
    
    // Gather selected skills with their display names
    this.skillsToImprove = Array.from(checked).map(cb => {
      const row = cb.closest('.skill-checkbox-row');
      const nameSpan = row.querySelector('.skill-name');
      return {
        id: cb.value,
        name: nameSpan?.textContent || cb.value,
        currentValue: parseInt(cb.dataset.skillValue, 10) || 0
      };
    });
    
    // Close the selection modal and open the roll method modal
    this.closeImproveSkillsModal();
    this.openRollMethodModal();
  },

  /**
   * Open the roll method selection modal
   */
  openRollMethodModal() {
    let modal = document.getElementById('roll-method-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'roll-method-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content roll-method-modal-content">
          <div class="modal-header">
            <h3>Skill Improvement</h3>
            <button class="modal-close" id="roll-method-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <h4>Selected Skills to Improve:</h4>
            <div class="selected-skills-list" id="selected-skills-list"></div>
            <div class="roll-method-choice">
              <p>How would you like to roll?</p>
              <div class="roll-method-buttons">
                <button type="button" class="btn btn-primary" id="btn-roll-here">Roll Here</button>
                <button type="button" class="btn btn-secondary" id="btn-roll-myself">I'll Roll Myself</button>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="roll-method-back">Back</button>
            <button type="button" class="btn btn-secondary" id="roll-method-cancel">Cancel</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Close handlers
      document.getElementById('roll-method-modal-close').addEventListener('click', () => this.closeRollMethodModal());
      modal.addEventListener('click', (e) => { if (e.target === modal) this.closeRollMethodModal(); });
      
      // Back button
      document.getElementById('roll-method-back').addEventListener('click', () => {
        this.closeRollMethodModal();
        this.openImproveSkillsModal();
      });
      
      // Cancel button
      document.getElementById('roll-method-cancel').addEventListener('click', () => this.closeRollMethodModal());
      
      // Roll here button
      document.getElementById('btn-roll-here').addEventListener('click', () => {
        this.closeRollMethodModal();
        this.openDiceTypeModal();
      });
      
      // Roll myself button
      document.getElementById('btn-roll-myself').addEventListener('click', () => {
        this.closeRollMethodModal();
        this.openManualEntryModal();
      });
    }
    
    // Populate selected skills list
    const listContainer = document.getElementById('selected-skills-list');
    listContainer.innerHTML = this.skillsToImprove.map(skill => 
      `<div class="selected-skill-item"><span class="skill-name">${skill.name}</span><span class="skill-value">${skill.currentValue}%</span></div>`
    ).join('');
    
    modal.classList.remove('hidden');
  },

  closeRollMethodModal() {
    const modal = document.getElementById('roll-method-modal');
    if (modal) modal.classList.add('hidden');
  },

  /**
   * Open the dice type selection modal (1d4+1 vs 1d6+1)
   */
  openDiceTypeModal() {
    let modal = document.getElementById('dice-type-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'dice-type-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content dice-type-modal-content">
          <div class="modal-header">
            <h3>Improvement Dice</h3>
            <button class="modal-close" id="dice-type-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <p>Which improvement dice are you using?</p>
            <div class="dice-type-buttons">
              <button type="button" class="btn exp-option-btn" id="btn-dice-1d4">
                <span class="dice-type-label">Standard</span>
                <span class="dice-type-value">1d4+1</span>
              </button>
              <button type="button" class="btn exp-option-btn" id="btn-dice-1d6">
                <span class="dice-type-label">Faster Ranking</span>
                <span class="dice-type-value">1d6+1</span>
              </button>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="dice-type-back">Back</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      document.getElementById('dice-type-modal-close').addEventListener('click', () => this.closeDiceTypeModal());
      modal.addEventListener('click', (e) => { if (e.target === modal) this.closeDiceTypeModal(); });
      
      document.getElementById('dice-type-back').addEventListener('click', () => {
        this.closeDiceTypeModal();
        this.openRollMethodModal();
      });
      
      document.getElementById('btn-dice-1d4').addEventListener('click', () => {
        this.improvementDice = '1d4+1';
        this.closeDiceTypeModal();
        this.startAutomaticRolling();
      });
      
      document.getElementById('btn-dice-1d6').addEventListener('click', () => {
        this.improvementDice = '1d6+1';
        this.closeDiceTypeModal();
        this.startAutomaticRolling();
      });
    }
    
    modal.classList.remove('hidden');
  },

  closeDiceTypeModal() {
    const modal = document.getElementById('dice-type-modal');
    if (modal) modal.classList.add('hidden');
  },

  /**
   * Start the automatic rolling process
   */
  startAutomaticRolling() {
    const INT = parseInt(document.getElementById('int-value')?.value, 10) || 0;
    this.rollResults = [];
    this.currentRollIndex = 0;
    
    // Process all skills
    this.skillsToImprove.forEach(skill => {
      // Roll 1d100
      const d100Roll = Math.floor(Math.random() * 100) + 1;
      const totalCheck = d100Roll + INT;
      const success = totalCheck > skill.currentValue;
      
      let improvement = 0;
      let improvementRoll = null;
      
      if (success) {
        // Roll improvement dice on success
        if (this.improvementDice === '1d4+1') {
          improvementRoll = Math.floor(Math.random() * 4) + 1;
        } else {
          improvementRoll = Math.floor(Math.random() * 6) + 1;
        }
        improvement = improvementRoll + 1;
      } else {
        // Still get +1 on failure
        improvement = 1;
      }
      
      this.rollResults.push({
        ...skill,
        d100Roll,
        INT,
        totalCheck,
        success,
        improvementRoll,
        improvement,
        newValue: skill.currentValue + improvement
      });
    });
    
    // Show results
    this.openRollResultsModal();
  },

  /**
   * Open the roll results modal
   */
  openRollResultsModal() {
    let modal = document.getElementById('roll-results-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'roll-results-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content roll-results-modal-content">
          <div class="modal-header">
            <h3>Improvement Results</h3>
            <button class="modal-close" id="roll-results-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="roll-results-list" id="roll-results-list"></div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="roll-results-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="roll-results-apply">Apply Changes</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      document.getElementById('roll-results-modal-close').addEventListener('click', () => this.closeRollResultsModal());
      modal.addEventListener('click', (e) => { if (e.target === modal) this.closeRollResultsModal(); });
      
      document.getElementById('roll-results-cancel').addEventListener('click', () => this.closeRollResultsModal());
      
      document.getElementById('roll-results-apply').addEventListener('click', () => {
        this.applySkillImprovements();
        this.closeRollResultsModal();
      });
    }
    
    // Build results HTML
    const resultsContainer = document.getElementById('roll-results-list');
    resultsContainer.innerHTML = this.rollResults.map(result => {
      const successClass = result.success ? 'success' : 'failure';
      const successText = result.success ? '✓ Success!' : '✗ Failed (but +1)';
      const improvementText = result.success 
        ? `+${result.improvement} (${this.improvementDice} = ${result.improvementRoll}+1)`
        : '+1 (consolation)';
      
      return `
        <div class="roll-result-item ${successClass}">
          <div class="roll-result-header">
            <span class="skill-name">${result.name}</span>
            <span class="roll-outcome ${successClass}">${successText}</span>
          </div>
          <div class="roll-result-details">
            <span>Roll: ${result.d100Roll} + ${result.INT} INT = ${result.totalCheck}</span>
            <span>vs ${result.currentValue}%</span>
          </div>
          <div class="roll-result-improvement">
            <span>${improvementText}</span>
            <span class="new-value">${result.currentValue}% → ${result.newValue}%</span>
          </div>
        </div>
      `;
    }).join('');
    
    modal.classList.remove('hidden');
  },

  closeRollResultsModal() {
    const modal = document.getElementById('roll-results-modal');
    if (modal) modal.classList.add('hidden');
  },

  /**
   * Open the manual entry modal
   */
  openManualEntryModal() {
    let modal = document.getElementById('manual-entry-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'manual-entry-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content manual-entry-modal-content">
          <div class="modal-header">
            <h3>Manual Skill Improvement</h3>
            <button class="modal-close" id="manual-entry-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <p class="manual-entry-instructions">Enter the amount to add to each skill:</p>
            <div class="manual-entry-list" id="manual-entry-list"></div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="manual-entry-back">Back</button>
            <button type="button" class="btn btn-secondary" id="manual-entry-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="manual-entry-apply">Apply Changes</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      document.getElementById('manual-entry-modal-close').addEventListener('click', () => this.closeManualEntryModal());
      modal.addEventListener('click', (e) => { if (e.target === modal) this.closeManualEntryModal(); });
      
      document.getElementById('manual-entry-back').addEventListener('click', () => {
        this.closeManualEntryModal();
        this.openRollMethodModal();
      });
      
      document.getElementById('manual-entry-cancel').addEventListener('click', () => this.closeManualEntryModal());
      
      document.getElementById('manual-entry-apply').addEventListener('click', () => {
        this.applyManualImprovements();
        this.closeManualEntryModal();
      });
    }
    
    // Build entry list
    const listContainer = document.getElementById('manual-entry-list');
    listContainer.innerHTML = this.skillsToImprove.map((skill, index) => `
      <div class="manual-entry-row">
        <span class="skill-name">${skill.name}</span>
        <span class="skill-current">${skill.currentValue}%</span>
        <span class="entry-plus">+</span>
        <input type="number" class="manual-entry-input" id="manual-entry-${index}" min="0" max="99" value="0" data-skill-id="${skill.id}">
      </div>
    `).join('');
    
    modal.classList.remove('hidden');
  },

  closeManualEntryModal() {
    const modal = document.getElementById('manual-entry-modal');
    if (modal) modal.classList.add('hidden');
  },

  /**
   * Apply skill improvements from automatic rolling
   */
  applySkillImprovements() {
    console.log('Applying skill improvements:', this.rollResults);
    this.rollResults.forEach(result => {
      // Always apply - everyone gets at least +1
      console.log(`Applying to ${result.id}: improvement=${result.improvement}, newValue=${result.newValue}`);
      if (result.improvement > 0) {
        this.updateSkillValue(result.id, result.newValue);
      }
    });
    
    // Deduct EXP rolls
    const expRollsInput = document.getElementById('exp-rolls');
    if (expRollsInput) {
      const current = parseInt(expRollsInput.value, 10) || 0;
      expRollsInput.value = Math.max(0, current - this.skillsToImprove.length);
    }
    
    this.scheduleAutoSave();
    alert('Skill improvements applied!');
  },

  /**
   * Apply manual skill improvements
   */
  applyManualImprovements() {
    this.skillsToImprove.forEach((skill, index) => {
      const input = document.getElementById(`manual-entry-${index}`);
      const improvement = parseInt(input?.value, 10) || 0;
      if (improvement > 0) {
        const newValue = skill.currentValue + improvement;
        this.updateSkillValue(skill.id, newValue);
      }
    });
    
    // Deduct EXP rolls
    const expRollsInput = document.getElementById('exp-rolls');
    if (expRollsInput) {
      const current = parseInt(expRollsInput.value, 10) || 0;
      expRollsInput.value = Math.max(0, current - this.skillsToImprove.length);
    }
    
    this.scheduleAutoSave();
    alert('Skill improvements applied!');
  },

  /**
   * Update a skill value on the character sheet
   */
  updateSkillValue(skillId, newValue) {
    // Parse skill ID format: "standard:skillname", "prof:index", "combat", "magic:id", "alignment:index", "passion:index", "oath:index"
    const [type, id] = skillId.split(':');
    let el = null;
    
    // Special handling for Evade with display bonuses (Artful Dodger, Lightning Reflexes)
    const hasEvadeDisplayBonus = type === 'standard' && id === 'evade' && 
      (this.artfulDodgerDisplayed || this.lightningReflexesDisplayed);
    
    if (hasEvadeDisplayBonus) {
      // Remove display bonuses, set new base value, then re-apply
      el = document.getElementById('evade-current');
      if (el) {
        // Remove Artful Dodger display bonus if present
        if (this.artfulDodgerDisplayed) {
          this.artfulDodgerDisplayed = false;
          el.classList.remove('artful-dodger-bonus');
        }
        // Remove Lightning Reflexes display bonus if present
        if (this.lightningReflexesDisplayed) {
          this.lightningReflexesDisplayed = false;
          el.classList.remove('lightning-reflexes-bonus');
          this._lightningReflexesBonus = 0;
        }
        el.title = '';
        el.value = newValue;
        el.dataset.originalValue = newValue;
        this.character.standardSkills[this.camelCase(id)] = newValue.toString();
        // Re-apply display bonuses
        this.updateArtfulDodgerDisplay();
        this.updateLightningReflexesDisplay();
        console.log(`Updated ${skillId} to ${newValue} (Evade display bonuses re-applied)`);
      }
    } else if (type === 'standard') {
      // Standard skills use {id}-current, except unarmed which uses unarmed-percent
      if (id === 'unarmed') {
        el = document.getElementById('unarmed-percent');
      } else {
        el = document.getElementById(`${id}-current`);
      }
    } else if (type === 'prof') {
      // Professional skills use prof-skill-{index}-current
      el = document.getElementById(`prof-skill-${id}-current`);
    } else if (skillId === 'combat') {
      // Combat skill
      el = document.getElementById('combat-skill-1-percent');
    } else if (type === 'magic') {
      // Magical skills
      el = document.getElementById(id);
    } else if (type === 'alignment') {
      // Alignment uses alignment-{index}-current
      el = document.getElementById(`alignment-${id}-current`);
    } else if (type === 'passion') {
      // Passions use passion-{index}-current
      el = document.getElementById(`passion-${id}-current`);
    } else if (type === 'oath') {
      // Oaths use oath-{index}-current
      el = document.getElementById(`oath-${id}-current`);
    }
    
    if (el && !hasEvadeDisplayBonus) {
      el.value = newValue;
      // Dispatch input event to trigger any listeners
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
      console.log(`Updated ${skillId} to ${newValue}`);
    } else if (!el) {
      console.warn(`Could not find element for skill: ${skillId}`);
    }
    
    // Trigger recalculation
    this.recalculateAll();
  },

  /**
   * Open the Learn New Skills modal
   */
  openLearnNewSkillsModal() {
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    
    // Skills that cannot be learned this way
    const excludedSkills = [
      'arcane casting', 'arcane sorcery', 'channel', 'lyrical magic', 
      'mysticism', 'psychic manipulation', 'sorcerous wisdom', 'arcane knowledge'
    ];
    
    // Skills that need specialties
    const specialtySkills = ['art', 'craft', 'lore'];
    
    // Get currently known professional skills
    const knownSkills = new Set();
    for (let i = 0; i < 20; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      if (nameInput && nameInput.value.trim()) {
        // Get base skill name (before parentheses)
        const baseName = nameInput.value.trim().toLowerCase().split('(')[0].trim();
        knownSkills.add(baseName);
      }
    }
    
    // Get known languages
    const knownLanguages = new Set();
    const nativeTongue = document.getElementById('native-tongue-name')?.value?.trim();
    if (nativeTongue) knownLanguages.add(nativeTongue.toLowerCase());
    for (let i = 2; i <= 5; i++) {
      const langName = document.getElementById(`language-${i}-name`)?.value?.trim();
      if (langName) knownLanguages.add(langName.toLowerCase());
    }
    
    // Build list of available professional skills
    const availableSkills = [];
    if (typeof SKILL_DEFINITIONS !== 'undefined' && SKILL_DEFINITIONS.professional) {
      for (const [skillKey, skillData] of Object.entries(SKILL_DEFINITIONS.professional)) {
        // Skip excluded skills
        if (excludedSkills.includes(skillKey)) continue;
        
        // Skip language (handled separately)
        if (skillKey === 'language') continue;
        
        // For specialty skills, always show them
        if (specialtySkills.includes(skillKey)) {
          availableSkills.push({
            key: skillKey,
            name: this.toTitleCase(skillKey),
            formula: skillData.formula,
            needsSpecialty: true
          });
        } else if (!knownSkills.has(skillKey)) {
          // For non-specialty skills, only show if not known
          availableSkills.push({
            key: skillKey,
            name: this.toTitleCase(skillKey),
            formula: skillData.formula,
            needsSpecialty: false
          });
        }
      }
    }
    
    // Always add Language option and Piety if they need specialty input
    availableSkills.push({
      key: 'language',
      name: 'Language',
      formula: 'INT+CHA',
      needsSpecialty: true,
      isLanguage: true
    });
    
    // Add Piety with deity prompt if not excluded
    if (!knownSkills.has('piety')) {
      // Remove the plain piety that was added above, we'll add special version
      const pietyIdx = availableSkills.findIndex(s => s.key === 'piety' && !s.needsSpecialty);
      if (pietyIdx > -1) availableSkills.splice(pietyIdx, 1);
      
      availableSkills.push({
        key: 'piety',
        name: 'Piety',
        formula: 'CHA+POW',
        needsSpecialty: true,
        isPiety: true
      });
    }
    
    // Sort alphabetically
    availableSkills.sort((a, b) => a.name.localeCompare(b.name));
    
    // Store for later
    this.availableNewSkills = availableSkills;
    
    // Create modal
    let modal = document.getElementById('learn-skills-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'learn-skills-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content learn-skills-modal-content">
          <div class="modal-header">
            <h3>Learn New Skills</h3>
            <button class="modal-close" id="learn-skills-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="exp-rolls-display">
              <span class="exp-rolls-label">Available EXP Rolls:</span>
              <span class="exp-rolls-value" id="learn-skills-exp-rolls">0</span>
            </div>
            <p class="learn-skills-instructions">Select new skills to learn:</p>
            <div class="learn-skills-list" id="learn-skills-list"></div>
            <p class="learn-skills-cost-note">⚠️ New skills cost <strong>3 Experience Rolls</strong> each.</p>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="learn-skills-back">Back</button>
            <button type="button" class="btn btn-secondary" id="learn-skills-cancel">Cancel</button>
            <button type="button" class="btn btn-primary" id="learn-skills-continue" disabled>Continue</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      document.getElementById('learn-skills-modal-close').addEventListener('click', () => this.closeLearnSkillsModal());
      modal.addEventListener('click', (e) => { if (e.target === modal) this.closeLearnSkillsModal(); });
      
      document.getElementById('learn-skills-back').addEventListener('click', () => {
        this.closeLearnSkillsModal();
        this.openExpModal();
      });
      
      document.getElementById('learn-skills-cancel').addEventListener('click', () => this.closeLearnSkillsModal());
      
      document.getElementById('learn-skills-continue').addEventListener('click', () => {
        this.processLearnNewSkills();
      });
    }
    
    // Populate skill list
    const listContainer = document.getElementById('learn-skills-list');
    listContainer.innerHTML = availableSkills.map((skill, index) => `
      <label class="learn-skill-row">
        <input type="checkbox" name="learn-skill" value="${index}" data-skill-key="${skill.key}">
        <span class="skill-name">${skill.name}</span>
        <span class="skill-formula">(${skill.formula})</span>
      </label>
    `).join('');
    
    // Update EXP display
    document.getElementById('learn-skills-exp-rolls').textContent = expRolls;
    
    // Add checkbox listeners
    document.querySelectorAll('#learn-skills-modal input[name="learn-skill"]').forEach(cb => {
      cb.addEventListener('change', () => this.updateLearnSkillsContinueButton());
    });
    
    modal.classList.remove('hidden');
  },

  closeLearnSkillsModal() {
    const modal = document.getElementById('learn-skills-modal');
    if (modal) modal.classList.add('hidden');
  },

  updateLearnSkillsContinueButton() {
    const checked = document.querySelectorAll('#learn-skills-modal input[name="learn-skill"]:checked');
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    const continueBtn = document.getElementById('learn-skills-continue');
    const cost = checked.length * 3;
    
    if (continueBtn) {
      const canAfford = cost <= expRolls && checked.length > 0;
      continueBtn.disabled = !canAfford;
      continueBtn.textContent = checked.length > 0 
        ? `Continue (${checked.length} skill${checked.length > 1 ? 's' : ''}, ${cost} EXP)`
        : 'Continue';
    }
  },

  /**
   * Process learning new skills - prompt for specialties if needed
   */
  processLearnNewSkills() {
    const checked = document.querySelectorAll('#learn-skills-modal input[name="learn-skill"]:checked');
    if (checked.length === 0) return;
    
    // Gather selected skills
    this.skillsToLearn = Array.from(checked).map(cb => {
      const index = parseInt(cb.value, 10);
      return { ...this.availableNewSkills[index] };
    });
    
    // Check if any need specialty input
    const needsInput = this.skillsToLearn.filter(s => s.needsSpecialty);
    
    if (needsInput.length > 0) {
      this.closeLearnSkillsModal();
      this.openSpecialtyInputModal();
    } else {
      this.closeLearnSkillsModal();
      this.finalizeLearnNewSkills();
    }
  },

  /**
   * Open specialty input modal for skills that need it
   */
  openSpecialtyInputModal() {
    let modal = document.getElementById('specialty-input-modal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'specialty-input-modal';
      modal.className = 'modal-overlay hidden';
      modal.innerHTML = `
        <div class="modal-content specialty-input-modal-content">
          <div class="modal-header">
            <h3>Specify Details</h3>
            <button class="modal-close" id="specialty-input-modal-close">&times;</button>
          </div>
          <div class="modal-body">
            <div class="specialty-input-list" id="specialty-input-list"></div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" id="specialty-input-back">Back</button>
            <button type="button" class="btn btn-primary" id="specialty-input-confirm">Confirm</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      document.getElementById('specialty-input-modal-close').addEventListener('click', () => this.closeSpecialtyInputModal());
      modal.addEventListener('click', (e) => { if (e.target === modal) this.closeSpecialtyInputModal(); });
      
      document.getElementById('specialty-input-back').addEventListener('click', () => {
        this.closeSpecialtyInputModal();
        this.openLearnNewSkillsModal();
      });
      
      document.getElementById('specialty-input-confirm').addEventListener('click', () => {
        this.collectSpecialtiesAndFinalize();
      });
    }
    
    // Build input fields
    const listContainer = document.getElementById('specialty-input-list');
    listContainer.innerHTML = this.skillsToLearn
      .filter(s => s.needsSpecialty)
      .map((skill, index) => {
        let prompt = 'What specialty?';
        let placeholder = 'e.g., Painting, Sculpting';
        
        if (skill.isLanguage) {
          prompt = 'What language do you wish to learn?';
          placeholder = 'e.g., Goblin, Infernal, Elvish';
        } else if (skill.isPiety) {
          prompt = 'What deity? The Ten Thousand are the most common.';
          placeholder = 'e.g., Vitus, Mycr';
        } else if (skill.key === 'lore') {
          placeholder = 'e.g., History, Arcana, Religion';
        } else if (skill.key === 'craft') {
          placeholder = 'e.g., Blacksmithing, Carpentry';
        } else if (skill.key === 'art') {
          placeholder = 'e.g., Painting, Sculpture, Music';
        }
        
        return `
          <div class="specialty-input-row">
            <label class="specialty-label">${skill.name}</label>
            <p class="specialty-prompt">${prompt}</p>
            <input type="text" class="specialty-input" id="specialty-input-${index}" 
                   data-skill-key="${skill.key}" placeholder="${placeholder}">
          </div>
        `;
      }).join('');
    
    modal.classList.remove('hidden');
  },

  closeSpecialtyInputModal() {
    const modal = document.getElementById('specialty-input-modal');
    if (modal) modal.classList.add('hidden');
  },

  collectSpecialtiesAndFinalize() {
    // Collect specialty inputs
    let inputIndex = 0;
    this.skillsToLearn.forEach(skill => {
      if (skill.needsSpecialty) {
        const input = document.getElementById(`specialty-input-${inputIndex}`);
        const specialty = input?.value?.trim() || '';
        if (specialty) {
          skill.specialty = this.toTitleCase(specialty);
          skill.fullName = skill.isLanguage ? specialty : `${skill.name} (${skill.specialty})`;
        } else {
          skill.fullName = skill.name;
        }
        inputIndex++;
      } else {
        skill.fullName = skill.name;
      }
    });
    
    this.closeSpecialtyInputModal();
    this.finalizeLearnNewSkills();
  },

  /**
   * Finalize learning new skills - add to character sheet
   */
  finalizeLearnNewSkills() {
    const expCost = this.skillsToLearn.length * 3;
    const expRolls = parseInt(document.getElementById('exp-rolls')?.value, 10) || 0;
    
    if (expCost > expRolls) {
      alert('Not enough EXP rolls!');
      return;
    }
    
    // Add each skill
    this.skillsToLearn.forEach(skill => {
      if (skill.isLanguage) {
        this.addNewLanguage(skill);
      } else {
        this.addNewProfessionalSkill(skill);
      }
    });
    
    // Deduct EXP
    const expRollsInput = document.getElementById('exp-rolls');
    if (expRollsInput) {
      expRollsInput.value = Math.max(0, expRolls - expCost);
    }
    
    this.recalculateAll();
    this.scheduleAutoSave();
    
    const skillNames = this.skillsToLearn.map(s => s.fullName || s.name).join(', ');
    alert(`Added new skill${this.skillsToLearn.length > 1 ? 's' : ''}: ${skillNames}`);
  },

  /**
   * Add a new professional skill to the character sheet
   */
  addNewProfessionalSkill(skill) {
    const container = document.getElementById('professional-skills-container');
    if (!container) {
      alert('Professional skills container not found!');
      return;
    }
    
    // Find first empty slot by checking all rows
    const rows = container.querySelectorAll('.professional-skill-row');
    for (let i = 0; i < rows.length; i++) {
      const nameInput = document.getElementById(`prof-skill-${i}-name`);
      if (nameInput && !nameInput.value.trim()) {
        const baseInput = document.getElementById(`prof-skill-${i}-base`);
        const baseValSpan = document.getElementById(`prof-skill-${i}-base-val`);
        const currentInput = document.getElementById(`prof-skill-${i}-current`);
        
        // Set the skill name
        nameInput.value = skill.fullName || skill.name;
        
        // Set the formula from skill data
        if (baseInput && skill.formula) {
          baseInput.value = skill.formula;
        }
        
        // Trigger input event to auto-fill formula if not already set
        nameInput.dispatchEvent(new Event('input', { bubbles: true }));
        
        // Trigger blur to finalize
        nameInput.dispatchEvent(new Event('blur', { bubbles: true }));
        
        // Calculate base and set current to base value
        setTimeout(() => {
          // Trigger base calculation
          this.calculateProfessionalSkillBase(i);
          
          // Get the calculated base value and set as current
          setTimeout(() => {
            const baseVal = document.getElementById(`prof-skill-${i}-base-val`);
            const currInput = document.getElementById(`prof-skill-${i}-current`);
            if (baseVal && currInput) {
              const calculatedBase = baseVal.textContent || '';
              if (calculatedBase) {
                currInput.value = calculatedBase;
              }
            }
          }, 50);
        }, 50);
        
        return;
      }
    }
    
    // No empty slot found - add a new row
    this.addProfessionalSkillRow();
    setTimeout(() => {
      // Try again with the new row
      const newRows = container.querySelectorAll('.professional-skill-row');
      const lastIndex = newRows.length - 1;
      const nameInput = document.getElementById(`prof-skill-${lastIndex}-name`);
      const baseInput = document.getElementById(`prof-skill-${lastIndex}-base`);
      
      if (nameInput) {
        nameInput.value = skill.fullName || skill.name;
        if (baseInput && skill.formula) {
          baseInput.value = skill.formula;
        }
        nameInput.dispatchEvent(new Event('input', { bubbles: true }));
        nameInput.dispatchEvent(new Event('blur', { bubbles: true }));
        
        setTimeout(() => {
          this.calculateProfessionalSkillBase(lastIndex);
          setTimeout(() => {
            const baseVal = document.getElementById(`prof-skill-${lastIndex}-base-val`);
            const currInput = document.getElementById(`prof-skill-${lastIndex}-current`);
            if (baseVal && currInput && baseVal.textContent) {
              currInput.value = baseVal.textContent;
            }
          }, 50);
        }, 50);
      }
    }, 100);
  },

  /**
   * Add a new language to the character sheet
   */
  addNewLanguage(skill) {
    const container = document.getElementById('language-container');
    if (!container) {
      alert('Language container not found!');
      return;
    }
    
    // Find first empty language slot (skip native tongue)
    const langRows = container.querySelectorAll('.language-row:not(.native)');
    for (const row of langRows) {
      const nameInput = row.querySelector('.language-name');
      if (nameInput && !nameInput.value.trim()) {
        // Set the language name
        nameInput.value = skill.specialty || skill.fullName || 'New Language';
        
        // Set current to base value
        setTimeout(() => {
          const baseEl = row.querySelector('.language-base');
          const currentInput = row.querySelector('.language-input');
          if (baseEl && currentInput) {
            currentInput.value = baseEl.textContent || '';
          }
        }, 100);
        
        return;
      }
    }
    
    // No empty slots - add a new row
    this.addLanguageRow();
    setTimeout(() => {
      const newRows = container.querySelectorAll('.language-row:not(.native)');
      const lastRow = newRows[newRows.length - 1];
      if (lastRow) {
        const nameInput = lastRow.querySelector('.language-name');
        if (nameInput) {
          nameInput.value = skill.specialty || skill.fullName || 'New Language';
        }
        setTimeout(() => {
          const baseEl = lastRow.querySelector('.language-base');
          const currentInput = lastRow.querySelector('.language-input');
          if (baseEl && currentInput) {
            currentInput.value = baseEl.textContent || '';
          }
        }, 100);
      }
    }, 100);
  }
};

console.log('app.js loaded fully — castSpell available:', typeof App.castSpell);

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  App.init();
});
